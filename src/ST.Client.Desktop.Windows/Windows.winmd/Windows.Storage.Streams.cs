// This file was generated by cswinrt.exe

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using WinRT;
using WinRT.Interop;


#pragma warning disable 0169 // warning CS0169: The field '...' is never used
#pragma warning disable 0649 // warning CS0169: Field '...' is never assigned to
#pragma warning disable CA2207, CA1063, CA1033, CA1001, CA2213

namespace Windows.Storage.Streams
{
    [global::WinRT.WindowsRuntimeType("Windows")]

    [global::WinRT.ProjectedRuntimeClass(nameof(_default))]
    [global::WinRT.ObjectReferenceWrapper(nameof(_inner))]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    public sealed class Buffer : IBuffer, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<Buffer>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private IObjectReference _inner = null;
        private readonly Lazy<IBuffer> _defaultLazy;
        private readonly Dictionary<Type, object> _lazyInterfaces;

        private IBuffer _default => _defaultLazy.Value;

        internal class _IBufferFactory : IWinRTObject
        {
            private IObjectReference _obj;
            private IntPtr ThisPtr => _obj.ThisPtr;
            public _IBufferFactory()
            {
                _obj = ActivationFactory<Buffer>.As(GuidGenerator.GetIID(typeof(Windows.Storage.Streams.IBufferFactory).GetHelperType()));
            }

            private static WeakLazy<_IBufferFactory> _instance = new WeakLazy<_IBufferFactory>();
            internal static _IBufferFactory Instance => _instance.Value;

            IObjectReference IWinRTObject.NativeObject => _obj;
            bool IWinRTObject.HasUnwrappableNativeObject => false;
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();


            public unsafe IntPtr Create(uint capacity)
            {
                IntPtr __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint, out IntPtr, int>**)ThisPtr)[6](ThisPtr, capacity, out __retval));
                return __retval;
            }

        }

        public Buffer(uint capacity) : this(((Func<IObjectReference>)(() => {
            IntPtr ptr = (_IBufferFactory.Instance.Create(capacity));
            try
            {
                return (ComWrappersSupport.GetObjectReferenceForInterface(ptr));
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(ptr);
            }
        }))())
        {
            ComWrappersSupport.RegisterObjectForInterface(this, ThisPtr);
            ComWrappersHelper.Init(_inner, false);
        }

        internal static BaseActivationFactory _factory = new BaseActivationFactory("Windows.Storage.Streams", "Windows.Storage.Streams.Buffer");
        public static I As<I>() => _factory.AsInterface<I>();

        internal class _IBufferStatics : IWinRTObject
        {
            private IObjectReference _obj;
            public _IBufferStatics()
            {
                _obj = (new BaseActivationFactory("Windows.Storage.Streams", "Windows.Storage.Streams.Buffer"))._As(GuidGenerator.GetIID(typeof(Windows.Storage.Streams.IBufferStatics).GetHelperType()));
            }

            private static readonly WeakLazy<_IBufferStatics> _instance = new WeakLazy<_IBufferStatics>();
            internal static IBufferStatics Instance => (IBufferStatics)_instance.Value;

            IObjectReference IWinRTObject.NativeObject => _obj;
            bool IWinRTObject.HasUnwrappableNativeObject => false;
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();
        }

        public static Buffer CreateCopyFromMemoryBuffer(global::Windows.Foundation.IMemoryBuffer input) => _IBufferStatics.Instance.CreateCopyFromMemoryBuffer(input);

        public static global::Windows.Foundation.MemoryBuffer CreateMemoryBufferOverIBuffer(IBuffer input) => _IBufferStatics.Instance.CreateMemoryBufferOverIBuffer(input);

        public static Buffer FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<Buffer>.FromAbi(thisPtr);
        }

        internal Buffer(IObjectReference objRef)
        {
            _inner = objRef.As(GuidGenerator.GetIID(typeof(IBuffer).GetHelperType()));
            _defaultLazy = new Lazy<IBuffer>(() => (IBuffer)new SingleInterfaceOptimizedObject(typeof(IBuffer), _inner));
            _lazyInterfaces = new Dictionary<Type, object>()
            {
            };
        }

        public static bool operator ==(Buffer x, Buffer y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(Buffer x, Buffer y) => !(x == y);
        public bool Equals(Buffer other) => this == other;
        public override bool Equals(object obj) => obj is Buffer that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();

        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();

        private struct InterfaceTag<I>{};

        private IBuffer AsInternal(InterfaceTag<IBuffer> _) => _default;

        uint IBuffer.Capacity {get => Capacity; }
        uint IBuffer.Length {get => Length; set => Length = value; }
        public uint Capacity => _default.Capacity;

        public uint Length
        {
            get => _default.Length;
            set => _default.Length = value;
        }

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || typeof(global::WinRT.IInspectable).GUID == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs<IUnknownVftbl>(iid, out ObjectReference<IUnknownVftbl> objRef) >= 0)
            {
                using (objRef)
                {
                    ppv = objRef.GetRef();
                    return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
                }
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    public enum ByteOrder : int
    {
        LittleEndian = unchecked((int)0),
        BigEndian = unchecked((int)0x1),
    }
    [global::WinRT.WindowsRuntimeType("Windows")]

    [global::WinRT.ProjectedRuntimeClass(nameof(_default))]
    [global::WinRT.ObjectReferenceWrapper(nameof(_inner))]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    public sealed class DataReader : IDataReader, global::System.IDisposable, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<DataReader>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private IObjectReference _inner = null;
        private readonly Lazy<IDataReader> _defaultLazy;
        private readonly Dictionary<Type, object> _lazyInterfaces;

        private IDataReader _default => _defaultLazy.Value;

        internal class _IDataReaderFactory : IWinRTObject
        {
            private IObjectReference _obj;
            private IntPtr ThisPtr => _obj.ThisPtr;
            public _IDataReaderFactory()
            {
                _obj = ActivationFactory<DataReader>.As(GuidGenerator.GetIID(typeof(Windows.Storage.Streams.IDataReaderFactory).GetHelperType()));
            }

            private static WeakLazy<_IDataReaderFactory> _instance = new WeakLazy<_IDataReaderFactory>();
            internal static _IDataReaderFactory Instance => _instance.Value;

            IObjectReference IWinRTObject.NativeObject => _obj;
            bool IWinRTObject.HasUnwrappableNativeObject => false;
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();


            public unsafe IntPtr CreateDataReader(IInputStream inputStream)
            {
                IObjectReference __inputStream = default;
                IntPtr __retval = default;
                try
                {
                    __inputStream = MarshalInterface<IInputStream>.CreateMarshaler(inputStream);
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, MarshalInterface<IInputStream>.GetAbi(__inputStream), out __retval));
                    return __retval;
                }
                finally
                {
                    MarshalInterface<IInputStream>.DisposeMarshaler(__inputStream);
                }
            }

        }

        public DataReader(IInputStream inputStream) : this(((Func<IObjectReference>)(() => {
            IntPtr ptr = (_IDataReaderFactory.Instance.CreateDataReader(inputStream));
            try
            {
                return (ComWrappersSupport.GetObjectReferenceForInterface(ptr));
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(ptr);
            }
        }))())
        {
            ComWrappersSupport.RegisterObjectForInterface(this, ThisPtr);
            ComWrappersHelper.Init(_inner, false);
        }

        internal static BaseActivationFactory _factory = new BaseActivationFactory("Windows.Storage.Streams", "Windows.Storage.Streams.DataReader");
        public static I As<I>() => _factory.AsInterface<I>();

        internal class _IDataReaderStatics : IWinRTObject
        {
            private IObjectReference _obj;
            public _IDataReaderStatics()
            {
                _obj = (new BaseActivationFactory("Windows.Storage.Streams", "Windows.Storage.Streams.DataReader"))._As(GuidGenerator.GetIID(typeof(Windows.Storage.Streams.IDataReaderStatics).GetHelperType()));
            }

            private static readonly WeakLazy<_IDataReaderStatics> _instance = new WeakLazy<_IDataReaderStatics>();
            internal static IDataReaderStatics Instance => (IDataReaderStatics)_instance.Value;

            IObjectReference IWinRTObject.NativeObject => _obj;
            bool IWinRTObject.HasUnwrappableNativeObject => false;
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();
        }

        public static DataReader FromBuffer(IBuffer buffer) => _IDataReaderStatics.Instance.FromBuffer(buffer);

        public static DataReader FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<DataReader>.FromAbi(thisPtr);
        }

        internal DataReader(IObjectReference objRef)
        {
            _inner = objRef.As(GuidGenerator.GetIID(typeof(IDataReader).GetHelperType()));
            _defaultLazy = new Lazy<IDataReader>(() => (IDataReader)new SingleInterfaceOptimizedObject(typeof(IDataReader), _inner));
            _lazyInterfaces = new Dictionary<Type, object>()
            {
                {typeof(global::System.IDisposable), new Lazy<global::System.IDisposable>(() => (global::System.IDisposable)(object)new SingleInterfaceOptimizedObject(typeof(global::System.IDisposable), _inner ?? ((IWinRTObject)this).NativeObject))},
            };
        }

        public static bool operator ==(DataReader x, DataReader y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(DataReader x, DataReader y) => !(x == y);
        public bool Equals(DataReader other) => this == other;
        public override bool Equals(object obj) => obj is DataReader that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();

        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();

        private struct InterfaceTag<I>{};

        private IDataReader AsInternal(InterfaceTag<IDataReader> _) => _default;

        public byte ReadByte() => _default.ReadByte();

        byte IDataReader.ReadByte() => ReadByte();
        public void ReadBytes(byte[] value) => _default.ReadBytes(value);

        void IDataReader.ReadBytes(byte[] value) => ReadBytes(value);
        public IBuffer ReadBuffer(uint length) => _default.ReadBuffer(length);

        IBuffer IDataReader.ReadBuffer(uint length) => ReadBuffer(length);
        public bool ReadBoolean() => _default.ReadBoolean();

        bool IDataReader.ReadBoolean() => ReadBoolean();
        public Guid ReadGuid() => _default.ReadGuid();

        Guid IDataReader.ReadGuid() => ReadGuid();
        public short ReadInt16() => _default.ReadInt16();

        short IDataReader.ReadInt16() => ReadInt16();
        public int ReadInt32() => _default.ReadInt32();

        int IDataReader.ReadInt32() => ReadInt32();
        public long ReadInt64() => _default.ReadInt64();

        long IDataReader.ReadInt64() => ReadInt64();
        public ushort ReadUInt16() => _default.ReadUInt16();

        ushort IDataReader.ReadUInt16() => ReadUInt16();
        public uint ReadUInt32() => _default.ReadUInt32();

        uint IDataReader.ReadUInt32() => ReadUInt32();
        public ulong ReadUInt64() => _default.ReadUInt64();

        ulong IDataReader.ReadUInt64() => ReadUInt64();
        public float ReadSingle() => _default.ReadSingle();

        float IDataReader.ReadSingle() => ReadSingle();
        public double ReadDouble() => _default.ReadDouble();

        double IDataReader.ReadDouble() => ReadDouble();
        public string ReadString(uint codeUnitCount) => _default.ReadString(codeUnitCount);

        string IDataReader.ReadString(uint codeUnitCount) => ReadString(codeUnitCount);
        public global::System.DateTimeOffset ReadDateTime() => _default.ReadDateTime();

        global::System.DateTimeOffset IDataReader.ReadDateTime() => ReadDateTime();
        public global::System.TimeSpan ReadTimeSpan() => _default.ReadTimeSpan();

        global::System.TimeSpan IDataReader.ReadTimeSpan() => ReadTimeSpan();
        public DataReaderLoadOperation LoadAsync(uint count) => _default.LoadAsync(count);

        DataReaderLoadOperation IDataReader.LoadAsync(uint count) => LoadAsync(count);
        public IBuffer DetachBuffer() => _default.DetachBuffer();

        IBuffer IDataReader.DetachBuffer() => DetachBuffer();
        public IInputStream DetachStream() => _default.DetachStream();

        IInputStream IDataReader.DetachStream() => DetachStream();
        ByteOrder IDataReader.ByteOrder {get => ByteOrder; set => ByteOrder = value; }
        InputStreamOptions IDataReader.InputStreamOptions {get => InputStreamOptions; set => InputStreamOptions = value; }
        uint IDataReader.UnconsumedBufferLength {get => UnconsumedBufferLength; }
        UnicodeEncoding IDataReader.UnicodeEncoding {get => UnicodeEncoding; set => UnicodeEncoding = value; }
        private global::System.IDisposable AsInternal(InterfaceTag<global::System.IDisposable> _) =>  ((Lazy<global::System.IDisposable>)_lazyInterfaces[typeof(global::System.IDisposable)]).Value;

        public void Dispose() => AsInternal(new InterfaceTag<global::System.IDisposable>()).Dispose();

        public ByteOrder ByteOrder
        {
            get => _default.ByteOrder;
            set => _default.ByteOrder = value;
        }

        public InputStreamOptions InputStreamOptions
        {
            get => _default.InputStreamOptions;
            set => _default.InputStreamOptions = value;
        }

        public uint UnconsumedBufferLength => _default.UnconsumedBufferLength;

        public UnicodeEncoding UnicodeEncoding
        {
            get => _default.UnicodeEncoding;
            set => _default.UnicodeEncoding = value;
        }

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || typeof(global::WinRT.IInspectable).GUID == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs<IUnknownVftbl>(iid, out ObjectReference<IUnknownVftbl> objRef) >= 0)
            {
                using (objRef)
                {
                    ppv = objRef.GetRef();
                    return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
                }
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]

    [global::WinRT.ProjectedRuntimeClass(nameof(_default))]
    [global::WinRT.ObjectReferenceWrapper(nameof(_inner))]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    public sealed class DataReaderLoadOperation : global::Windows.Foundation.IAsyncOperation<uint>, global::Windows.Foundation.IAsyncInfo, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<DataReaderLoadOperation>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private IObjectReference _inner = null;
        private readonly Lazy<global::Windows.Foundation.IAsyncOperation<uint>> _defaultLazy;
        private readonly Dictionary<Type, object> _lazyInterfaces;

        private global::Windows.Foundation.IAsyncOperation<uint> _default => _defaultLazy.Value;

        public static DataReaderLoadOperation FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<DataReaderLoadOperation>.FromAbi(thisPtr);
        }

        internal DataReaderLoadOperation(IObjectReference objRef)
        {
            _inner = objRef.As(GuidGenerator.GetIID(typeof(global::Windows.Foundation.IAsyncOperation<uint>).GetHelperType()));
            _defaultLazy = new Lazy<global::Windows.Foundation.IAsyncOperation<uint>>(() => (global::Windows.Foundation.IAsyncOperation<uint>)new SingleInterfaceOptimizedObject(typeof(global::Windows.Foundation.IAsyncOperation<uint>), _inner));
            _lazyInterfaces = new Dictionary<Type, object>()
            {
                {typeof(global::Windows.Foundation.IAsyncInfo), new Lazy<global::Windows.Foundation.IAsyncInfo>(() => (global::Windows.Foundation.IAsyncInfo)(object)new SingleInterfaceOptimizedObject(typeof(global::Windows.Foundation.IAsyncInfo), _inner ?? ((IWinRTObject)this).NativeObject))},
            };
        }

        public static bool operator ==(DataReaderLoadOperation x, DataReaderLoadOperation y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(DataReaderLoadOperation x, DataReaderLoadOperation y) => !(x == y);
        public bool Equals(DataReaderLoadOperation other) => this == other;
        public override bool Equals(object obj) => obj is DataReaderLoadOperation that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();

        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();

        private struct InterfaceTag<I>{};

        private global::Windows.Foundation.IAsyncOperation<uint> AsInternal(InterfaceTag<global::Windows.Foundation.IAsyncOperation<uint>> _) => _default;

        public uint GetResults() => _default.GetResults();

        uint global::Windows.Foundation.IAsyncOperation<uint>.GetResults() => GetResults();
        global::Windows.Foundation.AsyncOperationCompletedHandler<uint> global::Windows.Foundation.IAsyncOperation<uint>.Completed {get => Completed; set => Completed = value; }
        private global::Windows.Foundation.IAsyncInfo AsInternal(InterfaceTag<global::Windows.Foundation.IAsyncInfo> _) =>  ((Lazy<global::Windows.Foundation.IAsyncInfo>)_lazyInterfaces[typeof(global::Windows.Foundation.IAsyncInfo)]).Value;

        public void Cancel() => AsInternal(new InterfaceTag<global::Windows.Foundation.IAsyncInfo>()).Cancel();

        void global::Windows.Foundation.IAsyncInfo.Cancel() => Cancel();
        public void Close() => AsInternal(new InterfaceTag<global::Windows.Foundation.IAsyncInfo>()).Close();

        void global::Windows.Foundation.IAsyncInfo.Close() => Close();
        global::System.Exception global::Windows.Foundation.IAsyncInfo.ErrorCode {get => ErrorCode; }
        uint global::Windows.Foundation.IAsyncInfo.Id {get => Id; }
        global::Windows.Foundation.AsyncStatus global::Windows.Foundation.IAsyncInfo.Status {get => Status; }
        public global::Windows.Foundation.AsyncOperationCompletedHandler<uint> Completed
        {
            get => _default.Completed;
            set => _default.Completed = value;
        }

        public global::System.Exception ErrorCode => AsInternal(new InterfaceTag<global::Windows.Foundation.IAsyncInfo>()).ErrorCode;

        public uint Id => AsInternal(new InterfaceTag<global::Windows.Foundation.IAsyncInfo>()).Id;

        public global::Windows.Foundation.AsyncStatus Status => AsInternal(new InterfaceTag<global::Windows.Foundation.IAsyncInfo>()).Status;

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || typeof(global::WinRT.IInspectable).GUID == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs<IUnknownVftbl>(iid, out ObjectReference<IUnknownVftbl> objRef) >= 0)
            {
                using (objRef)
                {
                    ppv = objRef.GetRef();
                    return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
                }
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]

    [global::WinRT.ProjectedRuntimeClass(nameof(_default))]
    [global::WinRT.ObjectReferenceWrapper(nameof(_inner))]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    public sealed class DataWriter : IDataWriter, global::System.IDisposable, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<DataWriter>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private IObjectReference _inner = null;
        private readonly Lazy<IDataWriter> _defaultLazy;
        private readonly Dictionary<Type, object> _lazyInterfaces;

        private IDataWriter _default => _defaultLazy.Value;

        public DataWriter() : this((ActivationFactory<DataWriter>.ActivateInstance<IUnknownVftbl>()))
        {
            ComWrappersSupport.RegisterObjectForInterface(this, ThisPtr);
            ComWrappersHelper.Init(_inner, false);
        }

        internal class _IDataWriterFactory : IWinRTObject
        {
            private IObjectReference _obj;
            private IntPtr ThisPtr => _obj.ThisPtr;
            public _IDataWriterFactory()
            {
                _obj = ActivationFactory<DataWriter>.As(GuidGenerator.GetIID(typeof(Windows.Storage.Streams.IDataWriterFactory).GetHelperType()));
            }

            private static WeakLazy<_IDataWriterFactory> _instance = new WeakLazy<_IDataWriterFactory>();
            internal static _IDataWriterFactory Instance => _instance.Value;

            IObjectReference IWinRTObject.NativeObject => _obj;
            bool IWinRTObject.HasUnwrappableNativeObject => false;
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();


            public unsafe IntPtr CreateDataWriter(IOutputStream outputStream)
            {
                IObjectReference __outputStream = default;
                IntPtr __retval = default;
                try
                {
                    __outputStream = MarshalInterface<IOutputStream>.CreateMarshaler(outputStream);
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, MarshalInterface<IOutputStream>.GetAbi(__outputStream), out __retval));
                    return __retval;
                }
                finally
                {
                    MarshalInterface<IOutputStream>.DisposeMarshaler(__outputStream);
                }
            }

        }

        public DataWriter(IOutputStream outputStream) : this(((Func<IObjectReference>)(() => {
            IntPtr ptr = (_IDataWriterFactory.Instance.CreateDataWriter(outputStream));
            try
            {
                return (ComWrappersSupport.GetObjectReferenceForInterface(ptr));
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(ptr);
            }
        }))())
        {
            ComWrappersSupport.RegisterObjectForInterface(this, ThisPtr);
            ComWrappersHelper.Init(_inner, false);
        }

        public static DataWriter FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<DataWriter>.FromAbi(thisPtr);
        }

        internal DataWriter(IObjectReference objRef)
        {
            _inner = objRef.As(GuidGenerator.GetIID(typeof(IDataWriter).GetHelperType()));
            _defaultLazy = new Lazy<IDataWriter>(() => (IDataWriter)new SingleInterfaceOptimizedObject(typeof(IDataWriter), _inner));
            _lazyInterfaces = new Dictionary<Type, object>()
            {
                {typeof(global::System.IDisposable), new Lazy<global::System.IDisposable>(() => (global::System.IDisposable)(object)new SingleInterfaceOptimizedObject(typeof(global::System.IDisposable), _inner ?? ((IWinRTObject)this).NativeObject))},
            };
        }

        public static bool operator ==(DataWriter x, DataWriter y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(DataWriter x, DataWriter y) => !(x == y);
        public bool Equals(DataWriter other) => this == other;
        public override bool Equals(object obj) => obj is DataWriter that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();

        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();

        private struct InterfaceTag<I>{};

        private IDataWriter AsInternal(InterfaceTag<IDataWriter> _) => _default;

        public void WriteByte(byte value) => _default.WriteByte(value);

        void IDataWriter.WriteByte(byte value) => WriteByte(value);
        public void WriteBytes(byte[] value) => _default.WriteBytes(value);

        void IDataWriter.WriteBytes(byte[] value) => WriteBytes(value);
        public void WriteBuffer(IBuffer buffer) => _default.WriteBuffer(buffer);

        void IDataWriter.WriteBuffer(IBuffer buffer) => WriteBuffer(buffer);
        public void WriteBuffer(IBuffer buffer, uint start, uint count) => _default.WriteBuffer(buffer, start, count);

        void IDataWriter.WriteBuffer(IBuffer buffer, uint start, uint count) => WriteBuffer(buffer, start, count);
        public void WriteBoolean(bool value) => _default.WriteBoolean(value);

        void IDataWriter.WriteBoolean(bool value) => WriteBoolean(value);
        public void WriteGuid(Guid value) => _default.WriteGuid(value);

        void IDataWriter.WriteGuid(Guid value) => WriteGuid(value);
        public void WriteInt16(short value) => _default.WriteInt16(value);

        void IDataWriter.WriteInt16(short value) => WriteInt16(value);
        public void WriteInt32(int value) => _default.WriteInt32(value);

        void IDataWriter.WriteInt32(int value) => WriteInt32(value);
        public void WriteInt64(long value) => _default.WriteInt64(value);

        void IDataWriter.WriteInt64(long value) => WriteInt64(value);
        public void WriteUInt16(ushort value) => _default.WriteUInt16(value);

        void IDataWriter.WriteUInt16(ushort value) => WriteUInt16(value);
        public void WriteUInt32(uint value) => _default.WriteUInt32(value);

        void IDataWriter.WriteUInt32(uint value) => WriteUInt32(value);
        public void WriteUInt64(ulong value) => _default.WriteUInt64(value);

        void IDataWriter.WriteUInt64(ulong value) => WriteUInt64(value);
        public void WriteSingle(float value) => _default.WriteSingle(value);

        void IDataWriter.WriteSingle(float value) => WriteSingle(value);
        public void WriteDouble(double value) => _default.WriteDouble(value);

        void IDataWriter.WriteDouble(double value) => WriteDouble(value);
        public void WriteDateTime(global::System.DateTimeOffset value) => _default.WriteDateTime(value);

        void IDataWriter.WriteDateTime(global::System.DateTimeOffset value) => WriteDateTime(value);
        public void WriteTimeSpan(global::System.TimeSpan value) => _default.WriteTimeSpan(value);

        void IDataWriter.WriteTimeSpan(global::System.TimeSpan value) => WriteTimeSpan(value);
        public uint WriteString(string value) => _default.WriteString(value);

        uint IDataWriter.WriteString(string value) => WriteString(value);
        public uint MeasureString(string value) => _default.MeasureString(value);

        uint IDataWriter.MeasureString(string value) => MeasureString(value);
        public DataWriterStoreOperation StoreAsync() => _default.StoreAsync();

        DataWriterStoreOperation IDataWriter.StoreAsync() => StoreAsync();
        public global::Windows.Foundation.IAsyncOperation<bool> FlushAsync() => _default.FlushAsync();

        global::Windows.Foundation.IAsyncOperation<bool> IDataWriter.FlushAsync() => FlushAsync();
        public IBuffer DetachBuffer() => _default.DetachBuffer();

        IBuffer IDataWriter.DetachBuffer() => DetachBuffer();
        public IOutputStream DetachStream() => _default.DetachStream();

        IOutputStream IDataWriter.DetachStream() => DetachStream();
        ByteOrder IDataWriter.ByteOrder {get => ByteOrder; set => ByteOrder = value; }
        UnicodeEncoding IDataWriter.UnicodeEncoding {get => UnicodeEncoding; set => UnicodeEncoding = value; }
        uint IDataWriter.UnstoredBufferLength {get => UnstoredBufferLength; }
        private global::System.IDisposable AsInternal(InterfaceTag<global::System.IDisposable> _) =>  ((Lazy<global::System.IDisposable>)_lazyInterfaces[typeof(global::System.IDisposable)]).Value;

        public void Dispose() => AsInternal(new InterfaceTag<global::System.IDisposable>()).Dispose();

        public ByteOrder ByteOrder
        {
            get => _default.ByteOrder;
            set => _default.ByteOrder = value;
        }

        public UnicodeEncoding UnicodeEncoding
        {
            get => _default.UnicodeEncoding;
            set => _default.UnicodeEncoding = value;
        }

        public uint UnstoredBufferLength => _default.UnstoredBufferLength;

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || typeof(global::WinRT.IInspectable).GUID == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs<IUnknownVftbl>(iid, out ObjectReference<IUnknownVftbl> objRef) >= 0)
            {
                using (objRef)
                {
                    ppv = objRef.GetRef();
                    return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
                }
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]

    [global::WinRT.ProjectedRuntimeClass(nameof(_default))]
    [global::WinRT.ObjectReferenceWrapper(nameof(_inner))]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    public sealed class DataWriterStoreOperation : global::Windows.Foundation.IAsyncOperation<uint>, global::Windows.Foundation.IAsyncInfo, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<DataWriterStoreOperation>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private IObjectReference _inner = null;
        private readonly Lazy<global::Windows.Foundation.IAsyncOperation<uint>> _defaultLazy;
        private readonly Dictionary<Type, object> _lazyInterfaces;

        private global::Windows.Foundation.IAsyncOperation<uint> _default => _defaultLazy.Value;

        public static DataWriterStoreOperation FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<DataWriterStoreOperation>.FromAbi(thisPtr);
        }

        internal DataWriterStoreOperation(IObjectReference objRef)
        {
            _inner = objRef.As(GuidGenerator.GetIID(typeof(global::Windows.Foundation.IAsyncOperation<uint>).GetHelperType()));
            _defaultLazy = new Lazy<global::Windows.Foundation.IAsyncOperation<uint>>(() => (global::Windows.Foundation.IAsyncOperation<uint>)new SingleInterfaceOptimizedObject(typeof(global::Windows.Foundation.IAsyncOperation<uint>), _inner));
            _lazyInterfaces = new Dictionary<Type, object>()
            {
                {typeof(global::Windows.Foundation.IAsyncInfo), new Lazy<global::Windows.Foundation.IAsyncInfo>(() => (global::Windows.Foundation.IAsyncInfo)(object)new SingleInterfaceOptimizedObject(typeof(global::Windows.Foundation.IAsyncInfo), _inner ?? ((IWinRTObject)this).NativeObject))},
            };
        }

        public static bool operator ==(DataWriterStoreOperation x, DataWriterStoreOperation y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(DataWriterStoreOperation x, DataWriterStoreOperation y) => !(x == y);
        public bool Equals(DataWriterStoreOperation other) => this == other;
        public override bool Equals(object obj) => obj is DataWriterStoreOperation that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();

        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();

        private struct InterfaceTag<I>{};

        private global::Windows.Foundation.IAsyncOperation<uint> AsInternal(InterfaceTag<global::Windows.Foundation.IAsyncOperation<uint>> _) => _default;

        public uint GetResults() => _default.GetResults();

        uint global::Windows.Foundation.IAsyncOperation<uint>.GetResults() => GetResults();
        global::Windows.Foundation.AsyncOperationCompletedHandler<uint> global::Windows.Foundation.IAsyncOperation<uint>.Completed {get => Completed; set => Completed = value; }
        private global::Windows.Foundation.IAsyncInfo AsInternal(InterfaceTag<global::Windows.Foundation.IAsyncInfo> _) =>  ((Lazy<global::Windows.Foundation.IAsyncInfo>)_lazyInterfaces[typeof(global::Windows.Foundation.IAsyncInfo)]).Value;

        public void Cancel() => AsInternal(new InterfaceTag<global::Windows.Foundation.IAsyncInfo>()).Cancel();

        void global::Windows.Foundation.IAsyncInfo.Cancel() => Cancel();
        public void Close() => AsInternal(new InterfaceTag<global::Windows.Foundation.IAsyncInfo>()).Close();

        void global::Windows.Foundation.IAsyncInfo.Close() => Close();
        global::System.Exception global::Windows.Foundation.IAsyncInfo.ErrorCode {get => ErrorCode; }
        uint global::Windows.Foundation.IAsyncInfo.Id {get => Id; }
        global::Windows.Foundation.AsyncStatus global::Windows.Foundation.IAsyncInfo.Status {get => Status; }
        public global::Windows.Foundation.AsyncOperationCompletedHandler<uint> Completed
        {
            get => _default.Completed;
            set => _default.Completed = value;
        }

        public global::System.Exception ErrorCode => AsInternal(new InterfaceTag<global::Windows.Foundation.IAsyncInfo>()).ErrorCode;

        public uint Id => AsInternal(new InterfaceTag<global::Windows.Foundation.IAsyncInfo>()).Id;

        public global::Windows.Foundation.AsyncStatus Status => AsInternal(new InterfaceTag<global::Windows.Foundation.IAsyncInfo>()).Status;

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || typeof(global::WinRT.IInspectable).GUID == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs<IUnknownVftbl>(iid, out ObjectReference<IUnknownVftbl> objRef) >= 0)
            {
                using (objRef)
                {
                    ppv = objRef.GetRef();
                    return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
                }
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]

    [global::WinRT.ProjectedRuntimeClass(nameof(_default))]
    [global::WinRT.ObjectReferenceWrapper(nameof(_inner))]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    public sealed class FileInputStream : IInputStream, global::System.IDisposable, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<FileInputStream>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private IObjectReference _inner = null;
        private readonly Lazy<IInputStream> _defaultLazy;
        private readonly Dictionary<Type, object> _lazyInterfaces;

        private IInputStream _default => _defaultLazy.Value;

        public static FileInputStream FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<FileInputStream>.FromAbi(thisPtr);
        }

        internal FileInputStream(IObjectReference objRef)
        {
            _inner = objRef.As(GuidGenerator.GetIID(typeof(IInputStream).GetHelperType()));
            _defaultLazy = new Lazy<IInputStream>(() => (IInputStream)new SingleInterfaceOptimizedObject(typeof(IInputStream), _inner));
            _lazyInterfaces = new Dictionary<Type, object>()
            {
                {typeof(global::System.IDisposable), new Lazy<global::System.IDisposable>(() => (global::System.IDisposable)(object)new SingleInterfaceOptimizedObject(typeof(global::System.IDisposable), _inner ?? ((IWinRTObject)this).NativeObject))},
            };
        }

        public static bool operator ==(FileInputStream x, FileInputStream y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(FileInputStream x, FileInputStream y) => !(x == y);
        public bool Equals(FileInputStream other) => this == other;
        public override bool Equals(object obj) => obj is FileInputStream that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();

        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();

        private struct InterfaceTag<I>{};

        private IInputStream AsInternal(InterfaceTag<IInputStream> _) => _default;

        public global::Windows.Foundation.IAsyncOperationWithProgress<IBuffer, uint> ReadAsync(IBuffer buffer, uint count, InputStreamOptions options) => _default.ReadAsync(buffer, count, options);

        global::Windows.Foundation.IAsyncOperationWithProgress<IBuffer, uint> IInputStream.ReadAsync(IBuffer buffer, uint count, InputStreamOptions options) => ReadAsync(buffer, count, options);
        private global::System.IDisposable AsInternal(InterfaceTag<global::System.IDisposable> _) =>  ((Lazy<global::System.IDisposable>)_lazyInterfaces[typeof(global::System.IDisposable)]).Value;

        public void Dispose() => AsInternal(new InterfaceTag<global::System.IDisposable>()).Dispose();

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || typeof(global::WinRT.IInspectable).GUID == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs<IUnknownVftbl>(iid, out ObjectReference<IUnknownVftbl> objRef) >= 0)
            {
                using (objRef)
                {
                    ppv = objRef.GetRef();
                    return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
                }
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 327680u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.16299.0")]
    public enum FileOpenDisposition : int
    {
        OpenExisting = unchecked((int)0),
        OpenAlways = unchecked((int)0x1),
        CreateNew = unchecked((int)0x2),
        CreateAlways = unchecked((int)0x3),
        TruncateExisting = unchecked((int)0x4),
    }
    [global::WinRT.WindowsRuntimeType("Windows")]

    [global::WinRT.ProjectedRuntimeClass(nameof(_default))]
    [global::WinRT.ObjectReferenceWrapper(nameof(_inner))]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    public sealed class FileOutputStream : IOutputStream, global::System.IDisposable, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<FileOutputStream>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private IObjectReference _inner = null;
        private readonly Lazy<IOutputStream> _defaultLazy;
        private readonly Dictionary<Type, object> _lazyInterfaces;

        private IOutputStream _default => _defaultLazy.Value;

        public static FileOutputStream FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<FileOutputStream>.FromAbi(thisPtr);
        }

        internal FileOutputStream(IObjectReference objRef)
        {
            _inner = objRef.As(GuidGenerator.GetIID(typeof(IOutputStream).GetHelperType()));
            _defaultLazy = new Lazy<IOutputStream>(() => (IOutputStream)new SingleInterfaceOptimizedObject(typeof(IOutputStream), _inner));
            _lazyInterfaces = new Dictionary<Type, object>()
            {
                {typeof(global::System.IDisposable), new Lazy<global::System.IDisposable>(() => (global::System.IDisposable)(object)new SingleInterfaceOptimizedObject(typeof(global::System.IDisposable), _inner ?? ((IWinRTObject)this).NativeObject))},
            };
        }

        public static bool operator ==(FileOutputStream x, FileOutputStream y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(FileOutputStream x, FileOutputStream y) => !(x == y);
        public bool Equals(FileOutputStream other) => this == other;
        public override bool Equals(object obj) => obj is FileOutputStream that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();

        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();

        private struct InterfaceTag<I>{};

        private IOutputStream AsInternal(InterfaceTag<IOutputStream> _) => _default;

        public global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> WriteAsync(IBuffer buffer) => _default.WriteAsync(buffer);

        global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> IOutputStream.WriteAsync(IBuffer buffer) => WriteAsync(buffer);
        public global::Windows.Foundation.IAsyncOperation<bool> FlushAsync() => _default.FlushAsync();

        global::Windows.Foundation.IAsyncOperation<bool> IOutputStream.FlushAsync() => FlushAsync();
        private global::System.IDisposable AsInternal(InterfaceTag<global::System.IDisposable> _) =>  ((Lazy<global::System.IDisposable>)_lazyInterfaces[typeof(global::System.IDisposable)]).Value;

        public void Dispose() => AsInternal(new InterfaceTag<global::System.IDisposable>()).Dispose();

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || typeof(global::WinRT.IInspectable).GUID == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs<IUnknownVftbl>(iid, out ObjectReference<IUnknownVftbl> objRef) >= 0)
            {
                using (objRef)
                {
                    ppv = objRef.GetRef();
                    return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
                }
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("905A0FE0-BC53-11DF-8C49-001E4FC686DA")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public interface IBuffer
    {
        uint Capacity { get; }
        uint Length { get; set; }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("71AF914D-C10F-484B-BC50-14BC623B3A27")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    internal interface IBufferFactory
    {
        Buffer Create(uint capacity);
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("E901E65B-D716-475A-A90A-AF7229B1E741")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    internal interface IBufferStatics
    {
        Buffer CreateCopyFromMemoryBuffer(global::Windows.Foundation.IMemoryBuffer input);
        global::Windows.Foundation.MemoryBuffer CreateMemoryBufferOverIBuffer(IBuffer input);
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("97D098A5-3B99-4DE9-88A5-E11D2F50C795")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public interface IContentTypeProvider
    {
        string ContentType { get; }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("E2B50029-B4C1-4314-A4B8-FB813A2F275E")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public interface IDataReader
    {
        byte ReadByte();
        void ReadBytes(byte[] value);
        IBuffer ReadBuffer(uint length);
        bool ReadBoolean();
        Guid ReadGuid();
        short ReadInt16();
        int ReadInt32();
        long ReadInt64();
        ushort ReadUInt16();
        uint ReadUInt32();
        ulong ReadUInt64();
        float ReadSingle();
        double ReadDouble();
        string ReadString(uint codeUnitCount);
        global::System.DateTimeOffset ReadDateTime();
        global::System.TimeSpan ReadTimeSpan();
        DataReaderLoadOperation LoadAsync(uint count);
        IBuffer DetachBuffer();
        IInputStream DetachStream();
        ByteOrder ByteOrder { get; set; }
        InputStreamOptions InputStreamOptions { get; set; }
        uint UnconsumedBufferLength { get; }
        UnicodeEncoding UnicodeEncoding { get; set; }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("D7527847-57DA-4E15-914C-06806699A098")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    internal interface IDataReaderFactory
    {
        DataReader CreateDataReader(IInputStream inputStream);
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("11FCBFC8-F93A-471B-B121-F379E349313C")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    internal interface IDataReaderStatics
    {
        DataReader FromBuffer(IBuffer buffer);
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("64B89265-D341-4922-B38A-DD4AF8808C4E")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public interface IDataWriter
    {
        void WriteByte(byte value);
        void WriteBytes(byte[] value);
        [Windows.Foundation.Metadata.Overload("WriteBuffer")]
        void WriteBuffer(IBuffer buffer);
        [Windows.Foundation.Metadata.Overload("WriteBufferRange")]
        void WriteBuffer(IBuffer buffer, uint start, uint count);
        void WriteBoolean(bool value);
        void WriteGuid(Guid value);
        void WriteInt16(short value);
        void WriteInt32(int value);
        void WriteInt64(long value);
        void WriteUInt16(ushort value);
        void WriteUInt32(uint value);
        void WriteUInt64(ulong value);
        void WriteSingle(float value);
        void WriteDouble(double value);
        void WriteDateTime(global::System.DateTimeOffset value);
        void WriteTimeSpan(global::System.TimeSpan value);
        uint WriteString(string value);
        uint MeasureString(string value);
        DataWriterStoreOperation StoreAsync();
        global::Windows.Foundation.IAsyncOperation<bool> FlushAsync();
        IBuffer DetachBuffer();
        IOutputStream DetachStream();
        ByteOrder ByteOrder { get; set; }
        UnicodeEncoding UnicodeEncoding { get; set; }
        uint UnstoredBufferLength { get; }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("338C67C2-8B84-4C2B-9C50-7B8767847A1F")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    internal interface IDataWriterFactory
    {
        DataWriter CreateDataWriter(IOutputStream outputStream);
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("905A0FE2-BC53-11DF-8C49-001E4FC686DA")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public interface IInputStream : global::System.IDisposable
    {
        global::Windows.Foundation.IAsyncOperationWithProgress<IBuffer, uint> ReadAsync(IBuffer buffer, uint count, InputStreamOptions options);
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("43929D18-5EC9-4B5A-919C-4205B0C804B6")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public interface IInputStreamReference
    {
        global::Windows.Foundation.IAsyncOperation<IInputStream> OpenSequentialReadAsync();
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("905A0FE6-BC53-11DF-8C49-001E4FC686DA")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public interface IOutputStream : global::System.IDisposable
    {
        global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> WriteAsync(IBuffer buffer);
        global::Windows.Foundation.IAsyncOperation<bool> FlushAsync();
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("905A0FE1-BC53-11DF-8C49-001E4FC686DA")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public interface IRandomAccessStream : global::System.IDisposable, IInputStream, IOutputStream
    {
        IInputStream GetInputStreamAt(ulong position);
        IOutputStream GetOutputStreamAt(ulong position);
        void Seek(ulong position);
        IRandomAccessStream CloneStream();
        bool CanRead { get; }
        bool CanWrite { get; }
        ulong Position { get; }
        ulong Size { get; set; }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("33EE3134-1DD6-4E3A-8067-D1C162E8642B")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public interface IRandomAccessStreamReference
    {
        global::Windows.Foundation.IAsyncOperation<IRandomAccessStreamWithContentType> OpenReadAsync();
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("524CEDCF-6E29-4CE5-9573-6B753DB66C3A")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    internal interface IRandomAccessStreamStatics
    {
        [Windows.Foundation.Metadata.Overload("CopyAsync")]
        global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> CopyAsync(IInputStream source, IOutputStream destination);
        [Windows.Foundation.Metadata.Overload("CopySizeAsync")]
        global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> CopyAsync(IInputStream source, IOutputStream destination, ulong bytesToCopy);
        global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> CopyAndCloseAsync(IInputStream source, IOutputStream destination);
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("CC254827-4B3D-438F-9232-10C76BC7E038")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public interface IRandomAccessStreamWithContentType : IRandomAccessStream, global::System.IDisposable, IInputStream, IOutputStream, IContentTypeProvider
    {
    }
    [global::WinRT.WindowsRuntimeType("Windows")]

    [global::WinRT.ProjectedRuntimeClass(nameof(_default))]
    [global::WinRT.ObjectReferenceWrapper(nameof(_inner))]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    public sealed class InMemoryRandomAccessStream : IRandomAccessStream, IOutputStream, global::System.IDisposable, IInputStream, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<InMemoryRandomAccessStream>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private IObjectReference _inner = null;
        private readonly Lazy<IRandomAccessStream> _defaultLazy;
        private readonly Dictionary<Type, object> _lazyInterfaces;

        private IRandomAccessStream _default => _defaultLazy.Value;

        public InMemoryRandomAccessStream() : this((ActivationFactory<InMemoryRandomAccessStream>.ActivateInstance<IUnknownVftbl>()))
        {
            ComWrappersSupport.RegisterObjectForInterface(this, ThisPtr);
            ComWrappersHelper.Init(_inner, false);
        }

        public static InMemoryRandomAccessStream FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<InMemoryRandomAccessStream>.FromAbi(thisPtr);
        }

        internal InMemoryRandomAccessStream(IObjectReference objRef)
        {
            _inner = objRef.As(GuidGenerator.GetIID(typeof(IRandomAccessStream).GetHelperType()));
            _defaultLazy = new Lazy<IRandomAccessStream>(() => (IRandomAccessStream)new SingleInterfaceOptimizedObject(typeof(IRandomAccessStream), _inner));
            _lazyInterfaces = new Dictionary<Type, object>()
            {
                {typeof(IOutputStream), new Lazy<IOutputStream>(() => (IOutputStream)(object)new SingleInterfaceOptimizedObject(typeof(IOutputStream), _inner ?? ((IWinRTObject)this).NativeObject))},
                {typeof(global::System.IDisposable), new Lazy<global::System.IDisposable>(() => (global::System.IDisposable)(object)new SingleInterfaceOptimizedObject(typeof(global::System.IDisposable), _inner ?? ((IWinRTObject)this).NativeObject))},
                {typeof(IInputStream), new Lazy<IInputStream>(() => (IInputStream)(object)new SingleInterfaceOptimizedObject(typeof(IInputStream), _inner ?? ((IWinRTObject)this).NativeObject))},
            };
        }

        public static bool operator ==(InMemoryRandomAccessStream x, InMemoryRandomAccessStream y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(InMemoryRandomAccessStream x, InMemoryRandomAccessStream y) => !(x == y);
        public bool Equals(InMemoryRandomAccessStream other) => this == other;
        public override bool Equals(object obj) => obj is InMemoryRandomAccessStream that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();

        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();

        private struct InterfaceTag<I>{};

        private IRandomAccessStream AsInternal(InterfaceTag<IRandomAccessStream> _) => _default;

        public IInputStream GetInputStreamAt(ulong position) => _default.GetInputStreamAt(position);

        IInputStream IRandomAccessStream.GetInputStreamAt(ulong position) => GetInputStreamAt(position);
        public IOutputStream GetOutputStreamAt(ulong position) => _default.GetOutputStreamAt(position);

        IOutputStream IRandomAccessStream.GetOutputStreamAt(ulong position) => GetOutputStreamAt(position);
        public void Seek(ulong position) => _default.Seek(position);

        void IRandomAccessStream.Seek(ulong position) => Seek(position);
        public IRandomAccessStream CloneStream() => _default.CloneStream();

        IRandomAccessStream IRandomAccessStream.CloneStream() => CloneStream();
        bool IRandomAccessStream.CanRead {get => CanRead; }
        bool IRandomAccessStream.CanWrite {get => CanWrite; }
        ulong IRandomAccessStream.Position {get => Position; }
        ulong IRandomAccessStream.Size {get => Size; set => Size = value; }
        private IOutputStream AsInternal(InterfaceTag<IOutputStream> _) =>  ((Lazy<IOutputStream>)_lazyInterfaces[typeof(IOutputStream)]).Value;

        public global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> WriteAsync(IBuffer buffer) => AsInternal(new InterfaceTag<IOutputStream>()).WriteAsync(buffer);

        global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> IOutputStream.WriteAsync(IBuffer buffer) => WriteAsync(buffer);
        public global::Windows.Foundation.IAsyncOperation<bool> FlushAsync() => AsInternal(new InterfaceTag<IOutputStream>()).FlushAsync();

        global::Windows.Foundation.IAsyncOperation<bool> IOutputStream.FlushAsync() => FlushAsync();
        private global::System.IDisposable AsInternal(InterfaceTag<global::System.IDisposable> _) =>  ((Lazy<global::System.IDisposable>)_lazyInterfaces[typeof(global::System.IDisposable)]).Value;

        public void Dispose() => AsInternal(new InterfaceTag<global::System.IDisposable>()).Dispose();

        private IInputStream AsInternal(InterfaceTag<IInputStream> _) =>  ((Lazy<IInputStream>)_lazyInterfaces[typeof(IInputStream)]).Value;

        public global::Windows.Foundation.IAsyncOperationWithProgress<IBuffer, uint> ReadAsync(IBuffer buffer, uint count, InputStreamOptions options) => AsInternal(new InterfaceTag<IInputStream>()).ReadAsync(buffer, count, options);

        global::Windows.Foundation.IAsyncOperationWithProgress<IBuffer, uint> IInputStream.ReadAsync(IBuffer buffer, uint count, InputStreamOptions options) => ReadAsync(buffer, count, options);
        public bool CanRead => _default.CanRead;

        public bool CanWrite => _default.CanWrite;

        public ulong Position => _default.Position;

        public ulong Size
        {
            get => _default.Size;
            set => _default.Size = value;
        }

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || typeof(global::WinRT.IInspectable).GUID == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs<IUnknownVftbl>(iid, out ObjectReference<IUnknownVftbl> objRef) >= 0)
            {
                using (objRef)
                {
                    ppv = objRef.GetRef();
                    return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
                }
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [FlagsAttribute]
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    public enum InputStreamOptions : uint
    {
        None = unchecked((uint)0),
        Partial = unchecked((uint)0x1),
        ReadAhead = unchecked((uint)0x2),
    }
    [global::WinRT.WindowsRuntimeType("Windows")]

    [global::WinRT.ProjectedRuntimeClass(nameof(_default))]
    [global::WinRT.ObjectReferenceWrapper(nameof(_inner))]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    public sealed class InputStreamOverStream : IInputStream, global::System.IDisposable, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<InputStreamOverStream>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private IObjectReference _inner = null;
        private readonly Lazy<IInputStream> _defaultLazy;
        private readonly Dictionary<Type, object> _lazyInterfaces;

        private IInputStream _default => _defaultLazy.Value;

        public static InputStreamOverStream FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<InputStreamOverStream>.FromAbi(thisPtr);
        }

        internal InputStreamOverStream(IObjectReference objRef)
        {
            _inner = objRef.As(GuidGenerator.GetIID(typeof(IInputStream).GetHelperType()));
            _defaultLazy = new Lazy<IInputStream>(() => (IInputStream)new SingleInterfaceOptimizedObject(typeof(IInputStream), _inner));
            _lazyInterfaces = new Dictionary<Type, object>()
            {
                {typeof(global::System.IDisposable), new Lazy<global::System.IDisposable>(() => (global::System.IDisposable)(object)new SingleInterfaceOptimizedObject(typeof(global::System.IDisposable), _inner ?? ((IWinRTObject)this).NativeObject))},
            };
        }

        public static bool operator ==(InputStreamOverStream x, InputStreamOverStream y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(InputStreamOverStream x, InputStreamOverStream y) => !(x == y);
        public bool Equals(InputStreamOverStream other) => this == other;
        public override bool Equals(object obj) => obj is InputStreamOverStream that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();

        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();

        private struct InterfaceTag<I>{};

        private IInputStream AsInternal(InterfaceTag<IInputStream> _) => _default;

        public global::Windows.Foundation.IAsyncOperationWithProgress<IBuffer, uint> ReadAsync(IBuffer buffer, uint count, InputStreamOptions options) => _default.ReadAsync(buffer, count, options);

        global::Windows.Foundation.IAsyncOperationWithProgress<IBuffer, uint> IInputStream.ReadAsync(IBuffer buffer, uint count, InputStreamOptions options) => ReadAsync(buffer, count, options);
        private global::System.IDisposable AsInternal(InterfaceTag<global::System.IDisposable> _) =>  ((Lazy<global::System.IDisposable>)_lazyInterfaces[typeof(global::System.IDisposable)]).Value;

        public void Dispose() => AsInternal(new InterfaceTag<global::System.IDisposable>()).Dispose();

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || typeof(global::WinRT.IInspectable).GUID == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs<IUnknownVftbl>(iid, out ObjectReference<IUnknownVftbl> objRef) >= 0)
            {
                using (objRef)
                {
                    ppv = objRef.GetRef();
                    return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
                }
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]

    [global::WinRT.ProjectedRuntimeClass(nameof(_default))]
    [global::WinRT.ObjectReferenceWrapper(nameof(_inner))]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    public sealed class OutputStreamOverStream : IOutputStream, global::System.IDisposable, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<OutputStreamOverStream>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private IObjectReference _inner = null;
        private readonly Lazy<IOutputStream> _defaultLazy;
        private readonly Dictionary<Type, object> _lazyInterfaces;

        private IOutputStream _default => _defaultLazy.Value;

        public static OutputStreamOverStream FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<OutputStreamOverStream>.FromAbi(thisPtr);
        }

        internal OutputStreamOverStream(IObjectReference objRef)
        {
            _inner = objRef.As(GuidGenerator.GetIID(typeof(IOutputStream).GetHelperType()));
            _defaultLazy = new Lazy<IOutputStream>(() => (IOutputStream)new SingleInterfaceOptimizedObject(typeof(IOutputStream), _inner));
            _lazyInterfaces = new Dictionary<Type, object>()
            {
                {typeof(global::System.IDisposable), new Lazy<global::System.IDisposable>(() => (global::System.IDisposable)(object)new SingleInterfaceOptimizedObject(typeof(global::System.IDisposable), _inner ?? ((IWinRTObject)this).NativeObject))},
            };
        }

        public static bool operator ==(OutputStreamOverStream x, OutputStreamOverStream y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(OutputStreamOverStream x, OutputStreamOverStream y) => !(x == y);
        public bool Equals(OutputStreamOverStream other) => this == other;
        public override bool Equals(object obj) => obj is OutputStreamOverStream that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();

        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();

        private struct InterfaceTag<I>{};

        private IOutputStream AsInternal(InterfaceTag<IOutputStream> _) => _default;

        public global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> WriteAsync(IBuffer buffer) => _default.WriteAsync(buffer);

        global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> IOutputStream.WriteAsync(IBuffer buffer) => WriteAsync(buffer);
        public global::Windows.Foundation.IAsyncOperation<bool> FlushAsync() => _default.FlushAsync();

        global::Windows.Foundation.IAsyncOperation<bool> IOutputStream.FlushAsync() => FlushAsync();
        private global::System.IDisposable AsInternal(InterfaceTag<global::System.IDisposable> _) =>  ((Lazy<global::System.IDisposable>)_lazyInterfaces[typeof(global::System.IDisposable)]).Value;

        public void Dispose() => AsInternal(new InterfaceTag<global::System.IDisposable>()).Dispose();

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || typeof(global::WinRT.IInspectable).GUID == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs<IUnknownVftbl>(iid, out ObjectReference<IUnknownVftbl> objRef) >= 0)
            {
                using (objRef)
                {
                    ppv = objRef.GetRef();
                    return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
                }
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    public static class RandomAccessStream
    {

        internal static BaseActivationFactory _factory = new BaseActivationFactory("Windows.Storage.Streams", "Windows.Storage.Streams.RandomAccessStream");
        public static I As<I>() => _factory.AsInterface<I>();

        internal class _IRandomAccessStreamStatics : IWinRTObject
        {
            private IObjectReference _obj;
            public _IRandomAccessStreamStatics()
            {
                _obj = (new BaseActivationFactory("Windows.Storage.Streams", "Windows.Storage.Streams.RandomAccessStream"))._As(GuidGenerator.GetIID(typeof(Windows.Storage.Streams.IRandomAccessStreamStatics).GetHelperType()));
            }

            private static readonly WeakLazy<_IRandomAccessStreamStatics> _instance = new WeakLazy<_IRandomAccessStreamStatics>();
            internal static IRandomAccessStreamStatics Instance => (IRandomAccessStreamStatics)_instance.Value;

            IObjectReference IWinRTObject.NativeObject => _obj;
            bool IWinRTObject.HasUnwrappableNativeObject => false;
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();
        }

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> CopyAsync(IInputStream source, IOutputStream destination) => _IRandomAccessStreamStatics.Instance.CopyAsync(source, destination);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> CopyAsync(IInputStream source, IOutputStream destination, ulong bytesToCopy) => _IRandomAccessStreamStatics.Instance.CopyAsync(source, destination, bytesToCopy);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> CopyAndCloseAsync(IInputStream source, IOutputStream destination) => _IRandomAccessStreamStatics.Instance.CopyAndCloseAsync(source, destination);
    }[global::WinRT.WindowsRuntimeType("Windows")]

    [global::WinRT.ProjectedRuntimeClass(nameof(_default))]
    [global::WinRT.ObjectReferenceWrapper(nameof(_inner))]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    public sealed class RandomAccessStreamOverStream : IRandomAccessStream, IOutputStream, global::System.IDisposable, IInputStream, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<RandomAccessStreamOverStream>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private IObjectReference _inner = null;
        private readonly Lazy<IRandomAccessStream> _defaultLazy;
        private readonly Dictionary<Type, object> _lazyInterfaces;

        private IRandomAccessStream _default => _defaultLazy.Value;

        public static RandomAccessStreamOverStream FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<RandomAccessStreamOverStream>.FromAbi(thisPtr);
        }

        internal RandomAccessStreamOverStream(IObjectReference objRef)
        {
            _inner = objRef.As(GuidGenerator.GetIID(typeof(IRandomAccessStream).GetHelperType()));
            _defaultLazy = new Lazy<IRandomAccessStream>(() => (IRandomAccessStream)new SingleInterfaceOptimizedObject(typeof(IRandomAccessStream), _inner));
            _lazyInterfaces = new Dictionary<Type, object>()
            {
                {typeof(IOutputStream), new Lazy<IOutputStream>(() => (IOutputStream)(object)new SingleInterfaceOptimizedObject(typeof(IOutputStream), _inner ?? ((IWinRTObject)this).NativeObject))},
                {typeof(global::System.IDisposable), new Lazy<global::System.IDisposable>(() => (global::System.IDisposable)(object)new SingleInterfaceOptimizedObject(typeof(global::System.IDisposable), _inner ?? ((IWinRTObject)this).NativeObject))},
                {typeof(IInputStream), new Lazy<IInputStream>(() => (IInputStream)(object)new SingleInterfaceOptimizedObject(typeof(IInputStream), _inner ?? ((IWinRTObject)this).NativeObject))},
            };
        }

        public static bool operator ==(RandomAccessStreamOverStream x, RandomAccessStreamOverStream y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(RandomAccessStreamOverStream x, RandomAccessStreamOverStream y) => !(x == y);
        public bool Equals(RandomAccessStreamOverStream other) => this == other;
        public override bool Equals(object obj) => obj is RandomAccessStreamOverStream that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();

        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();

        private struct InterfaceTag<I>{};

        private IRandomAccessStream AsInternal(InterfaceTag<IRandomAccessStream> _) => _default;

        public IInputStream GetInputStreamAt(ulong position) => _default.GetInputStreamAt(position);

        IInputStream IRandomAccessStream.GetInputStreamAt(ulong position) => GetInputStreamAt(position);
        public IOutputStream GetOutputStreamAt(ulong position) => _default.GetOutputStreamAt(position);

        IOutputStream IRandomAccessStream.GetOutputStreamAt(ulong position) => GetOutputStreamAt(position);
        public void Seek(ulong position) => _default.Seek(position);

        void IRandomAccessStream.Seek(ulong position) => Seek(position);
        public IRandomAccessStream CloneStream() => _default.CloneStream();

        IRandomAccessStream IRandomAccessStream.CloneStream() => CloneStream();
        bool IRandomAccessStream.CanRead {get => CanRead; }
        bool IRandomAccessStream.CanWrite {get => CanWrite; }
        ulong IRandomAccessStream.Position {get => Position; }
        ulong IRandomAccessStream.Size {get => Size; set => Size = value; }
        private IOutputStream AsInternal(InterfaceTag<IOutputStream> _) =>  ((Lazy<IOutputStream>)_lazyInterfaces[typeof(IOutputStream)]).Value;

        public global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> WriteAsync(IBuffer buffer) => AsInternal(new InterfaceTag<IOutputStream>()).WriteAsync(buffer);

        global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> IOutputStream.WriteAsync(IBuffer buffer) => WriteAsync(buffer);
        public global::Windows.Foundation.IAsyncOperation<bool> FlushAsync() => AsInternal(new InterfaceTag<IOutputStream>()).FlushAsync();

        global::Windows.Foundation.IAsyncOperation<bool> IOutputStream.FlushAsync() => FlushAsync();
        private global::System.IDisposable AsInternal(InterfaceTag<global::System.IDisposable> _) =>  ((Lazy<global::System.IDisposable>)_lazyInterfaces[typeof(global::System.IDisposable)]).Value;

        public void Dispose() => AsInternal(new InterfaceTag<global::System.IDisposable>()).Dispose();

        private IInputStream AsInternal(InterfaceTag<IInputStream> _) =>  ((Lazy<IInputStream>)_lazyInterfaces[typeof(IInputStream)]).Value;

        public global::Windows.Foundation.IAsyncOperationWithProgress<IBuffer, uint> ReadAsync(IBuffer buffer, uint count, InputStreamOptions options) => AsInternal(new InterfaceTag<IInputStream>()).ReadAsync(buffer, count, options);

        global::Windows.Foundation.IAsyncOperationWithProgress<IBuffer, uint> IInputStream.ReadAsync(IBuffer buffer, uint count, InputStreamOptions options) => ReadAsync(buffer, count, options);
        public bool CanRead => _default.CanRead;

        public bool CanWrite => _default.CanWrite;

        public ulong Position => _default.Position;

        public ulong Size
        {
            get => _default.Size;
            set => _default.Size = value;
        }

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || typeof(global::WinRT.IInspectable).GUID == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs<IUnknownVftbl>(iid, out ObjectReference<IUnknownVftbl> objRef) >= 0)
            {
                using (objRef)
                {
                    ppv = objRef.GetRef();
                    return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
                }
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    public enum UnicodeEncoding : int
    {
        Utf8 = unchecked((int)0),
        Utf16LE = unchecked((int)0x1),
        Utf16BE = unchecked((int)0x2),
    }
}

#pragma warning disable CA1416
namespace ABI.Windows.Storage.Streams
{
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct Buffer
    {
        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.Buffer obj) => obj is null ? null : MarshalInterface<global::Windows.Storage.Streams.IBuffer>.CreateMarshaler(obj);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.Buffer FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.Buffer.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.Buffer obj) => obj is null ? IntPtr.Zero : CreateMarshaler(obj).GetRef();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.Buffer>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.Buffer[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.Buffer>.CreateMarshalerArray(array, (o) => CreateMarshaler(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.Buffer>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.Buffer[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.Buffer>.FromAbiArray(box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.Buffer[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.Buffer>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.Buffer>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.Buffer>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct DataReader
    {
        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.DataReader obj) => obj is null ? null : MarshalInterface<global::Windows.Storage.Streams.IDataReader>.CreateMarshaler(obj);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.DataReader FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.DataReader.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.DataReader obj) => obj is null ? IntPtr.Zero : CreateMarshaler(obj).GetRef();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReader>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.DataReader[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReader>.CreateMarshalerArray(array, (o) => CreateMarshaler(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReader>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.DataReader[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReader>.FromAbiArray(box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.DataReader[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReader>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReader>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReader>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct DataReaderLoadOperation
    {
        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.DataReaderLoadOperation obj) => obj is null ? null : MarshalInterface<global::Windows.Foundation.IAsyncOperation<uint>>.CreateMarshaler(obj);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.DataReaderLoadOperation FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.DataReaderLoadOperation.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.DataReaderLoadOperation obj) => obj is null ? IntPtr.Zero : CreateMarshaler(obj).GetRef();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReaderLoadOperation>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.DataReaderLoadOperation[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReaderLoadOperation>.CreateMarshalerArray(array, (o) => CreateMarshaler(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReaderLoadOperation>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.DataReaderLoadOperation[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReaderLoadOperation>.FromAbiArray(box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.DataReaderLoadOperation[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReaderLoadOperation>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReaderLoadOperation>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReaderLoadOperation>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct DataWriter
    {
        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.DataWriter obj) => obj is null ? null : MarshalInterface<global::Windows.Storage.Streams.IDataWriter>.CreateMarshaler(obj);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.DataWriter FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.DataWriter.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.DataWriter obj) => obj is null ? IntPtr.Zero : CreateMarshaler(obj).GetRef();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriter>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.DataWriter[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriter>.CreateMarshalerArray(array, (o) => CreateMarshaler(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriter>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.DataWriter[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriter>.FromAbiArray(box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.DataWriter[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriter>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriter>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriter>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct DataWriterStoreOperation
    {
        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.DataWriterStoreOperation obj) => obj is null ? null : MarshalInterface<global::Windows.Foundation.IAsyncOperation<uint>>.CreateMarshaler(obj);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.DataWriterStoreOperation FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.DataWriterStoreOperation.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.DataWriterStoreOperation obj) => obj is null ? IntPtr.Zero : CreateMarshaler(obj).GetRef();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriterStoreOperation>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.DataWriterStoreOperation[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriterStoreOperation>.CreateMarshalerArray(array, (o) => CreateMarshaler(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriterStoreOperation>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.DataWriterStoreOperation[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriterStoreOperation>.FromAbiArray(box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.DataWriterStoreOperation[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriterStoreOperation>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriterStoreOperation>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriterStoreOperation>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct FileInputStream
    {
        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.FileInputStream obj) => obj is null ? null : MarshalInterface<global::Windows.Storage.Streams.IInputStream>.CreateMarshaler(obj);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.FileInputStream FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.FileInputStream.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.FileInputStream obj) => obj is null ? IntPtr.Zero : CreateMarshaler(obj).GetRef();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.FileInputStream>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.FileInputStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileInputStream>.CreateMarshalerArray(array, (o) => CreateMarshaler(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileInputStream>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.FileInputStream[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileInputStream>.FromAbiArray(box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.FileInputStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileInputStream>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.FileInputStream>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileInputStream>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct FileOutputStream
    {
        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.FileOutputStream obj) => obj is null ? null : MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.CreateMarshaler(obj);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.FileOutputStream FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.FileOutputStream.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.FileOutputStream obj) => obj is null ? IntPtr.Zero : CreateMarshaler(obj).GetRef();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.FileOutputStream>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.FileOutputStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileOutputStream>.CreateMarshalerArray(array, (o) => CreateMarshaler(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileOutputStream>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.FileOutputStream[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileOutputStream>.FromAbiArray(box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.FileOutputStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileOutputStream>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.FileOutputStream>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileOutputStream>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [DynamicInterfaceCastableImplementation]
    [Guid("905A0FE0-BC53-11DF-8C49-001E4FC686DA")]
    internal unsafe interface IBuffer : global::Windows.Storage.Streams.IBuffer
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IBuffer()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IBuffer), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 3);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_get_Capacity_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint*, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_get_Length_1;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint, int>*)AbiToProjectionVftablePtr)[8] = &Do_Abi_put_Length_2;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Capacity_0(IntPtr thisPtr, uint* value)
        {
            uint __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IBuffer>(thisPtr).Capacity;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_put_Length_2(IntPtr thisPtr, uint value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IBuffer>(thisPtr).Length = value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Length_1(IntPtr thisPtr, uint* value)
        {
            uint __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IBuffer>(thisPtr).Length;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe uint global::Windows.Storage.Streams.IBuffer.Capacity
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IBuffer).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                uint __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out uint, int>**)ThisPtr)[6](ThisPtr, out __retval));
                return __retval;
            }
        }

        unsafe uint global::Windows.Storage.Streams.IBuffer.Length
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IBuffer).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                uint __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out uint, int>**)ThisPtr)[7](ThisPtr, out __retval));
                return __retval;
            }
            set
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IBuffer).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint, int>**)ThisPtr)[8](ThisPtr, value));
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("71AF914D-C10F-484B-BC50-14BC623B3A27")]
    internal unsafe interface IBufferFactory : global::Windows.Storage.Streams.IBufferFactory
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IBufferFactory()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IBufferFactory), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 1);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_Create_0;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_Create_0(IntPtr thisPtr, uint capacity, IntPtr* value)
        {
            global::Windows.Storage.Streams.Buffer __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IBufferFactory>(thisPtr).Create(capacity);
                *value = global::ABI.Windows.Storage.Streams.Buffer.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Storage.Streams.Buffer global::Windows.Storage.Streams.IBufferFactory.Create(uint capacity)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IBufferFactory).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint, out IntPtr, int>**)ThisPtr)[6](ThisPtr, capacity, out __retval));
                return global::ABI.Windows.Storage.Streams.Buffer.FromAbi(__retval);
            }
            finally
            {
                global::ABI.Windows.Storage.Streams.Buffer.DisposeAbi(__retval);
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("E901E65B-D716-475A-A90A-AF7229B1E741")]
    internal unsafe interface IBufferStatics : global::Windows.Storage.Streams.IBufferStatics
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IBufferStatics()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IBufferStatics), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 2);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_CreateCopyFromMemoryBuffer_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_CreateMemoryBufferOverIBuffer_1;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateCopyFromMemoryBuffer_0(IntPtr thisPtr, IntPtr input, IntPtr* value)
        {
            global::Windows.Storage.Streams.Buffer __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IBufferStatics>(thisPtr).CreateCopyFromMemoryBuffer(MarshalInterface<global::Windows.Foundation.IMemoryBuffer>.FromAbi(input));
                *value = global::ABI.Windows.Storage.Streams.Buffer.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateMemoryBufferOverIBuffer_1(IntPtr thisPtr, IntPtr input, IntPtr* value)
        {
            global::Windows.Foundation.MemoryBuffer __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IBufferStatics>(thisPtr).CreateMemoryBufferOverIBuffer(MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromAbi(input));
                *value = global::ABI.Windows.Foundation.MemoryBuffer.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Storage.Streams.Buffer global::Windows.Storage.Streams.IBufferStatics.CreateCopyFromMemoryBuffer(global::Windows.Foundation.IMemoryBuffer input)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IBufferStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IObjectReference __input = default;
            IntPtr __retval = default;
            try
            {
                __input = MarshalInterface<global::Windows.Foundation.IMemoryBuffer>.CreateMarshaler(input);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, MarshalInterface<global::Windows.Foundation.IMemoryBuffer>.GetAbi(__input), out __retval));
                return global::ABI.Windows.Storage.Streams.Buffer.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Foundation.IMemoryBuffer>.DisposeMarshaler(__input);
                global::ABI.Windows.Storage.Streams.Buffer.DisposeAbi(__retval);
            }
        }

        unsafe global::Windows.Foundation.MemoryBuffer global::Windows.Storage.Streams.IBufferStatics.CreateMemoryBufferOverIBuffer(global::Windows.Storage.Streams.IBuffer input)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IBufferStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IObjectReference __input = default;
            IntPtr __retval = default;
            try
            {
                __input = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.CreateMarshaler(input);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[7](ThisPtr, MarshalInterface<global::Windows.Storage.Streams.IBuffer>.GetAbi(__input), out __retval));
                return global::ABI.Windows.Foundation.MemoryBuffer.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IBuffer>.DisposeMarshaler(__input);
                global::ABI.Windows.Foundation.MemoryBuffer.DisposeAbi(__retval);
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("97D098A5-3B99-4DE9-88A5-E11D2F50C795")]
    internal unsafe interface IContentTypeProvider : global::Windows.Storage.Streams.IContentTypeProvider
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IContentTypeProvider()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IContentTypeProvider), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 1);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_get_ContentType_0;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_ContentType_0(IntPtr thisPtr, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IContentTypeProvider>(thisPtr).ContentType;
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe string global::Windows.Storage.Streams.IContentTypeProvider.ContentType
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IContentTypeProvider).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, out __retval));
                    return MarshalString.FromAbi(__retval);
                }
                finally
                {
                    MarshalString.DisposeAbi(__retval);
                }
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("E2B50029-B4C1-4314-A4B8-FB813A2F275E")]
    internal unsafe interface IDataReader : global::Windows.Storage.Streams.IDataReader
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IDataReader()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IDataReader), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 26);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_get_UnconsumedBufferLength_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.UnicodeEncoding*, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_get_UnicodeEncoding_1;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.UnicodeEncoding, int>*)AbiToProjectionVftablePtr)[8] = &Do_Abi_put_UnicodeEncoding_2;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.ByteOrder*, int>*)AbiToProjectionVftablePtr)[9] = &Do_Abi_get_ByteOrder_3;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.ByteOrder, int>*)AbiToProjectionVftablePtr)[10] = &Do_Abi_put_ByteOrder_4;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.InputStreamOptions*, int>*)AbiToProjectionVftablePtr)[11] = &Do_Abi_get_InputStreamOptions_5;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.InputStreamOptions, int>*)AbiToProjectionVftablePtr)[12] = &Do_Abi_put_InputStreamOptions_6;
            ((delegate* unmanaged[Stdcall]<IntPtr, byte*, int>*)AbiToProjectionVftablePtr)[13] = &Do_Abi_ReadByte_7;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, int>*)AbiToProjectionVftablePtr)[14] = &Do_Abi_ReadBytes_8;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint, IntPtr*, int>*)AbiToProjectionVftablePtr)[15] = &Do_Abi_ReadBuffer_9;
            ((delegate* unmanaged[Stdcall]<IntPtr, byte*, int>*)AbiToProjectionVftablePtr)[16] = &Do_Abi_ReadBoolean_10;
            ((delegate* unmanaged[Stdcall]<IntPtr, Guid*, int>*)AbiToProjectionVftablePtr)[17] = &Do_Abi_ReadGuid_11;
            ((delegate* unmanaged[Stdcall]<IntPtr, short*, int>*)AbiToProjectionVftablePtr)[18] = &Do_Abi_ReadInt16_12;
            ((delegate* unmanaged[Stdcall]<IntPtr, int*, int>*)AbiToProjectionVftablePtr)[19] = &Do_Abi_ReadInt32_13;
            ((delegate* unmanaged[Stdcall]<IntPtr, long*, int>*)AbiToProjectionVftablePtr)[20] = &Do_Abi_ReadInt64_14;
            ((delegate* unmanaged[Stdcall]<IntPtr, ushort*, int>*)AbiToProjectionVftablePtr)[21] = &Do_Abi_ReadUInt16_15;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint*, int>*)AbiToProjectionVftablePtr)[22] = &Do_Abi_ReadUInt32_16;
            ((delegate* unmanaged[Stdcall]<IntPtr, ulong*, int>*)AbiToProjectionVftablePtr)[23] = &Do_Abi_ReadUInt64_17;
            ((delegate* unmanaged[Stdcall]<IntPtr, float*, int>*)AbiToProjectionVftablePtr)[24] = &Do_Abi_ReadSingle_18;
            ((delegate* unmanaged[Stdcall]<IntPtr, double*, int>*)AbiToProjectionVftablePtr)[25] = &Do_Abi_ReadDouble_19;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint, IntPtr*, int>*)AbiToProjectionVftablePtr)[26] = &Do_Abi_ReadString_20;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::ABI.System.DateTimeOffset*, int>*)AbiToProjectionVftablePtr)[27] = &Do_Abi_ReadDateTime_21;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::ABI.System.TimeSpan*, int>*)AbiToProjectionVftablePtr)[28] = &Do_Abi_ReadTimeSpan_22;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint, IntPtr*, int>*)AbiToProjectionVftablePtr)[29] = &Do_Abi_LoadAsync_23;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[30] = &Do_Abi_DetachBuffer_24;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[31] = &Do_Abi_DetachStream_25;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadByte_7(IntPtr thisPtr, byte* value)
        {
            byte __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadByte();
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadBytes_8(IntPtr thisPtr, int __valueSize, IntPtr value)
        {

            byte[] __value = MarshalBlittable<byte>.FromAbiArray((__valueSize, value));

            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadBytes( __value);
                MarshalBlittable<byte>.CopyManagedArray(__value, value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadBuffer_9(IntPtr thisPtr, uint length, IntPtr* buffer)
        {
            global::Windows.Storage.Streams.IBuffer __buffer = default;

            *buffer = default;

            try
            {
                __buffer = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadBuffer(length);
                *buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromManaged(__buffer);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadBoolean_10(IntPtr thisPtr, byte* value)
        {
            bool __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadBoolean();
                *value = (byte)(__value ? 1 : 0);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadGuid_11(IntPtr thisPtr, Guid* value)
        {
            Guid __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadGuid();
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadInt16_12(IntPtr thisPtr, short* value)
        {
            short __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadInt16();
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadInt32_13(IntPtr thisPtr, int* value)
        {
            int __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadInt32();
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadInt64_14(IntPtr thisPtr, long* value)
        {
            long __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadInt64();
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadUInt16_15(IntPtr thisPtr, ushort* value)
        {
            ushort __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadUInt16();
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadUInt32_16(IntPtr thisPtr, uint* value)
        {
            uint __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadUInt32();
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadUInt64_17(IntPtr thisPtr, ulong* value)
        {
            ulong __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadUInt64();
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadSingle_18(IntPtr thisPtr, float* value)
        {
            float __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadSingle();
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadDouble_19(IntPtr thisPtr, double* value)
        {
            double __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadDouble();
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadString_20(IntPtr thisPtr, uint codeUnitCount, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadString(codeUnitCount);
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadDateTime_21(IntPtr thisPtr, global::ABI.System.DateTimeOffset* value)
        {
            global::System.DateTimeOffset __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadDateTime();
                *value = global::ABI.System.DateTimeOffset.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadTimeSpan_22(IntPtr thisPtr, global::ABI.System.TimeSpan* value)
        {
            global::System.TimeSpan __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadTimeSpan();
                *value = global::ABI.System.TimeSpan.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_LoadAsync_23(IntPtr thisPtr, uint count, IntPtr* operation)
        {
            global::Windows.Storage.Streams.DataReaderLoadOperation __operation = default;

            *operation = default;

            try
            {
                __operation = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).LoadAsync(count);
                *operation = global::ABI.Windows.Storage.Streams.DataReaderLoadOperation.FromManaged(__operation);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_DetachBuffer_24(IntPtr thisPtr, IntPtr* buffer)
        {
            global::Windows.Storage.Streams.IBuffer __buffer = default;

            *buffer = default;

            try
            {
                __buffer = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).DetachBuffer();
                *buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromManaged(__buffer);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_DetachStream_25(IntPtr thisPtr, IntPtr* stream)
        {
            global::Windows.Storage.Streams.IInputStream __stream = default;

            *stream = default;

            try
            {
                __stream = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).DetachStream();
                *stream = MarshalInterface<global::Windows.Storage.Streams.IInputStream>.FromManaged(__stream);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_put_ByteOrder_4(IntPtr thisPtr, global::Windows.Storage.Streams.ByteOrder value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ByteOrder = value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_ByteOrder_3(IntPtr thisPtr, global::Windows.Storage.Streams.ByteOrder* value)
        {
            global::Windows.Storage.Streams.ByteOrder __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ByteOrder;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_put_InputStreamOptions_6(IntPtr thisPtr, global::Windows.Storage.Streams.InputStreamOptions value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).InputStreamOptions = value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_InputStreamOptions_5(IntPtr thisPtr, global::Windows.Storage.Streams.InputStreamOptions* value)
        {
            global::Windows.Storage.Streams.InputStreamOptions __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).InputStreamOptions;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_UnconsumedBufferLength_0(IntPtr thisPtr, uint* value)
        {
            uint __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).UnconsumedBufferLength;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_put_UnicodeEncoding_2(IntPtr thisPtr, global::Windows.Storage.Streams.UnicodeEncoding value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).UnicodeEncoding = value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_UnicodeEncoding_1(IntPtr thisPtr, global::Windows.Storage.Streams.UnicodeEncoding* value)
        {
            global::Windows.Storage.Streams.UnicodeEncoding __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).UnicodeEncoding;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe byte global::Windows.Storage.Streams.IDataReader.ReadByte()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            byte __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out byte, int>**)ThisPtr)[13](ThisPtr, out __retval));
            return __retval;
        }

        unsafe void global::Windows.Storage.Streams.IDataReader.ReadBytes(byte[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalBlittable<byte>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            try
            {
                __value = MarshalBlittable<byte>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalBlittable<byte>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, int>**)ThisPtr)[14](ThisPtr, __value_length, __value_data));
            }
            finally
            {
                MarshalBlittable<byte>.DisposeMarshalerArray(__value);
            }
        }

        unsafe global::Windows.Storage.Streams.IBuffer global::Windows.Storage.Streams.IDataReader.ReadBuffer(uint length)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint, out IntPtr, int>**)ThisPtr)[15](ThisPtr, length, out __retval));
                return MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IBuffer>.DisposeAbi(__retval);
            }
        }

        unsafe bool global::Windows.Storage.Streams.IDataReader.ReadBoolean()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            byte __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out byte, int>**)ThisPtr)[16](ThisPtr, out __retval));
            return __retval != 0;
        }

        unsafe Guid global::Windows.Storage.Streams.IDataReader.ReadGuid()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            Guid __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out Guid, int>**)ThisPtr)[17](ThisPtr, out __retval));
            return __retval;
        }

        unsafe short global::Windows.Storage.Streams.IDataReader.ReadInt16()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            short __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out short, int>**)ThisPtr)[18](ThisPtr, out __retval));
            return __retval;
        }

        unsafe int global::Windows.Storage.Streams.IDataReader.ReadInt32()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            int __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out int, int>**)ThisPtr)[19](ThisPtr, out __retval));
            return __retval;
        }

        unsafe long global::Windows.Storage.Streams.IDataReader.ReadInt64()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            long __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out long, int>**)ThisPtr)[20](ThisPtr, out __retval));
            return __retval;
        }

        unsafe ushort global::Windows.Storage.Streams.IDataReader.ReadUInt16()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            ushort __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out ushort, int>**)ThisPtr)[21](ThisPtr, out __retval));
            return __retval;
        }

        unsafe uint global::Windows.Storage.Streams.IDataReader.ReadUInt32()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            uint __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out uint, int>**)ThisPtr)[22](ThisPtr, out __retval));
            return __retval;
        }

        unsafe ulong global::Windows.Storage.Streams.IDataReader.ReadUInt64()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            ulong __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out ulong, int>**)ThisPtr)[23](ThisPtr, out __retval));
            return __retval;
        }

        unsafe float global::Windows.Storage.Streams.IDataReader.ReadSingle()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            float __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out float, int>**)ThisPtr)[24](ThisPtr, out __retval));
            return __retval;
        }

        unsafe double global::Windows.Storage.Streams.IDataReader.ReadDouble()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            double __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out double, int>**)ThisPtr)[25](ThisPtr, out __retval));
            return __retval;
        }

        unsafe string global::Windows.Storage.Streams.IDataReader.ReadString(uint codeUnitCount)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint, out IntPtr, int>**)ThisPtr)[26](ThisPtr, codeUnitCount, out __retval));
                return MarshalString.FromAbi(__retval);
            }
            finally
            {
                MarshalString.DisposeAbi(__retval);
            }
        }

        unsafe global::System.DateTimeOffset global::Windows.Storage.Streams.IDataReader.ReadDateTime()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::ABI.System.DateTimeOffset __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out global::ABI.System.DateTimeOffset, int>**)ThisPtr)[27](ThisPtr, out __retval));
                return global::ABI.System.DateTimeOffset.FromAbi(__retval);
            }
            finally
            {
                global::ABI.System.DateTimeOffset.DisposeAbi(__retval);
            }
        }

        unsafe global::System.TimeSpan global::Windows.Storage.Streams.IDataReader.ReadTimeSpan()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::ABI.System.TimeSpan __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out global::ABI.System.TimeSpan, int>**)ThisPtr)[28](ThisPtr, out __retval));
                return global::ABI.System.TimeSpan.FromAbi(__retval);
            }
            finally
            {
                global::ABI.System.TimeSpan.DisposeAbi(__retval);
            }
        }

        unsafe global::Windows.Storage.Streams.DataReaderLoadOperation global::Windows.Storage.Streams.IDataReader.LoadAsync(uint count)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint, out IntPtr, int>**)ThisPtr)[29](ThisPtr, count, out __retval));
                return global::ABI.Windows.Storage.Streams.DataReaderLoadOperation.FromAbi(__retval);
            }
            finally
            {
                global::ABI.Windows.Storage.Streams.DataReaderLoadOperation.DisposeAbi(__retval);
            }
        }

        unsafe global::Windows.Storage.Streams.IBuffer global::Windows.Storage.Streams.IDataReader.DetachBuffer()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[30](ThisPtr, out __retval));
                return MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IBuffer>.DisposeAbi(__retval);
            }
        }

        unsafe global::Windows.Storage.Streams.IInputStream global::Windows.Storage.Streams.IDataReader.DetachStream()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[31](ThisPtr, out __retval));
                return MarshalInterface<global::Windows.Storage.Streams.IInputStream>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IInputStream>.DisposeAbi(__retval);
            }
        }

        unsafe global::Windows.Storage.Streams.ByteOrder global::Windows.Storage.Streams.IDataReader.ByteOrder
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                global::Windows.Storage.Streams.ByteOrder __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out global::Windows.Storage.Streams.ByteOrder, int>**)ThisPtr)[9](ThisPtr, out __retval));
                return __retval;
            }
            set
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.ByteOrder, int>**)ThisPtr)[10](ThisPtr, value));
            }
        }

        unsafe global::Windows.Storage.Streams.InputStreamOptions global::Windows.Storage.Streams.IDataReader.InputStreamOptions
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                global::Windows.Storage.Streams.InputStreamOptions __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out global::Windows.Storage.Streams.InputStreamOptions, int>**)ThisPtr)[11](ThisPtr, out __retval));
                return __retval;
            }
            set
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.InputStreamOptions, int>**)ThisPtr)[12](ThisPtr, value));
            }
        }

        unsafe uint global::Windows.Storage.Streams.IDataReader.UnconsumedBufferLength
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                uint __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out uint, int>**)ThisPtr)[6](ThisPtr, out __retval));
                return __retval;
            }
        }

        unsafe global::Windows.Storage.Streams.UnicodeEncoding global::Windows.Storage.Streams.IDataReader.UnicodeEncoding
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                global::Windows.Storage.Streams.UnicodeEncoding __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out global::Windows.Storage.Streams.UnicodeEncoding, int>**)ThisPtr)[7](ThisPtr, out __retval));
                return __retval;
            }
            set
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.UnicodeEncoding, int>**)ThisPtr)[8](ThisPtr, value));
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("D7527847-57DA-4E15-914C-06806699A098")]
    internal unsafe interface IDataReaderFactory : global::Windows.Storage.Streams.IDataReaderFactory
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IDataReaderFactory()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IDataReaderFactory), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 1);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_CreateDataReader_0;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateDataReader_0(IntPtr thisPtr, IntPtr inputStream, IntPtr* dataReader)
        {
            global::Windows.Storage.Streams.DataReader __dataReader = default;

            *dataReader = default;

            try
            {
                __dataReader = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReaderFactory>(thisPtr).CreateDataReader(MarshalInterface<global::Windows.Storage.Streams.IInputStream>.FromAbi(inputStream));
                *dataReader = global::ABI.Windows.Storage.Streams.DataReader.FromManaged(__dataReader);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Storage.Streams.DataReader global::Windows.Storage.Streams.IDataReaderFactory.CreateDataReader(global::Windows.Storage.Streams.IInputStream inputStream)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReaderFactory).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IObjectReference __inputStream = default;
            IntPtr __retval = default;
            try
            {
                __inputStream = MarshalInterface<global::Windows.Storage.Streams.IInputStream>.CreateMarshaler(inputStream);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, MarshalInterface<global::Windows.Storage.Streams.IInputStream>.GetAbi(__inputStream), out __retval));
                return global::ABI.Windows.Storage.Streams.DataReader.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IInputStream>.DisposeMarshaler(__inputStream);
                global::ABI.Windows.Storage.Streams.DataReader.DisposeAbi(__retval);
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("11FCBFC8-F93A-471B-B121-F379E349313C")]
    internal unsafe interface IDataReaderStatics : global::Windows.Storage.Streams.IDataReaderStatics
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IDataReaderStatics()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IDataReaderStatics), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 1);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_FromBuffer_0;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_FromBuffer_0(IntPtr thisPtr, IntPtr buffer, IntPtr* dataReader)
        {
            global::Windows.Storage.Streams.DataReader __dataReader = default;

            *dataReader = default;

            try
            {
                __dataReader = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReaderStatics>(thisPtr).FromBuffer(MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromAbi(buffer));
                *dataReader = global::ABI.Windows.Storage.Streams.DataReader.FromManaged(__dataReader);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Storage.Streams.DataReader global::Windows.Storage.Streams.IDataReaderStatics.FromBuffer(global::Windows.Storage.Streams.IBuffer buffer)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReaderStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IObjectReference __buffer = default;
            IntPtr __retval = default;
            try
            {
                __buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.CreateMarshaler(buffer);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, MarshalInterface<global::Windows.Storage.Streams.IBuffer>.GetAbi(__buffer), out __retval));
                return global::ABI.Windows.Storage.Streams.DataReader.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IBuffer>.DisposeMarshaler(__buffer);
                global::ABI.Windows.Storage.Streams.DataReader.DisposeAbi(__retval);
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("64B89265-D341-4922-B38A-DD4AF8808C4E")]
    internal unsafe interface IDataWriter : global::Windows.Storage.Streams.IDataWriter
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IDataWriter()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IDataWriter), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 27);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_get_UnstoredBufferLength_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.UnicodeEncoding*, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_get_UnicodeEncoding_1;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.UnicodeEncoding, int>*)AbiToProjectionVftablePtr)[8] = &Do_Abi_put_UnicodeEncoding_2;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.ByteOrder*, int>*)AbiToProjectionVftablePtr)[9] = &Do_Abi_get_ByteOrder_3;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.ByteOrder, int>*)AbiToProjectionVftablePtr)[10] = &Do_Abi_put_ByteOrder_4;
            ((delegate* unmanaged[Stdcall]<IntPtr, byte, int>*)AbiToProjectionVftablePtr)[11] = &Do_Abi_WriteByte_5;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, int>*)AbiToProjectionVftablePtr)[12] = &Do_Abi_WriteBytes_6;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>*)AbiToProjectionVftablePtr)[13] = &Do_Abi_WriteBuffer_7;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, uint, uint, int>*)AbiToProjectionVftablePtr)[14] = &Do_Abi_WriteBuffer_8;
            ((delegate* unmanaged[Stdcall]<IntPtr, byte, int>*)AbiToProjectionVftablePtr)[15] = &Do_Abi_WriteBoolean_9;
            ((delegate* unmanaged[Stdcall]<IntPtr, Guid, int>*)AbiToProjectionVftablePtr)[16] = &Do_Abi_WriteGuid_10;
            ((delegate* unmanaged[Stdcall]<IntPtr, short, int>*)AbiToProjectionVftablePtr)[17] = &Do_Abi_WriteInt16_11;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, int>*)AbiToProjectionVftablePtr)[18] = &Do_Abi_WriteInt32_12;
            ((delegate* unmanaged[Stdcall]<IntPtr, long, int>*)AbiToProjectionVftablePtr)[19] = &Do_Abi_WriteInt64_13;
            ((delegate* unmanaged[Stdcall]<IntPtr, ushort, int>*)AbiToProjectionVftablePtr)[20] = &Do_Abi_WriteUInt16_14;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint, int>*)AbiToProjectionVftablePtr)[21] = &Do_Abi_WriteUInt32_15;
            ((delegate* unmanaged[Stdcall]<IntPtr, ulong, int>*)AbiToProjectionVftablePtr)[22] = &Do_Abi_WriteUInt64_16;
            ((delegate* unmanaged[Stdcall]<IntPtr, float, int>*)AbiToProjectionVftablePtr)[23] = &Do_Abi_WriteSingle_17;
            ((delegate* unmanaged[Stdcall]<IntPtr, double, int>*)AbiToProjectionVftablePtr)[24] = &Do_Abi_WriteDouble_18;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::ABI.System.DateTimeOffset, int>*)AbiToProjectionVftablePtr)[25] = &Do_Abi_WriteDateTime_19;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::ABI.System.TimeSpan, int>*)AbiToProjectionVftablePtr)[26] = &Do_Abi_WriteTimeSpan_20;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, uint*, int>*)AbiToProjectionVftablePtr)[27] = &Do_Abi_WriteString_21;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, uint*, int>*)AbiToProjectionVftablePtr)[28] = &Do_Abi_MeasureString_22;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[29] = &Do_Abi_StoreAsync_23;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[30] = &Do_Abi_FlushAsync_24;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[31] = &Do_Abi_DetachBuffer_25;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[32] = &Do_Abi_DetachStream_26;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteByte_5(IntPtr thisPtr, byte value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteByte(value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteBytes_6(IntPtr thisPtr, int __valueSize, IntPtr value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteBytes(MarshalBlittable<byte>.FromAbiArray((__valueSize, value)));

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteBuffer_7(IntPtr thisPtr, IntPtr buffer)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteBuffer(MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromAbi(buffer));

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteBuffer_8(IntPtr thisPtr, IntPtr buffer, uint start, uint count)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteBuffer(MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromAbi(buffer), start, count);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteBoolean_9(IntPtr thisPtr, byte value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteBoolean(value != 0);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteGuid_10(IntPtr thisPtr, Guid value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteGuid(value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteInt16_11(IntPtr thisPtr, short value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteInt16(value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteInt32_12(IntPtr thisPtr, int value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteInt32(value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteInt64_13(IntPtr thisPtr, long value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteInt64(value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteUInt16_14(IntPtr thisPtr, ushort value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteUInt16(value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteUInt32_15(IntPtr thisPtr, uint value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteUInt32(value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteUInt64_16(IntPtr thisPtr, ulong value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteUInt64(value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteSingle_17(IntPtr thisPtr, float value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteSingle(value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteDouble_18(IntPtr thisPtr, double value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteDouble(value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteDateTime_19(IntPtr thisPtr, global::ABI.System.DateTimeOffset value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteDateTime(global::ABI.System.DateTimeOffset.FromAbi(value));

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteTimeSpan_20(IntPtr thisPtr, global::ABI.System.TimeSpan value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteTimeSpan(global::ABI.System.TimeSpan.FromAbi(value));

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteString_21(IntPtr thisPtr, IntPtr value, uint* codeUnitCount)
        {
            uint __codeUnitCount = default;

            *codeUnitCount = default;

            try
            {
                __codeUnitCount = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteString(MarshalString.FromAbi(value));
                *codeUnitCount = __codeUnitCount;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_MeasureString_22(IntPtr thisPtr, IntPtr value, uint* codeUnitCount)
        {
            uint __codeUnitCount = default;

            *codeUnitCount = default;

            try
            {
                __codeUnitCount = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).MeasureString(MarshalString.FromAbi(value));
                *codeUnitCount = __codeUnitCount;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_StoreAsync_23(IntPtr thisPtr, IntPtr* operation)
        {
            global::Windows.Storage.Streams.DataWriterStoreOperation __operation = default;

            *operation = default;

            try
            {
                __operation = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).StoreAsync();
                *operation = global::ABI.Windows.Storage.Streams.DataWriterStoreOperation.FromManaged(__operation);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_FlushAsync_24(IntPtr thisPtr, IntPtr* operation)
        {
            global::Windows.Foundation.IAsyncOperation<bool> __operation = default;

            *operation = default;

            try
            {
                __operation = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).FlushAsync();
                *operation = MarshalInterface<global::Windows.Foundation.IAsyncOperation<bool>>.FromManaged(__operation);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_DetachBuffer_25(IntPtr thisPtr, IntPtr* buffer)
        {
            global::Windows.Storage.Streams.IBuffer __buffer = default;

            *buffer = default;

            try
            {
                __buffer = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).DetachBuffer();
                *buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromManaged(__buffer);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_DetachStream_26(IntPtr thisPtr, IntPtr* outputStream)
        {
            global::Windows.Storage.Streams.IOutputStream __outputStream = default;

            *outputStream = default;

            try
            {
                __outputStream = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).DetachStream();
                *outputStream = MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.FromManaged(__outputStream);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_put_ByteOrder_4(IntPtr thisPtr, global::Windows.Storage.Streams.ByteOrder value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).ByteOrder = value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_ByteOrder_3(IntPtr thisPtr, global::Windows.Storage.Streams.ByteOrder* value)
        {
            global::Windows.Storage.Streams.ByteOrder __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).ByteOrder;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_put_UnicodeEncoding_2(IntPtr thisPtr, global::Windows.Storage.Streams.UnicodeEncoding value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).UnicodeEncoding = value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_UnicodeEncoding_1(IntPtr thisPtr, global::Windows.Storage.Streams.UnicodeEncoding* value)
        {
            global::Windows.Storage.Streams.UnicodeEncoding __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).UnicodeEncoding;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_UnstoredBufferLength_0(IntPtr thisPtr, uint* value)
        {
            uint __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).UnstoredBufferLength;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteByte(byte value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, byte, int>**)ThisPtr)[11](ThisPtr, value));
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteBytes(byte[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalBlittable<byte>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            try
            {
                __value = MarshalBlittable<byte>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalBlittable<byte>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, int>**)ThisPtr)[12](ThisPtr, __value_length, __value_data));
            }
            finally
            {
                MarshalBlittable<byte>.DisposeMarshalerArray(__value);
            }
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteBuffer(global::Windows.Storage.Streams.IBuffer buffer)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IObjectReference __buffer = default;
            try
            {
                __buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.CreateMarshaler(buffer);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>**)ThisPtr)[13](ThisPtr, MarshalInterface<global::Windows.Storage.Streams.IBuffer>.GetAbi(__buffer)));
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IBuffer>.DisposeMarshaler(__buffer);
            }
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteBuffer(global::Windows.Storage.Streams.IBuffer buffer, uint start, uint count)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IObjectReference __buffer = default;
            try
            {
                __buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.CreateMarshaler(buffer);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, uint, uint, int>**)ThisPtr)[14](ThisPtr, MarshalInterface<global::Windows.Storage.Streams.IBuffer>.GetAbi(__buffer), start, count));
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IBuffer>.DisposeMarshaler(__buffer);
            }
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteBoolean(bool value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, byte, int>**)ThisPtr)[15](ThisPtr, (byte)(value ? 1 : 0)));
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteGuid(Guid value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, Guid, int>**)ThisPtr)[16](ThisPtr, value));
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteInt16(short value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, short, int>**)ThisPtr)[17](ThisPtr, value));
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteInt32(int value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, int>**)ThisPtr)[18](ThisPtr, value));
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteInt64(long value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, long, int>**)ThisPtr)[19](ThisPtr, value));
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteUInt16(ushort value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, ushort, int>**)ThisPtr)[20](ThisPtr, value));
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteUInt32(uint value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint, int>**)ThisPtr)[21](ThisPtr, value));
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteUInt64(ulong value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, ulong, int>**)ThisPtr)[22](ThisPtr, value));
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteSingle(float value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, float, int>**)ThisPtr)[23](ThisPtr, value));
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteDouble(double value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, double, int>**)ThisPtr)[24](ThisPtr, value));
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteDateTime(global::System.DateTimeOffset value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::ABI.System.DateTimeOffset.Marshaler __value = default;
            try
            {
                __value = global::ABI.System.DateTimeOffset.CreateMarshaler(value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::ABI.System.DateTimeOffset, int>**)ThisPtr)[25](ThisPtr, global::ABI.System.DateTimeOffset.GetAbi(__value)));
            }
            finally
            {
                global::ABI.System.DateTimeOffset.DisposeMarshaler(__value);
            }
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteTimeSpan(global::System.TimeSpan value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::ABI.System.TimeSpan.Marshaler __value = default;
            try
            {
                __value = global::ABI.System.TimeSpan.CreateMarshaler(value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::ABI.System.TimeSpan, int>**)ThisPtr)[26](ThisPtr, global::ABI.System.TimeSpan.GetAbi(__value)));
            }
            finally
            {
                global::ABI.System.TimeSpan.DisposeMarshaler(__value);
            }
        }

        unsafe uint global::Windows.Storage.Streams.IDataWriter.WriteString(string value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalString __value = default;
            uint __retval = default;
            try
            {
                __value = MarshalString.CreateMarshaler(value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out uint, int>**)ThisPtr)[27](ThisPtr, MarshalString.GetAbi(__value), out __retval));
                return __retval;
            }
            finally
            {
                MarshalString.DisposeMarshaler(__value);
            }
        }

        unsafe uint global::Windows.Storage.Streams.IDataWriter.MeasureString(string value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalString __value = default;
            uint __retval = default;
            try
            {
                __value = MarshalString.CreateMarshaler(value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out uint, int>**)ThisPtr)[28](ThisPtr, MarshalString.GetAbi(__value), out __retval));
                return __retval;
            }
            finally
            {
                MarshalString.DisposeMarshaler(__value);
            }
        }

        unsafe global::Windows.Storage.Streams.DataWriterStoreOperation global::Windows.Storage.Streams.IDataWriter.StoreAsync()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[29](ThisPtr, out __retval));
                return global::ABI.Windows.Storage.Streams.DataWriterStoreOperation.FromAbi(__retval);
            }
            finally
            {
                global::ABI.Windows.Storage.Streams.DataWriterStoreOperation.DisposeAbi(__retval);
            }
        }

        unsafe global::Windows.Foundation.IAsyncOperation<bool> global::Windows.Storage.Streams.IDataWriter.FlushAsync()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[30](ThisPtr, out __retval));
                return MarshalInterface<global::Windows.Foundation.IAsyncOperation<bool>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Foundation.IAsyncOperation<bool>>.DisposeAbi(__retval);
            }
        }

        unsafe global::Windows.Storage.Streams.IBuffer global::Windows.Storage.Streams.IDataWriter.DetachBuffer()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[31](ThisPtr, out __retval));
                return MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IBuffer>.DisposeAbi(__retval);
            }
        }

        unsafe global::Windows.Storage.Streams.IOutputStream global::Windows.Storage.Streams.IDataWriter.DetachStream()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[32](ThisPtr, out __retval));
                return MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.DisposeAbi(__retval);
            }
        }

        unsafe global::Windows.Storage.Streams.ByteOrder global::Windows.Storage.Streams.IDataWriter.ByteOrder
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                global::Windows.Storage.Streams.ByteOrder __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out global::Windows.Storage.Streams.ByteOrder, int>**)ThisPtr)[9](ThisPtr, out __retval));
                return __retval;
            }
            set
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.ByteOrder, int>**)ThisPtr)[10](ThisPtr, value));
            }
        }

        unsafe global::Windows.Storage.Streams.UnicodeEncoding global::Windows.Storage.Streams.IDataWriter.UnicodeEncoding
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                global::Windows.Storage.Streams.UnicodeEncoding __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out global::Windows.Storage.Streams.UnicodeEncoding, int>**)ThisPtr)[7](ThisPtr, out __retval));
                return __retval;
            }
            set
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.UnicodeEncoding, int>**)ThisPtr)[8](ThisPtr, value));
            }
        }

        unsafe uint global::Windows.Storage.Streams.IDataWriter.UnstoredBufferLength
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                uint __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out uint, int>**)ThisPtr)[6](ThisPtr, out __retval));
                return __retval;
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("338C67C2-8B84-4C2B-9C50-7B8767847A1F")]
    internal unsafe interface IDataWriterFactory : global::Windows.Storage.Streams.IDataWriterFactory
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IDataWriterFactory()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IDataWriterFactory), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 1);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_CreateDataWriter_0;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateDataWriter_0(IntPtr thisPtr, IntPtr outputStream, IntPtr* dataWriter)
        {
            global::Windows.Storage.Streams.DataWriter __dataWriter = default;

            *dataWriter = default;

            try
            {
                __dataWriter = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriterFactory>(thisPtr).CreateDataWriter(MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.FromAbi(outputStream));
                *dataWriter = global::ABI.Windows.Storage.Streams.DataWriter.FromManaged(__dataWriter);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Storage.Streams.DataWriter global::Windows.Storage.Streams.IDataWriterFactory.CreateDataWriter(global::Windows.Storage.Streams.IOutputStream outputStream)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriterFactory).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IObjectReference __outputStream = default;
            IntPtr __retval = default;
            try
            {
                __outputStream = MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.CreateMarshaler(outputStream);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.GetAbi(__outputStream), out __retval));
                return global::ABI.Windows.Storage.Streams.DataWriter.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.DisposeMarshaler(__outputStream);
                global::ABI.Windows.Storage.Streams.DataWriter.DisposeAbi(__retval);
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("905A0FE2-BC53-11DF-8C49-001E4FC686DA")]
    internal unsafe interface IInputStream : global::Windows.Storage.Streams.IInputStream
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IInputStream()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IInputStream), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 1);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, uint, global::Windows.Storage.Streams.InputStreamOptions, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_ReadAsync_0;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadAsync_0(IntPtr thisPtr, IntPtr buffer, uint count, global::Windows.Storage.Streams.InputStreamOptions options, IntPtr* operation)
        {
            global::Windows.Foundation.IAsyncOperationWithProgress<global::Windows.Storage.Streams.IBuffer, uint> __operation = default;

            *operation = default;

            try
            {
                __operation = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IInputStream>(thisPtr).ReadAsync(MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromAbi(buffer), count, options);
                *operation = MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<global::Windows.Storage.Streams.IBuffer, uint>>.FromManaged(__operation);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Foundation.IAsyncOperationWithProgress<global::Windows.Storage.Streams.IBuffer, uint> global::Windows.Storage.Streams.IInputStream.ReadAsync(global::Windows.Storage.Streams.IBuffer buffer, uint count, global::Windows.Storage.Streams.InputStreamOptions options)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IInputStream).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IObjectReference __buffer = default;
            IntPtr __retval = default;
            try
            {
                __buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.CreateMarshaler(buffer);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, uint, global::Windows.Storage.Streams.InputStreamOptions, out IntPtr, int>**)ThisPtr)[6](ThisPtr, MarshalInterface<global::Windows.Storage.Streams.IBuffer>.GetAbi(__buffer), count, options, out __retval));
                return MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<global::Windows.Storage.Streams.IBuffer, uint>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IBuffer>.DisposeMarshaler(__buffer);
                MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<global::Windows.Storage.Streams.IBuffer, uint>>.DisposeAbi(__retval);
            }
        }

        void global::System.IDisposable.Dispose() => ((global::System.IDisposable)(IWinRTObject)this).Dispose();
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("43929D18-5EC9-4B5A-919C-4205B0C804B6")]
    internal unsafe interface IInputStreamReference : global::Windows.Storage.Streams.IInputStreamReference
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IInputStreamReference()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IInputStreamReference), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 1);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_OpenSequentialReadAsync_0;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_OpenSequentialReadAsync_0(IntPtr thisPtr, IntPtr* operation)
        {
            global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IInputStream> __operation = default;

            *operation = default;

            try
            {
                __operation = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IInputStreamReference>(thisPtr).OpenSequentialReadAsync();
                *operation = MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IInputStream>>.FromManaged(__operation);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IInputStream> global::Windows.Storage.Streams.IInputStreamReference.OpenSequentialReadAsync()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IInputStreamReference).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, out __retval));
                return MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IInputStream>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IInputStream>>.DisposeAbi(__retval);
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("905A0FE6-BC53-11DF-8C49-001E4FC686DA")]
    internal unsafe interface IOutputStream : global::Windows.Storage.Streams.IOutputStream
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IOutputStream()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IOutputStream), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 2);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_WriteAsync_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_FlushAsync_1;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteAsync_0(IntPtr thisPtr, IntPtr buffer, IntPtr* operation)
        {
            global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> __operation = default;

            *operation = default;

            try
            {
                __operation = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IOutputStream>(thisPtr).WriteAsync(MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromAbi(buffer));
                *operation = MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint>>.FromManaged(__operation);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_FlushAsync_1(IntPtr thisPtr, IntPtr* operation)
        {
            global::Windows.Foundation.IAsyncOperation<bool> __operation = default;

            *operation = default;

            try
            {
                __operation = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IOutputStream>(thisPtr).FlushAsync();
                *operation = MarshalInterface<global::Windows.Foundation.IAsyncOperation<bool>>.FromManaged(__operation);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> global::Windows.Storage.Streams.IOutputStream.WriteAsync(global::Windows.Storage.Streams.IBuffer buffer)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IOutputStream).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IObjectReference __buffer = default;
            IntPtr __retval = default;
            try
            {
                __buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.CreateMarshaler(buffer);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, MarshalInterface<global::Windows.Storage.Streams.IBuffer>.GetAbi(__buffer), out __retval));
                return MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IBuffer>.DisposeMarshaler(__buffer);
                MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint>>.DisposeAbi(__retval);
            }
        }

        unsafe global::Windows.Foundation.IAsyncOperation<bool> global::Windows.Storage.Streams.IOutputStream.FlushAsync()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IOutputStream).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[7](ThisPtr, out __retval));
                return MarshalInterface<global::Windows.Foundation.IAsyncOperation<bool>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Foundation.IAsyncOperation<bool>>.DisposeAbi(__retval);
            }
        }

        void global::System.IDisposable.Dispose() => ((global::System.IDisposable)(IWinRTObject)this).Dispose();
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("905A0FE1-BC53-11DF-8C49-001E4FC686DA")]
    internal unsafe interface IRandomAccessStream : global::Windows.Storage.Streams.IRandomAccessStream
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IRandomAccessStream()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IRandomAccessStream), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 9);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, ulong*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_get_Size_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, ulong, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_put_Size_1;
            ((delegate* unmanaged[Stdcall]<IntPtr, ulong, IntPtr*, int>*)AbiToProjectionVftablePtr)[8] = &Do_Abi_GetInputStreamAt_2;
            ((delegate* unmanaged[Stdcall]<IntPtr, ulong, IntPtr*, int>*)AbiToProjectionVftablePtr)[9] = &Do_Abi_GetOutputStreamAt_3;
            ((delegate* unmanaged[Stdcall]<IntPtr, ulong*, int>*)AbiToProjectionVftablePtr)[10] = &Do_Abi_get_Position_4;
            ((delegate* unmanaged[Stdcall]<IntPtr, ulong, int>*)AbiToProjectionVftablePtr)[11] = &Do_Abi_Seek_5;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[12] = &Do_Abi_CloneStream_6;
            ((delegate* unmanaged[Stdcall]<IntPtr, byte*, int>*)AbiToProjectionVftablePtr)[13] = &Do_Abi_get_CanRead_7;
            ((delegate* unmanaged[Stdcall]<IntPtr, byte*, int>*)AbiToProjectionVftablePtr)[14] = &Do_Abi_get_CanWrite_8;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_GetInputStreamAt_2(IntPtr thisPtr, ulong position, IntPtr* stream)
        {
            global::Windows.Storage.Streams.IInputStream __stream = default;

            *stream = default;

            try
            {
                __stream = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStream>(thisPtr).GetInputStreamAt(position);
                *stream = MarshalInterface<global::Windows.Storage.Streams.IInputStream>.FromManaged(__stream);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_GetOutputStreamAt_3(IntPtr thisPtr, ulong position, IntPtr* stream)
        {
            global::Windows.Storage.Streams.IOutputStream __stream = default;

            *stream = default;

            try
            {
                __stream = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStream>(thisPtr).GetOutputStreamAt(position);
                *stream = MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.FromManaged(__stream);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_Seek_5(IntPtr thisPtr, ulong position)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStream>(thisPtr).Seek(position);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CloneStream_6(IntPtr thisPtr, IntPtr* stream)
        {
            global::Windows.Storage.Streams.IRandomAccessStream __stream = default;

            *stream = default;

            try
            {
                __stream = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStream>(thisPtr).CloneStream();
                *stream = MarshalInterface<global::Windows.Storage.Streams.IRandomAccessStream>.FromManaged(__stream);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_CanRead_7(IntPtr thisPtr, byte* value)
        {
            bool __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStream>(thisPtr).CanRead;
                *value = (byte)(__value ? 1 : 0);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_CanWrite_8(IntPtr thisPtr, byte* value)
        {
            bool __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStream>(thisPtr).CanWrite;
                *value = (byte)(__value ? 1 : 0);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Position_4(IntPtr thisPtr, ulong* value)
        {
            ulong __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStream>(thisPtr).Position;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_put_Size_1(IntPtr thisPtr, ulong value)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStream>(thisPtr).Size = value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Size_0(IntPtr thisPtr, ulong* value)
        {
            ulong __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStream>(thisPtr).Size;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Storage.Streams.IInputStream global::Windows.Storage.Streams.IRandomAccessStream.GetInputStreamAt(ulong position)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStream).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, ulong, out IntPtr, int>**)ThisPtr)[8](ThisPtr, position, out __retval));
                return MarshalInterface<global::Windows.Storage.Streams.IInputStream>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IInputStream>.DisposeAbi(__retval);
            }
        }

        unsafe global::Windows.Storage.Streams.IOutputStream global::Windows.Storage.Streams.IRandomAccessStream.GetOutputStreamAt(ulong position)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStream).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, ulong, out IntPtr, int>**)ThisPtr)[9](ThisPtr, position, out __retval));
                return MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.DisposeAbi(__retval);
            }
        }

        unsafe void global::Windows.Storage.Streams.IRandomAccessStream.Seek(ulong position)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStream).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, ulong, int>**)ThisPtr)[11](ThisPtr, position));
        }

        unsafe global::Windows.Storage.Streams.IRandomAccessStream global::Windows.Storage.Streams.IRandomAccessStream.CloneStream()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStream).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[12](ThisPtr, out __retval));
                return MarshalInterface<global::Windows.Storage.Streams.IRandomAccessStream>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IRandomAccessStream>.DisposeAbi(__retval);
            }
        }

        unsafe bool global::Windows.Storage.Streams.IRandomAccessStream.CanRead
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStream).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                byte __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out byte, int>**)ThisPtr)[13](ThisPtr, out __retval));
                return __retval != 0;
            }
        }

        unsafe bool global::Windows.Storage.Streams.IRandomAccessStream.CanWrite
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStream).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                byte __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out byte, int>**)ThisPtr)[14](ThisPtr, out __retval));
                return __retval != 0;
            }
        }

        unsafe ulong global::Windows.Storage.Streams.IRandomAccessStream.Position
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStream).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                ulong __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out ulong, int>**)ThisPtr)[10](ThisPtr, out __retval));
                return __retval;
            }
        }

        unsafe ulong global::Windows.Storage.Streams.IRandomAccessStream.Size
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStream).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                ulong __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out ulong, int>**)ThisPtr)[6](ThisPtr, out __retval));
                return __retval;
            }
            set
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStream).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, ulong, int>**)ThisPtr)[7](ThisPtr, value));
            }
        }

        void global::System.IDisposable.Dispose() => ((global::System.IDisposable)(IWinRTObject)this).Dispose();

        global::Windows.Foundation.IAsyncOperationWithProgress<global::Windows.Storage.Streams.IBuffer, uint> global::Windows.Storage.Streams.IInputStream.ReadAsync(global::Windows.Storage.Streams.IBuffer buffer, uint count, global::Windows.Storage.Streams.InputStreamOptions options) => ((global::Windows.Storage.Streams.IInputStream)(IWinRTObject)this).ReadAsync(buffer, count, options);

        global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> global::Windows.Storage.Streams.IOutputStream.WriteAsync(global::Windows.Storage.Streams.IBuffer buffer) => ((global::Windows.Storage.Streams.IOutputStream)(IWinRTObject)this).WriteAsync(buffer);

        global::Windows.Foundation.IAsyncOperation<bool> global::Windows.Storage.Streams.IOutputStream.FlushAsync() => ((global::Windows.Storage.Streams.IOutputStream)(IWinRTObject)this).FlushAsync();
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("33EE3134-1DD6-4E3A-8067-D1C162E8642B")]
    internal unsafe interface IRandomAccessStreamReference : global::Windows.Storage.Streams.IRandomAccessStreamReference
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IRandomAccessStreamReference()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IRandomAccessStreamReference), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 1);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_OpenReadAsync_0;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_OpenReadAsync_0(IntPtr thisPtr, IntPtr* operation)
        {
            global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStreamWithContentType> __operation = default;

            *operation = default;

            try
            {
                __operation = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStreamReference>(thisPtr).OpenReadAsync();
                *operation = MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStreamWithContentType>>.FromManaged(__operation);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStreamWithContentType> global::Windows.Storage.Streams.IRandomAccessStreamReference.OpenReadAsync()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStreamReference).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, out __retval));
                return MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStreamWithContentType>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStreamWithContentType>>.DisposeAbi(__retval);
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("524CEDCF-6E29-4CE5-9573-6B753DB66C3A")]
    internal unsafe interface IRandomAccessStreamStatics : global::Windows.Storage.Streams.IRandomAccessStreamStatics
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IRandomAccessStreamStatics()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IRandomAccessStreamStatics), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 3);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_CopyAsync_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, ulong, IntPtr*, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_CopyAsync_1;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[8] = &Do_Abi_CopyAndCloseAsync_2;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CopyAsync_0(IntPtr thisPtr, IntPtr source, IntPtr destination, IntPtr* operation)
        {
            global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> __operation = default;

            *operation = default;

            try
            {
                __operation = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStreamStatics>(thisPtr).CopyAsync(MarshalInterface<global::Windows.Storage.Streams.IInputStream>.FromAbi(source), MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.FromAbi(destination));
                *operation = MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong>>.FromManaged(__operation);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CopyAsync_1(IntPtr thisPtr, IntPtr source, IntPtr destination, ulong bytesToCopy, IntPtr* operation)
        {
            global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> __operation = default;

            *operation = default;

            try
            {
                __operation = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStreamStatics>(thisPtr).CopyAsync(MarshalInterface<global::Windows.Storage.Streams.IInputStream>.FromAbi(source), MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.FromAbi(destination), bytesToCopy);
                *operation = MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong>>.FromManaged(__operation);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CopyAndCloseAsync_2(IntPtr thisPtr, IntPtr source, IntPtr destination, IntPtr* operation)
        {
            global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> __operation = default;

            *operation = default;

            try
            {
                __operation = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStreamStatics>(thisPtr).CopyAndCloseAsync(MarshalInterface<global::Windows.Storage.Streams.IInputStream>.FromAbi(source), MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.FromAbi(destination));
                *operation = MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong>>.FromManaged(__operation);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> global::Windows.Storage.Streams.IRandomAccessStreamStatics.CopyAsync(global::Windows.Storage.Streams.IInputStream source, global::Windows.Storage.Streams.IOutputStream destination)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStreamStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IObjectReference __source = default;
            IObjectReference __destination = default;
            IntPtr __retval = default;
            try
            {
                __source = MarshalInterface<global::Windows.Storage.Streams.IInputStream>.CreateMarshaler(source);
                __destination = MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.CreateMarshaler(destination);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, MarshalInterface<global::Windows.Storage.Streams.IInputStream>.GetAbi(__source), MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.GetAbi(__destination), out __retval));
                return MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IInputStream>.DisposeMarshaler(__source);
                MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.DisposeMarshaler(__destination);
                MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong>>.DisposeAbi(__retval);
            }
        }

        unsafe global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> global::Windows.Storage.Streams.IRandomAccessStreamStatics.CopyAsync(global::Windows.Storage.Streams.IInputStream source, global::Windows.Storage.Streams.IOutputStream destination, ulong bytesToCopy)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStreamStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IObjectReference __source = default;
            IObjectReference __destination = default;
            IntPtr __retval = default;
            try
            {
                __source = MarshalInterface<global::Windows.Storage.Streams.IInputStream>.CreateMarshaler(source);
                __destination = MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.CreateMarshaler(destination);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, ulong, out IntPtr, int>**)ThisPtr)[7](ThisPtr, MarshalInterface<global::Windows.Storage.Streams.IInputStream>.GetAbi(__source), MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.GetAbi(__destination), bytesToCopy, out __retval));
                return MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IInputStream>.DisposeMarshaler(__source);
                MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.DisposeMarshaler(__destination);
                MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong>>.DisposeAbi(__retval);
            }
        }

        unsafe global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> global::Windows.Storage.Streams.IRandomAccessStreamStatics.CopyAndCloseAsync(global::Windows.Storage.Streams.IInputStream source, global::Windows.Storage.Streams.IOutputStream destination)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStreamStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IObjectReference __source = default;
            IObjectReference __destination = default;
            IntPtr __retval = default;
            try
            {
                __source = MarshalInterface<global::Windows.Storage.Streams.IInputStream>.CreateMarshaler(source);
                __destination = MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.CreateMarshaler(destination);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[8](ThisPtr, MarshalInterface<global::Windows.Storage.Streams.IInputStream>.GetAbi(__source), MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.GetAbi(__destination), out __retval));
                return MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IInputStream>.DisposeMarshaler(__source);
                MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.DisposeMarshaler(__destination);
                MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong>>.DisposeAbi(__retval);
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("CC254827-4B3D-438F-9232-10C76BC7E038")]
    internal unsafe interface IRandomAccessStreamWithContentType : global::Windows.Storage.Streams.IRandomAccessStreamWithContentType
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IRandomAccessStreamWithContentType()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IRandomAccessStreamWithContentType), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 0);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;

        }


        void global::System.IDisposable.Dispose() => ((global::System.IDisposable)(IWinRTObject)this).Dispose();

        string global::Windows.Storage.Streams.IContentTypeProvider.ContentType => ((global::Windows.Storage.Streams.IContentTypeProvider)(IWinRTObject)this).ContentType;

        global::Windows.Foundation.IAsyncOperationWithProgress<global::Windows.Storage.Streams.IBuffer, uint> global::Windows.Storage.Streams.IInputStream.ReadAsync(global::Windows.Storage.Streams.IBuffer buffer, uint count, global::Windows.Storage.Streams.InputStreamOptions options) => ((global::Windows.Storage.Streams.IInputStream)(IWinRTObject)this).ReadAsync(buffer, count, options);

        global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> global::Windows.Storage.Streams.IOutputStream.WriteAsync(global::Windows.Storage.Streams.IBuffer buffer) => ((global::Windows.Storage.Streams.IOutputStream)(IWinRTObject)this).WriteAsync(buffer);

        global::Windows.Foundation.IAsyncOperation<bool> global::Windows.Storage.Streams.IOutputStream.FlushAsync() => ((global::Windows.Storage.Streams.IOutputStream)(IWinRTObject)this).FlushAsync();

        global::Windows.Storage.Streams.IInputStream global::Windows.Storage.Streams.IRandomAccessStream.GetInputStreamAt(ulong position) => ((global::Windows.Storage.Streams.IRandomAccessStream)(IWinRTObject)this).GetInputStreamAt(position);

        global::Windows.Storage.Streams.IOutputStream global::Windows.Storage.Streams.IRandomAccessStream.GetOutputStreamAt(ulong position) => ((global::Windows.Storage.Streams.IRandomAccessStream)(IWinRTObject)this).GetOutputStreamAt(position);

        void global::Windows.Storage.Streams.IRandomAccessStream.Seek(ulong position) => ((global::Windows.Storage.Streams.IRandomAccessStream)(IWinRTObject)this).Seek(position);

        global::Windows.Storage.Streams.IRandomAccessStream global::Windows.Storage.Streams.IRandomAccessStream.CloneStream() => ((global::Windows.Storage.Streams.IRandomAccessStream)(IWinRTObject)this).CloneStream();

        bool global::Windows.Storage.Streams.IRandomAccessStream.CanRead => ((global::Windows.Storage.Streams.IRandomAccessStream)(IWinRTObject)this).CanRead;

        bool global::Windows.Storage.Streams.IRandomAccessStream.CanWrite => ((global::Windows.Storage.Streams.IRandomAccessStream)(IWinRTObject)this).CanWrite;

        ulong global::Windows.Storage.Streams.IRandomAccessStream.Position => ((global::Windows.Storage.Streams.IRandomAccessStream)(IWinRTObject)this).Position;

        ulong global::Windows.Storage.Streams.IRandomAccessStream.Size
        {
            get => ((global::Windows.Storage.Streams.IRandomAccessStream)(IWinRTObject)this).Size;
            set => ((global::Windows.Storage.Streams.IRandomAccessStream)(IWinRTObject)this).Size = value;
        }
    }

    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct InMemoryRandomAccessStream
    {
        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.InMemoryRandomAccessStream obj) => obj is null ? null : MarshalInterface<global::Windows.Storage.Streams.IRandomAccessStream>.CreateMarshaler(obj);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.InMemoryRandomAccessStream FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.InMemoryRandomAccessStream.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.InMemoryRandomAccessStream obj) => obj is null ? IntPtr.Zero : CreateMarshaler(obj).GetRef();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.InMemoryRandomAccessStream>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.InMemoryRandomAccessStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InMemoryRandomAccessStream>.CreateMarshalerArray(array, (o) => CreateMarshaler(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InMemoryRandomAccessStream>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.InMemoryRandomAccessStream[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InMemoryRandomAccessStream>.FromAbiArray(box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.InMemoryRandomAccessStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InMemoryRandomAccessStream>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.InMemoryRandomAccessStream>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InMemoryRandomAccessStream>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct InputStreamOverStream
    {
        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.InputStreamOverStream obj) => obj is null ? null : MarshalInterface<global::Windows.Storage.Streams.IInputStream>.CreateMarshaler(obj);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.InputStreamOverStream FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.InputStreamOverStream.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.InputStreamOverStream obj) => obj is null ? IntPtr.Zero : CreateMarshaler(obj).GetRef();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.InputStreamOverStream>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.InputStreamOverStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InputStreamOverStream>.CreateMarshalerArray(array, (o) => CreateMarshaler(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InputStreamOverStream>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.InputStreamOverStream[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InputStreamOverStream>.FromAbiArray(box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.InputStreamOverStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InputStreamOverStream>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.InputStreamOverStream>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InputStreamOverStream>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct OutputStreamOverStream
    {
        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.OutputStreamOverStream obj) => obj is null ? null : MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.CreateMarshaler(obj);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.OutputStreamOverStream FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.OutputStreamOverStream.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.OutputStreamOverStream obj) => obj is null ? IntPtr.Zero : CreateMarshaler(obj).GetRef();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.OutputStreamOverStream>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.OutputStreamOverStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.OutputStreamOverStream>.CreateMarshalerArray(array, (o) => CreateMarshaler(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.OutputStreamOverStream>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.OutputStreamOverStream[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.OutputStreamOverStream>.FromAbiArray(box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.OutputStreamOverStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.OutputStreamOverStream>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.OutputStreamOverStream>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.OutputStreamOverStream>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct RandomAccessStreamOverStream
    {
        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.RandomAccessStreamOverStream obj) => obj is null ? null : MarshalInterface<global::Windows.Storage.Streams.IRandomAccessStream>.CreateMarshaler(obj);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.RandomAccessStreamOverStream FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.RandomAccessStreamOverStream.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.RandomAccessStreamOverStream obj) => obj is null ? IntPtr.Zero : CreateMarshaler(obj).GetRef();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamOverStream>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.RandomAccessStreamOverStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamOverStream>.CreateMarshalerArray(array, (o) => CreateMarshaler(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamOverStream>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.RandomAccessStreamOverStream[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamOverStream>.FromAbiArray(box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.RandomAccessStreamOverStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamOverStream>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamOverStream>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamOverStream>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
}
#pragma warning restore CA1416

namespace Windows.Storage.Streams
{
    using global::System;

    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")]
    [Guid("905a0fef-bc53-11df-8c49-001e4fc686da")]
    internal interface IBufferByteAccess
    {
        IntPtr Buffer { get; }
    }
}

namespace ABI.Windows.Storage.Streams
{
    using global::System;
    using global::System.Runtime.InteropServices;
    using global::System.ComponentModel;

#if NETSTANDARD2_0
    [global::WinRT.ObjectReferenceWrapper(nameof(_obj)), EditorBrowsable(EditorBrowsableState.Never)]
    [Guid("905a0fef-bc53-11df-8c49-001e4fc686da")]
    internal unsafe class IBufferByteAccess : global::Windows.Storage.Streams.IBufferByteAccess
    {
        [Guid("905a0fef-bc53-11df-8c49-001e4fc686da")]
        public struct Vftbl
        {
            internal global::WinRT.Interop.IUnknownVftbl IUnknownVftbl;
            private void* _get_Buffer_0;
            public delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int> get_Buffer_0 { get => (delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>)_get_Buffer_0; set => _get_Buffer_0 = value; }

            public unsafe delegate int _get_Buffer_0_delegate(IntPtr thisPtr, IntPtr* result);
            private static readonly _get_Buffer_0_delegate DelegateCache;

            static unsafe Vftbl()
            {
                AbiToProjectionVftable = new Vftbl
                {
                    IUnknownVftbl = global::WinRT.Interop.IUnknownVftbl.AbiToProjectionVftbl,
                    _get_Buffer_0 = Marshal.GetFunctionPointerForDelegate(DelegateCache = Do_Abi_get_Buffer_0).ToPointer()
                };
                var nativeVftbl = (IntPtr*)ComWrappersSupport.AllocateVtableMemory(typeof(Vftbl), Marshal.SizeOf<global::WinRT.IInspectable.Vftbl>() + sizeof(IntPtr) * 1);
                Marshal.StructureToPtr(AbiToProjectionVftable, (IntPtr)nativeVftbl, false);
                AbiToProjectionVftablePtr = (IntPtr)nativeVftbl;
            }

            public static readonly Vftbl AbiToProjectionVftable;
            public static readonly IntPtr AbiToProjectionVftablePtr;

            private static int Do_Abi_get_Buffer_0(IntPtr thisPtr, IntPtr* buffer)
            {
                *buffer = default;
                try
                {
                    *buffer = ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IBufferByteAccess>(thisPtr).Buffer;
                }
                catch (Exception ex)
                {
                    return Marshal.GetHRForException(ex);
                }
                return 0;
            }
        }
        internal static ObjectReference<Vftbl> FromAbi(IntPtr thisPtr) => ObjectReference<Vftbl>.FromAbi(thisPtr);

        public static implicit operator IBufferByteAccess(IObjectReference obj) => (obj != null) ? new IBufferByteAccess(obj) : null;
        protected readonly ObjectReference<Vftbl> _obj;
        public IObjectReference ObjRef { get => _obj; }
        public IntPtr ThisPtr => _obj.ThisPtr;
        public ObjectReference<I> AsInterface<I>() => _obj.As<I>();
        public A As<A>() => _obj.AsType<A>();
        public IBufferByteAccess(IObjectReference obj) : this(obj.As<Vftbl>()) { }
        internal IBufferByteAccess(ObjectReference<Vftbl> obj)
        {
            _obj = obj;
        }

        public IntPtr Buffer
        {
            get
            {
                IntPtr __retval = default;
                Marshal.ThrowExceptionForHR(_obj.Vftbl.get_Buffer_0(ThisPtr, &__retval));
                return __retval;
            }
        }
    }
#else
    [DynamicInterfaceCastableImplementation]
    [Guid("905a0fef-bc53-11df-8c49-001e4fc686da")]
    internal interface IBufferByteAccess : global::Windows.Storage.Streams.IBufferByteAccess
    {
        [Guid("905a0fef-bc53-11df-8c49-001e4fc686da")]
        public struct Vftbl
        {
            public delegate int _get_Buffer_0(IntPtr thisPtr, out IntPtr buffer);

            internal global::WinRT.Interop.IUnknownVftbl IUnknownVftbl;
            public _get_Buffer_0 get_Buffer_0;

            static unsafe Vftbl()
            {
                AbiToProjectionVftable = new Vftbl
                {
                    IUnknownVftbl = global::WinRT.Interop.IUnknownVftbl.AbiToProjectionVftbl,
                    get_Buffer_0 = Do_Abi_get_Buffer_0
                };
                var nativeVftbl = (IntPtr*)Marshal.AllocCoTaskMem(Marshal.SizeOf<IUnknownVftbl>() + sizeof(IntPtr) * 12);
                Marshal.StructureToPtr(AbiToProjectionVftable.IUnknownVftbl, (IntPtr)nativeVftbl, false);
                nativeVftbl[3] = Marshal.GetFunctionPointerForDelegate(AbiToProjectionVftable.get_Buffer_0);
                AbiToProjectionVftablePtr = (IntPtr)nativeVftbl;
            }

            public static readonly Vftbl AbiToProjectionVftable;
            public static readonly IntPtr AbiToProjectionVftablePtr;

            internal unsafe Vftbl(IntPtr thisPtr)
            {
                var vftblPtr = Marshal.PtrToStructure<VftblPtr>(thisPtr);
                var vftbl = (IntPtr*)vftblPtr.Vftbl;
                IUnknownVftbl = Marshal.PtrToStructure<IUnknownVftbl>(vftblPtr.Vftbl);
                get_Buffer_0 = Marshal.GetDelegateForFunctionPointer<_get_Buffer_0>(vftbl[3]);
            }

            private static int Do_Abi_get_Buffer_0(IntPtr thisPtr, out IntPtr buffer)
            {
                buffer = default;
                try
                {
                    buffer = ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IBufferByteAccess>(thisPtr).Buffer;
                }
                catch (Exception ex)
                {
                    return Marshal.GetHRForException(ex);
                }
                return 0;
            }
        }
        internal static ObjectReference<Vftbl> FromAbi(IntPtr thisPtr) => ObjectReference<Vftbl>.FromAbi(thisPtr);

        IntPtr global::Windows.Storage.Streams.IBufferByteAccess.Buffer
        {
            get
            {
                var _obj = ((ObjectReference<Vftbl>)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IBufferByteAccess).TypeHandle));
                var ThisPtr = _obj.ThisPtr;
                Marshal.ThrowExceptionForHR(_obj.Vftbl.get_Buffer_0(ThisPtr, out IntPtr buffer));
                return buffer;
            }
        }
    }
#endif
}

namespace Com
{
    using global::System;

    internal enum MSHCTX : int { Local = 0, NoSharedMem = 1, DifferentMachine = 2, InProc = 3, CrossCtx = 4 }
    internal enum MSHLFLAGS : int { Normal = 0, TableStrong = 1, TableWeak = 2, NoPing = 4 }

    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")]
    [Guid("00000003-0000-0000-c000-000000000046")]
    internal interface IMarshal
    {
        void GetUnmarshalClass(ref Guid riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlFlags, out Guid pCid);

        void GetMarshalSizeMax(ref Guid riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags, out uint pSize);

        void MarshalInterface(IntPtr pStm, ref Guid riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags);

        void UnmarshalInterface(IntPtr pStm, ref Guid riid, out IntPtr ppv);

        void ReleaseMarshalData(IntPtr pStm);

        void DisconnectObject(uint dwReserved);
    }
}

namespace ABI.Com
{
    using global::System;
    using global::System.Runtime.InteropServices;

    [Guid("00000003-0000-0000-c000-000000000046")]
    internal class IMarshal : global::Com.IMarshal
    {
        [Guid("00000003-0000-0000-c000-000000000046")]
        public struct Vftbl
        {
            public delegate int _GetUnmarshalClass_0(IntPtr thisPtr, ref Guid riid, IntPtr pv, global::Com.MSHCTX dwDestContext, IntPtr pvDestContext, global::Com.MSHLFLAGS mshlFlags, out Guid pCid);
            public delegate int _GetMarshalSizeMax_1(IntPtr thisPtr, ref Guid riid, IntPtr pv, global::Com.MSHCTX dwDestContext, IntPtr pvDestContext, global::Com.MSHLFLAGS mshlflags, out uint pSize);
            public delegate int _MarshalInterface_2(IntPtr thisPtr, IntPtr pStm, ref Guid riid, IntPtr pv, global::Com.MSHCTX dwDestContext, IntPtr pvDestContext, global::Com.MSHLFLAGS mshlflags);
            public delegate int _UnmarshalInterface_3(IntPtr thisPtr, IntPtr pStm, ref Guid riid, out IntPtr ppv);
            public delegate int _ReleaseMarshalData_4(IntPtr thisPtr, IntPtr pStm);
            public delegate int _DisconnectObject_5(IntPtr thisPtr, uint dwReserved);

            internal global::WinRT.Interop.IUnknownVftbl IUnknownVftbl;
            public _GetUnmarshalClass_0 GetUnmarshalClass_0;
            public _GetMarshalSizeMax_1 GetMarshalSizeMax_1;
            public _MarshalInterface_2 MarshalInterface_2;
            public _UnmarshalInterface_3 UnmarshalInterface_3;
            public _ReleaseMarshalData_4 ReleaseMarshalData_4;
            public _DisconnectObject_5 DisconnectObject_5;


            public static readonly Vftbl AbiToProjectionVftable;
            public static readonly IntPtr AbiToProjectionVftablePtr;

            static Vftbl()
            {
                AbiToProjectionVftable = new Vftbl
                {
                    IUnknownVftbl = global::WinRT.Interop.IUnknownVftbl.AbiToProjectionVftbl,
                    GetUnmarshalClass_0 = Do_Abi_GetUnmarshalClass_0,
                    GetMarshalSizeMax_1 = Do_Abi_GetMarshalSizeMax_1,
                    MarshalInterface_2 = Do_Abi_MarshalInterface_2,
                    UnmarshalInterface_3 = Do_Abi_UnmarshalInterface_3,
                    ReleaseMarshalData_4 = Do_Abi_ReleaseMarshalData_4,
                    DisconnectObject_5 = Do_Abi_DisconnectObject_5
                };
                AbiToProjectionVftablePtr = Marshal.AllocHGlobal(Marshal.SizeOf<Vftbl>());
                Marshal.StructureToPtr(AbiToProjectionVftable, AbiToProjectionVftablePtr, false);
            }

            public Vftbl(IntPtr ptr)
            {
                this = Marshal.PtrToStructure<Vftbl>(ptr);
            }

            private static int Do_Abi_GetUnmarshalClass_0(IntPtr thisPtr, ref Guid riid, IntPtr pv, global::Com.MSHCTX dwDestContext, IntPtr pvDestContext, global::Com.MSHLFLAGS mshlFlags, out Guid pCid)
            {
                pCid = default;
                try
                {
                    ComWrappersSupport.FindObject<global::Com.IMarshal>(thisPtr).GetUnmarshalClass(ref riid, pv, dwDestContext, pvDestContext, mshlFlags, out pCid);
                }
                catch (Exception ex)
                {
                    return Marshal.GetHRForException(ex);
                }
                return 0;
            }

            private static int Do_Abi_GetMarshalSizeMax_1(IntPtr thisPtr, ref Guid riid, IntPtr pv, global::Com.MSHCTX dwDestContext, IntPtr pvDestContext, global::Com.MSHLFLAGS mshlflags, out uint pSize)
            {
                pSize = default;
                try
                {
                    ComWrappersSupport.FindObject<global::Com.IMarshal>(thisPtr).GetMarshalSizeMax(ref riid, pv, dwDestContext, pvDestContext, mshlflags, out pSize);
                }
                catch (Exception ex)
                {
                    return Marshal.GetHRForException(ex);
                }
                return 0;
            }

            private static int Do_Abi_MarshalInterface_2(IntPtr thisPtr, IntPtr pStm, ref Guid riid, IntPtr pv, global::Com.MSHCTX dwDestContext, IntPtr pvDestContext, global::Com.MSHLFLAGS mshlflags)
            {
                try
                {
                    ComWrappersSupport.FindObject<global::Com.IMarshal>(thisPtr).MarshalInterface(pStm, ref riid, pv, dwDestContext, pvDestContext, mshlflags);
                }
                catch (Exception ex)
                {
                    return Marshal.GetHRForException(ex);
                }
                return 0;
            }

            private static int Do_Abi_UnmarshalInterface_3(IntPtr thisPtr, IntPtr pStm, ref Guid riid, out IntPtr ppv)
            {
                ppv = default;
                try
                {
                    ComWrappersSupport.FindObject<global::Com.IMarshal>(thisPtr).UnmarshalInterface(pStm, ref riid, out ppv);
                }
                catch (Exception ex)
                {
                    return Marshal.GetHRForException(ex);
                }
                return 0;
            }

            private static int Do_Abi_ReleaseMarshalData_4(IntPtr thisPtr, IntPtr pStm)
            {
                try
                {
                    ComWrappersSupport.FindObject<global::Com.IMarshal>(thisPtr).ReleaseMarshalData(pStm);
                }
                catch (Exception ex)
                {
                    return Marshal.GetHRForException(ex);
                }
                return 0;
            }

            private static int Do_Abi_DisconnectObject_5(IntPtr thisPtr, uint dwReserved)
            {
                try
                {
                    ComWrappersSupport.FindObject<global::Com.IMarshal>(thisPtr).DisconnectObject(dwReserved);
                }
                catch (Exception ex)
                {
                    return Marshal.GetHRForException(ex);
                }
                return 0;
            }
        }
        internal static ObjectReference<Vftbl> FromAbi(IntPtr thisPtr) => ObjectReference<Vftbl>.FromAbi(thisPtr);

        public static implicit operator IMarshal(IObjectReference obj) => (obj != null) ? new IMarshal(obj) : null;
        protected readonly ObjectReference<Vftbl> _obj;
        public IObjectReference ObjRef { get => _obj; }
        public IntPtr ThisPtr => _obj.ThisPtr;
        public ObjectReference<I> AsInterface<I>() => _obj.As<I>();
        public A As<A>() => _obj.AsType<A>();
        public IMarshal(IObjectReference obj) : this(obj.As<Vftbl>()) { }
        internal IMarshal(ObjectReference<Vftbl> obj)
        {
            _obj = obj;
        }

        public void GetUnmarshalClass(ref Guid riid, IntPtr pv, global::Com.MSHCTX dwDestContext, IntPtr pvDestContext, global::Com.MSHLFLAGS mshlFlags, out Guid pCid)
        {
            Marshal.ThrowExceptionForHR(_obj.Vftbl.GetUnmarshalClass_0(ThisPtr, ref riid, pv, dwDestContext, pvDestContext, mshlFlags, out pCid));
        }

        public void GetMarshalSizeMax(ref Guid riid, IntPtr pv, global::Com.MSHCTX dwDestContext, IntPtr pvDestContext, global::Com.MSHLFLAGS mshlflags, out uint pSize)
        {
            Marshal.ThrowExceptionForHR(_obj.Vftbl.GetMarshalSizeMax_1(ThisPtr, ref riid, pv, dwDestContext, pvDestContext, mshlflags, out pSize));
        }

        public void MarshalInterface(IntPtr pStm, ref Guid riid, IntPtr pv, global::Com.MSHCTX dwDestContext, IntPtr pvDestContext, global::Com.MSHLFLAGS mshlflags)
        {
            Marshal.ThrowExceptionForHR(_obj.Vftbl.MarshalInterface_2(ThisPtr, pStm, ref riid, pv, dwDestContext, pvDestContext, mshlflags));
        }

        public void UnmarshalInterface(IntPtr pStm, ref Guid riid, out IntPtr ppv)
        {
            Marshal.ThrowExceptionForHR(_obj.Vftbl.UnmarshalInterface_3(ThisPtr, pStm, ref riid, out ppv));
        }

        public void ReleaseMarshalData(IntPtr pStm)
        {
            Marshal.ThrowExceptionForHR(_obj.Vftbl.ReleaseMarshalData_4(ThisPtr, pStm));
        }

        public void DisconnectObject(uint dwReserved)
        {
            Marshal.ThrowExceptionForHR(_obj.Vftbl.DisconnectObject_5(ThisPtr, dwReserved));
        }
    }
}

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace System.IO
{
    using System.Diagnostics;
    using System.IO;
    
    using System.Runtime.InteropServices;
    using System.Threading.Tasks;
    using System.Threading;
    using global::Windows.Foundation;
    using global::Windows.Storage.Streams;
    using System.Diagnostics.CodeAnalysis;
    /// <summary>
    /// An <code>wrapper</code> for a managed stream that implements all WinRT stream operations.
    /// This class must not implement any WinRT stream interfaces directly.
    /// We never create instances of this class directly; instead we use classes defined in
    /// the region Interface adapters to implement WinRT ifaces and create instances of those types.
    /// See comment in that region for technical details.
    /// </summary>
    internal abstract class NetFxToWinRtStreamAdapter : IDisposable
    {
        private const int E_ILLEGAL_METHOD_CALL = unchecked((int)0x8000000E);
        private const int RO_E_CLOSED = unchecked((int)0x80000013);
        private const int E_NOTIMPL = unchecked((int)0x80004001);
        private const int E_INVALIDARG = unchecked((int)0x80070057);
        #region Construction

        #region Interface adapters

        // Instances of private types defined in this section will be returned from NetFxToWinRtStreamAdapter.Create(..).
        // Depending on the capabilities of the .NET stream for which we need to construct the adapter, we need to return
        // an object that can be QIed (COM speak for "cast") to a well-defined set of ifaces.
        // E.g, if the specified stream CanRead, but not CanSeek and not CanWrite, then we *must* return an object that
        // can be QIed to IInputStream, but *not* IRandomAccessStream and *not* IOutputStream.
        // There are two ways to do that:
        //   - We could explicitly implement ICustomQueryInterface and respond to QI requests by analyzing the stream capabilities
        //   - We can use the runtime's ability to do that for us, based on the ifaces the concrete class implements (or does not).
        // The latter is much more elegant, and likely also faster.


        private class InputStream : NetFxToWinRtStreamAdapter, IInputStream, IDisposable
        {
            internal InputStream(Stream stream, StreamReadOperationOptimization readOptimization)
                : base(stream, readOptimization)
            {
            }
        }


        private class OutputStream : NetFxToWinRtStreamAdapter, IOutputStream, IDisposable
        {
            internal OutputStream(Stream stream, StreamReadOperationOptimization readOptimization)
                : base(stream, readOptimization)
            {
            }
        }


        private class RandomAccessStream : NetFxToWinRtStreamAdapter, IRandomAccessStream, IInputStream, IOutputStream, IDisposable
        {
            internal RandomAccessStream(Stream stream, StreamReadOperationOptimization readOptimization)
                : base(stream, readOptimization)
            {
            }
        }


        private class InputOutputStream : NetFxToWinRtStreamAdapter, IInputStream, IOutputStream, IDisposable
        {
            internal InputOutputStream(Stream stream, StreamReadOperationOptimization readOptimization)
                : base(stream, readOptimization)
            {
            }
        }

        #endregion Interface adapters

        // We may want to define different behaviour for different types of streams.
        // For instance, ReadAsync treats MemoryStream special for performance reasons.
        // The enum 'StreamReadOperationOptimization' describes the read optimization to employ for a
        // given NetFxToWinRtStreamAdapter instance. In future, we might define other enums to follow a
        // similar pattern, e.g. 'StreamWriteOperationOptimization' or 'StreamFlushOperationOptimization'.
        private enum StreamReadOperationOptimization
        {
            AbstractStream = 0, MemoryStream
        }


        internal static NetFxToWinRtStreamAdapter Create(Stream stream)
        {
            if (stream == null)
                throw new ArgumentNullException(nameof(stream));

            StreamReadOperationOptimization readOptimization = StreamReadOperationOptimization.AbstractStream;
            if (stream.CanRead)
                readOptimization = DetermineStreamReadOptimization(stream);

            NetFxToWinRtStreamAdapter adapter;

            if (stream.CanSeek)
                adapter = new RandomAccessStream(stream, readOptimization);

            else if (stream.CanRead && stream.CanWrite)
                adapter = new InputOutputStream(stream, readOptimization);

            else if (stream.CanRead)
                adapter = new InputStream(stream, readOptimization);

            else if (stream.CanWrite)
                adapter = new OutputStream(stream, readOptimization);

            else
                throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_NotSufficientCapabilitiesToConvertToWinRtStream);

            return adapter;
        }


        private static StreamReadOperationOptimization DetermineStreamReadOptimization(Stream stream)
        {
            Debug.Assert(stream != null);

            if (CanApplyReadMemoryStreamOptimization(stream))
                return StreamReadOperationOptimization.MemoryStream;

            return StreamReadOperationOptimization.AbstractStream;
        }


        private static bool CanApplyReadMemoryStreamOptimization(Stream stream)
        {
            MemoryStream memStream = stream as MemoryStream;
            if (memStream == null)
                return false;

            ArraySegment<byte> arrSeg;
            return memStream.TryGetBuffer(out arrSeg);
        }


        private NetFxToWinRtStreamAdapter(Stream stream, StreamReadOperationOptimization readOptimization)
        {
            Debug.Assert(stream != null);
            Debug.Assert(stream.CanRead || stream.CanWrite || stream.CanSeek);
            Debug.Assert(!stream.CanRead || (stream.CanRead && this is IInputStream));
            Debug.Assert(!stream.CanWrite || (stream.CanWrite && this is IOutputStream));
            Debug.Assert(!stream.CanSeek || (stream.CanSeek && this is IRandomAccessStream));

            _readOptimization = readOptimization;
            _managedStream = stream;
        }

        #endregion Construction


        #region Instance variables

        private Stream _managedStream = null;
        private bool _leaveUnderlyingStreamOpen = true;
        private readonly StreamReadOperationOptimization _readOptimization;

        #endregion Instance variables


        #region Tools and Helpers

        /// <summary>
        /// We keep tables for mappings between managed and WinRT streams to make sure to always return the same adapter for a given underlying stream.
        /// However, in order to avoid global locks on those tables, several instances of this type may be created and then can race to be entered
        /// into the appropriate map table. All except for the winning instances will be thrown away. However, we must ensure that when the losers are
        /// finalized, they do not dispose the underlying stream. To ensure that, we must call this method on the winner to notify it that it is safe to
        /// dispose the underlying stream.
        /// </summary>
        internal void SetWonInitializationRace()
        {
            _leaveUnderlyingStreamOpen = false;
        }


        public Stream GetManagedStream()
        {
            return _managedStream;
        }


        private Stream EnsureNotDisposed()
        {
            Stream str = _managedStream;

            if (str == null)
            {
                ObjectDisposedException ex = new ObjectDisposedException(global::Windows.Storage.Streams.SR.ObjectDisposed_CannotPerformOperation);
                ex.SetHResult(RO_E_CLOSED);
                throw ex;
            }

            return str;
        }

        #endregion Tools and Helpers


        #region Common public interface

        /// <summary>Implements IDisposable.Dispose (IClosable.Close in WinRT)</summary>
        void IDisposable.Dispose()
        {
            Stream str = _managedStream;
            if (str == null)
                return;

            _managedStream = null;

            if (!_leaveUnderlyingStreamOpen)
                str.Dispose();
        }

        #endregion Common public interface


        #region IInputStream public interface

#if !NETSTANDARD2_0
        [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
        public IAsyncOperationWithProgress<IBuffer, uint> ReadAsync(IBuffer buffer, uint count, InputStreamOptions options)
        {
            if (buffer == null)
            {
                // Mapped to E_POINTER.
                throw new ArgumentNullException(nameof(buffer));
            }

            if (count < 0 || int.MaxValue < count)
            {
                ArgumentOutOfRangeException ex = new ArgumentOutOfRangeException(nameof(count));
                ex.SetHResult(E_INVALIDARG);
                throw ex;
            }

            if (buffer.Capacity < count)
            {
                ArgumentException ex = new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientBufferCapacity);
                ex.SetHResult(E_INVALIDARG);
                throw ex;
            }

            if (!(options == InputStreamOptions.None || options == InputStreamOptions.Partial || options == InputStreamOptions.ReadAhead))
            {
                ArgumentOutOfRangeException ex = new ArgumentOutOfRangeException(nameof(options),
                                                                                 global::Windows.Storage.Streams.SR.ArgumentOutOfRange_InvalidInputStreamOptionsEnumValue);
                ex.SetHResult(E_INVALIDARG);
                throw ex;
            }

            Stream str = EnsureNotDisposed();

            IAsyncOperationWithProgress<IBuffer, uint> readAsyncOperation;
            switch (_readOptimization)
            {
                case StreamReadOperationOptimization.MemoryStream:
                    readAsyncOperation = StreamOperationsImplementation.ReadAsync_MemoryStream(str, buffer, count);
                    break;

                case StreamReadOperationOptimization.AbstractStream:
                    readAsyncOperation = StreamOperationsImplementation.ReadAsync_AbstractStream(str, buffer, count, options);
                    break;

                // Use this pattern to add more optimisation options if necessary:
                //case StreamReadOperationOptimization.XxxxStream:
                //    readAsyncOperation = StreamOperationsImplementation.ReadAsync_XxxxStream(str, buffer, count, options);
                //    break;

                default:
                    Debug.Fail("We should never get here. Someone forgot to handle an input stream optimisation option.");
                    readAsyncOperation = null;
                    break;
            }

            return readAsyncOperation;
        }

        #endregion IInputStream public interface


        #region IOutputStream public interface

#if !NETSTANDARD2_0
        [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
        public IAsyncOperationWithProgress<uint, uint> WriteAsync(IBuffer buffer)
        {
            if (buffer == null)
            {
                // Mapped to E_POINTER.
                throw new ArgumentNullException(nameof(buffer));
            }

            if (buffer.Capacity < buffer.Length)
            {
                ArgumentException ex = new ArgumentException(global::Windows.Storage.Streams.SR.Argument_BufferLengthExceedsCapacity);
                ex.SetHResult(E_INVALIDARG);
                throw ex;
            }

            Stream str = EnsureNotDisposed();
            return StreamOperationsImplementation.WriteAsync_AbstractStream(str, buffer);
        }

#if !NETSTANDARD2_0
        [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
        public IAsyncOperation<bool> FlushAsync()
        {
            Stream str = EnsureNotDisposed();
            return StreamOperationsImplementation.FlushAsync_AbstractStream(str);
        }

        #endregion IOutputStream public interface


        #region IRandomAccessStream public interface


        #region IRandomAccessStream public interface: Not cloning related

        public void Seek(ulong position)
        {
            if (position > long.MaxValue)
            {
                ArgumentException ex = new ArgumentException(global::Windows.Storage.Streams.SR.IO_CannotSeekBeyondInt64MaxValue);
                ex.SetHResult(E_INVALIDARG);
                throw ex;
            }

            Stream str = EnsureNotDisposed();
            long pos = unchecked((long)position);

            Debug.Assert(str != null);
            Debug.Assert(str.CanSeek, "The underlying str is expected to support Seek, but it does not.");
            Debug.Assert(0 <= pos, "Unexpected pos=" + pos + ".");

            str.Seek(pos, SeekOrigin.Begin);
        }


        public bool CanRead
        {
            get
            {
                Stream str = EnsureNotDisposed();
                return str.CanRead;
            }
        }


        public bool CanWrite
        {
            get
            {
                Stream str = EnsureNotDisposed();
                return str.CanWrite;
            }
        }


        public ulong Position
        {
            get
            {
                Stream str = EnsureNotDisposed();
                return (ulong)str.Position;
            }
        }


        public ulong Size
        {
            get
            {
                Stream str = EnsureNotDisposed();
                return (ulong)str.Length;
            }

            set
            {
                if (value > long.MaxValue)
                {
                    ArgumentException ex = new ArgumentException(global::Windows.Storage.Streams.SR.IO_CannotSetSizeBeyondInt64MaxValue);
                    ex.SetHResult(E_INVALIDARG);
                    throw ex;
                }

                Stream str = EnsureNotDisposed();

                if (!str.CanWrite)
                {
                    InvalidOperationException ex = new InvalidOperationException(global::Windows.Storage.Streams.SR.InvalidOperation_CannotSetStreamSizeCannotWrite);
                    ex.SetHResult(E_ILLEGAL_METHOD_CALL);
                    throw ex;
                }

                long val = unchecked((long)value);

                Debug.Assert(str != null);
                Debug.Assert(str.CanSeek, "The underlying str is expected to support Seek, but it does not.");
                Debug.Assert(0 <= val, "Unexpected val=" + val + ".");

                str.SetLength(val);
            }
        }

        #endregion IRandomAccessStream public interface: Not cloning related


        #region IRandomAccessStream public interface: Cloning related

        // We do not want to support the cloning-related operation for now.
        // They appear to mainly target corner-case scenarios in Windows itself,
        // and are (mainly) a historical artefact of abandoned early designs
        // for IRandonAccessStream.
        // Cloning can be added in future, however, it would be quite complex
        // to support it correctly for generic streams.
        private static void ThrowCloningNotSupported(string methodName)
        {
            NotSupportedException nse = new NotSupportedException(string.Format(global::Windows.Storage.Streams.SR.NotSupported_CloningNotSupported, methodName));
            nse.SetHResult(E_NOTIMPL);
            throw nse;
        }


        public IRandomAccessStream CloneStream()
        {
            ThrowCloningNotSupported("CloneStream");
            return null;
        }


        public IInputStream GetInputStreamAt(ulong position)
        {
            ThrowCloningNotSupported("GetInputStreamAt");
            return null;
        }


        public IOutputStream GetOutputStreamAt(ulong position)
        {
            ThrowCloningNotSupported("GetOutputStreamAt");
            return null;
        }
        #endregion IRandomAccessStream public interface: Cloning related

        #endregion IRandomAccessStream public interface

    }  // class NetFxToWinRtStreamAdapter
}  // namespace

// NetFxToWinRtStreamAdapter.cs

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace System.IO
{
    using System.Diagnostics;
    using System.Runtime.ExceptionServices;
    
    using System.Runtime.InteropServices;
    using System.Threading.Tasks;
    using System.Threading;
    using global::Windows.Foundation;
    using global::Windows.Storage.Streams;
    using System.Diagnostics.CodeAnalysis;
    #region class StreamOperationAsyncResult

    internal abstract partial class StreamOperationAsyncResult : IAsyncResult
    {
        private readonly AsyncCallback _userCompletionCallback = null;
        private readonly object _userAsyncStateInfo = null;

        private IAsyncInfo _asyncStreamOperation = null;

        private volatile bool _completed = false;
        private volatile bool _callbackInvoked = false;
        private volatile ManualResetEvent _waitHandle = null;

        private long _bytesCompleted = 0;

        private ExceptionDispatchInfo _errorInfo = null;

        private readonly bool _processCompletedOperationInCallback;
        private IAsyncInfo _completedOperation = null;


        protected internal StreamOperationAsyncResult(IAsyncInfo asyncStreamOperation,
                                                      AsyncCallback userCompletionCallback, object userAsyncStateInfo,
                                                      bool processCompletedOperationInCallback)
        {
            if (asyncStreamOperation == null)
                throw new ArgumentNullException(nameof(asyncStreamOperation));

            _userCompletionCallback = userCompletionCallback;
            _userAsyncStateInfo = userAsyncStateInfo;

            _asyncStreamOperation = asyncStreamOperation;

            _completed = false;
            _callbackInvoked = false;

            _bytesCompleted = 0;

            _errorInfo = null;

            _processCompletedOperationInCallback = processCompletedOperationInCallback;
        }


        public object AsyncState
        {
            get { return _userAsyncStateInfo; }
        }


        internal bool ProcessCompletedOperationInCallback
        {
            get { return _processCompletedOperationInCallback; }
        }


        public WaitHandle AsyncWaitHandle
        {
            get
            {
                ManualResetEvent wh = _waitHandle;
                if (wh != null)
                    return wh;

                // What if someone calls this public property and decides to wait on it?
                // > Use 'completed' in the ctor - this way the handle wait will return as appropriate.
                wh = new ManualResetEvent(_completed);

                ManualResetEvent otherHandle = Interlocked.CompareExchange(ref _waitHandle, wh, null);

                // We lost the race. Dispose OUR handle and return OTHER handle:
                if (otherHandle != null)
                {
                    wh.Dispose();
                    return otherHandle;
                }

                // We won the race. Return OUR new handle:
                return wh;
            }
        }

        public bool CompletedSynchronously
        {
            get { return false; }
        }


        public bool IsCompleted
        {
            get { return _completed; }
        }


        internal void Wait()
        {
            if (_completed)
                return;

            WaitHandle wh = AsyncWaitHandle;

            while (_completed == false)
                wh.WaitOne();
        }


        internal long BytesCompleted
        {
            get { return _bytesCompleted; }
        }


        internal bool HasError
        {
            get { return _errorInfo != null; }
        }


        internal void ThrowCachedError()
        {
            if (_errorInfo == null)
                return;

            _errorInfo.Throw();
        }


        internal bool CancelStreamOperation()
        {
            if (_callbackInvoked)
                return false;

            if (_asyncStreamOperation != null)
            {
                _asyncStreamOperation.Cancel();
                _asyncStreamOperation = null;
            }

            return true;
        }

        internal void CloseStreamOperation()
        {
            try
            {
                if (_asyncStreamOperation != null)
                    _asyncStreamOperation.Close();
            }
            catch { }
            _asyncStreamOperation = null;
        }


        ~StreamOperationAsyncResult()
        {
            // This finalisation is not critical, but we can still make an effort to notify the underlying WinRT stream
            // that we are not any longer interested in the results:
            CancelStreamOperation();
        }


        internal abstract void ProcessConcreteCompletedOperation(IAsyncInfo completedOperation, out long bytesCompleted);

         private static void ProcessCompletedOperation_InvalidOperationThrowHelper(ExceptionDispatchInfo errInfo, string errMsg)
        {
            Exception errInfosrc = (errInfo == null) ? null : errInfo.SourceException;

            if (errInfosrc == null)
                throw new InvalidOperationException(errMsg);
            else
                throw new InvalidOperationException(errMsg, errInfosrc);
        }


        internal void ProcessCompletedOperation()
        {
            // The error handling is slightly tricky here:
            // Before processing the IO results, we are verifying some basic assumptions and if they do not hold, we are
            // throwing InvalidOperation. However, by the time this method is called, we might have already stored something
            // into errorInfo, e.g. if an error occurred in StreamOperationCompletedCallback. If that is the case, then that
            // previous exception might include some important info relevant for detecting the problem. So, we take that
            // previous exception and attach it as the inner exception to the InvalidOperationException being thrown.
            // In cases where we have a good understanding of the previously saved errorInfo, and we know for sure that it
            // the immediate reason for the state validation to fail, we can avoid throwing InvalidOperation altogether
            // and only rethrow the errorInfo.

            if (!_callbackInvoked)
                ProcessCompletedOperation_InvalidOperationThrowHelper(_errorInfo, global::Windows.Storage.Streams.SR.InvalidOperation_CannotCallThisMethodInCurrentState);

            if (!_processCompletedOperationInCallback && !_completed)
                ProcessCompletedOperation_InvalidOperationThrowHelper(_errorInfo, global::Windows.Storage.Streams.SR.InvalidOperation_CannotCallThisMethodInCurrentState);

            if (_completedOperation == null)
            {
                ExceptionDispatchInfo errInfo = _errorInfo;
                Exception errInfosrc = (errInfo == null) ? null : errInfo.SourceException;

                // See if errorInfo is set because we observed completedOperation == null previously (being slow is Ok on error path):
                if (errInfosrc != null && errInfosrc is NullReferenceException
                        && global::Windows.Storage.Streams.SR.NullReference_IOCompletionCallbackCannotProcessNullAsyncInfo.Equals(errInfosrc.Message))
                {
                    errInfo!.Throw();
                }
                else
                {
                    throw new InvalidOperationException(global::Windows.Storage.Streams.SR.InvalidOperation_CannotCallThisMethodInCurrentState);
                }
            }

            if (_completedOperation.Id != _asyncStreamOperation!.Id)
                ProcessCompletedOperation_InvalidOperationThrowHelper(_errorInfo, global::Windows.Storage.Streams.SR.InvalidOperation_UnexpectedAsyncOperationID);

            if (_completedOperation.Status == AsyncStatus.Error)
            {
                _bytesCompleted = 0;
                ThrowWithIOExceptionDispatchInfo(_completedOperation.ErrorCode);
            }

            ProcessConcreteCompletedOperation(_completedOperation, out _bytesCompleted);
        }


        internal void StreamOperationCompletedCallback(IAsyncInfo completedOperation, AsyncStatus unusedCompletionStatus)
        {
            try
            {
                if (_callbackInvoked)
                    throw new InvalidOperationException(global::Windows.Storage.Streams.SR.InvalidOperation_MultipleIOCompletionCallbackInvocation);

                _callbackInvoked = true;

                // This happens in rare stress cases in Console mode and the WinRT folks said they are unlikely to fix this in Dev11.
                // Moreover, this can happen if the underlying WinRT stream has a faulty user implementation.
                // If we did not do this check, we would either get the same exception without the explaining message when dereferencing
                // completedOperation later, or we will get an InvalidOperation when processing the Op. With the check, they will be
                // aggregated and the user will know what went wrong.
                if (completedOperation == null)
                    throw new NullReferenceException(global::Windows.Storage.Streams.SR.NullReference_IOCompletionCallbackCannotProcessNullAsyncInfo);

                _completedOperation = completedOperation;

                // processCompletedOperationInCallback == false indicates that the stream is doing a blocking wait on the waitHandle of this IAsyncResult.
                // In that case calls on completedOperation may deadlock if completedOperation is not free threaded.
                // By setting processCompletedOperationInCallback to false the stream that created this IAsyncResult indicated that it
                // will call ProcessCompletedOperation after the waitHandle is signalled to fetch the results.

                if (_processCompletedOperationInCallback)
                    ProcessCompletedOperation();
            }
            catch (Exception ex)
            {
                _bytesCompleted = 0;
                _errorInfo = ExceptionDispatchInfo.Capture(ex);
            }
            finally
            {
                _completed = true;
                Interlocked.MemoryBarrier();
                // From this point on, AsyncWaitHandle would create a handle that is readily set,
                // so we do not need to check if it is being produced asynchronously.
                if (_waitHandle != null)
                    _waitHandle.Set();
            }

            if (_userCompletionCallback != null)
                _userCompletionCallback(this);
        }

        private void ThrowWithIOExceptionDispatchInfo(Exception e)
        {
            WinRtIOHelper.NativeExceptionToIOExceptionInfo(WinRT.ExceptionHelpers.AttachRestrictedErrorInfo(_completedOperation.ErrorCode)).Throw();
        }
    }  // class StreamOperationAsyncResult

    #endregion class StreamOperationAsyncResult


    #region class StreamReadAsyncResult

    internal class StreamReadAsyncResult : StreamOperationAsyncResult
    {
        private readonly IBuffer _userBuffer;

        internal StreamReadAsyncResult(IAsyncOperationWithProgress<IBuffer, uint> asyncStreamReadOperation, IBuffer buffer,
                                       AsyncCallback userCompletionCallback, object userAsyncStateInfo,
                                       bool processCompletedOperationInCallback)

            : base(asyncStreamReadOperation, userCompletionCallback, userAsyncStateInfo, processCompletedOperationInCallback)
        {
            if (buffer == null)
                throw new ArgumentNullException(nameof(buffer));

            _userBuffer = buffer;
            asyncStreamReadOperation.Completed = this.StreamOperationCompletedCallback;
        }


        internal override void ProcessConcreteCompletedOperation(IAsyncInfo completedOperation, out long bytesCompleted)
        {
            ProcessConcreteCompletedOperation((IAsyncOperationWithProgress<IBuffer, uint>)completedOperation, out bytesCompleted);
        }


        private void ProcessConcreteCompletedOperation(IAsyncOperationWithProgress<IBuffer, uint> completedOperation, out long bytesCompleted)
        {
            IBuffer resultBuffer = completedOperation.GetResults();
            Debug.Assert(resultBuffer != null);

            WinRtIOHelper.EnsureResultsInUserBuffer(_userBuffer!, resultBuffer);
            bytesCompleted = _userBuffer!.Length;
        }
    }  // class StreamReadAsyncResult

    #endregion class StreamReadAsyncResult


    #region class StreamWriteAsyncResult

    internal class StreamWriteAsyncResult : StreamOperationAsyncResult
    {
        internal StreamWriteAsyncResult(IAsyncOperationWithProgress<uint, uint> asyncStreamWriteOperation,
                                        AsyncCallback userCompletionCallback, object userAsyncStateInfo,
                                        bool processCompletedOperationInCallback)

            : base(asyncStreamWriteOperation, userCompletionCallback, userAsyncStateInfo, processCompletedOperationInCallback)
        {
            asyncStreamWriteOperation.Completed = this.StreamOperationCompletedCallback;
        }


        internal override void ProcessConcreteCompletedOperation(IAsyncInfo completedOperation, out long bytesCompleted)
        {
            ProcessConcreteCompletedOperation((IAsyncOperationWithProgress<uint, uint>)completedOperation, out bytesCompleted);
        }


        private void ProcessConcreteCompletedOperation(IAsyncOperationWithProgress<uint, uint> completedOperation, out long bytesCompleted)
        {
            uint bytesWritten = completedOperation.GetResults();
            bytesCompleted = bytesWritten;
        }
    }  // class StreamWriteAsyncResult

    #endregion class StreamWriteAsyncResult


    #region class StreamFlushAsyncResult

    internal class StreamFlushAsyncResult : StreamOperationAsyncResult
    {
        internal StreamFlushAsyncResult(IAsyncOperation<bool> asyncStreamFlushOperation, bool processCompletedOperationInCallback)

            : base(asyncStreamFlushOperation, null, null, processCompletedOperationInCallback)
        {
            asyncStreamFlushOperation.Completed = this.StreamOperationCompletedCallback;
        }


        internal override void ProcessConcreteCompletedOperation(IAsyncInfo completedOperation, out long bytesCompleted)
        {
            ProcessConcreteCompletedOperation((IAsyncOperation<bool>)completedOperation, out bytesCompleted);
        }


        private void ProcessConcreteCompletedOperation(IAsyncOperation<bool> completedOperation, out long bytesCompleted)
        {
            bool success = completedOperation.GetResults();
            bytesCompleted = (success ? 0 : -1);
        }
    }  // class StreamFlushAsyncResult
    #endregion class StreamFlushAsyncResult
}  // namespace

// StreamOperationAsyncResult.cs

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace Windows.Storage.Streams
{
    using global::System.Diagnostics;
    using global::System.IO;
    
    using global::System.Runtime.InteropServices;
    using global::System.Threading.Tasks;
    using global::System.Threading;
    using global::System.Runtime.InteropServices.WindowsRuntime;
    using Windows.Foundation;

    /// <summary>Depending on the concrete type of the stream managed by a <c>NetFxToWinRtStreamAdapter</c>,
    /// we want the <c>ReadAsync</c> / <c>WriteAsync</c> / <c>FlushAsync</c> / etc. operation to be implemented
    /// differently. This is for best performance as we can take advantage of the specifics of particular stream
    /// types. For instance, <c>ReadAsync</c> currently has a special implementation for memory streams.
    /// Moreover, knowledge about the actual runtime type of the <c>IBuffer</c> can also help choosing the optimal
    /// implementation. This type provides static methods that encapsulate the performance logic and can be used
    /// by <c>NetFxToWinRtStreamAdapter</c>.</summary>
#if !NETSTANDARD2_0
    [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
    internal static class StreamOperationsImplementation
    {
        #region ReadAsync implementations

        internal static IAsyncOperationWithProgress<IBuffer, uint> ReadAsync_MemoryStream(Stream stream, IBuffer buffer, uint count)
        {
            Debug.Assert(stream != null);
            Debug.Assert(stream is MemoryStream);
            Debug.Assert(stream.CanRead);
            Debug.Assert(stream.CanSeek);
            Debug.Assert(buffer != null);
            Debug.Assert(0 <= count);
            Debug.Assert(count <= int.MaxValue);
            Debug.Assert(count <= buffer.Capacity);

            // We will return a different buffer to the user backed directly by the memory stream (avoids memory copy).
            // This is permitted by the WinRT stream contract.
            // The user specified buffer will not have any data put into it:
            buffer.Length = 0;

            MemoryStream memStream = stream as MemoryStream;
            Debug.Assert(memStream != null);

            try
            {
                IBuffer dataBuffer = memStream.GetWindowsRuntimeBuffer((int)memStream.Position, (int)count);
                if (dataBuffer.Length > 0)
                    memStream.Seek(dataBuffer.Length, SeekOrigin.Current);

                return AsyncInfo.CreateCompletedOperation<IBuffer, uint>(dataBuffer);
            }
            catch (Exception ex)
            {
                return AsyncInfo.CreateFaultedOperation<IBuffer, uint>(ex);
            }
        }  // ReadAsync_MemoryStream


        internal static IAsyncOperationWithProgress<IBuffer, uint> ReadAsync_AbstractStream(Stream stream, IBuffer buffer, uint count,
                                                                                              InputStreamOptions options)
        {
            Debug.Assert(stream != null);
            Debug.Assert(stream.CanRead);
            Debug.Assert(buffer != null);
            Debug.Assert(0 <= count);
            Debug.Assert(count <= int.MaxValue);
            Debug.Assert(count <= buffer.Capacity);
            Debug.Assert(options == InputStreamOptions.None || options == InputStreamOptions.Partial || options == InputStreamOptions.ReadAhead);

            int bytesrequested = (int)count;

            // Check if the buffer is our implementation.
            // IF YES: In that case, we can read directly into its data array.
            // IF NO:  The buffer is of unknown implementation. It's not backed by a managed array, but the wrapped stream can only
            //         read into a managed array. If we used the user-supplied buffer we would need to copy data into it after every read.
            //         The spec allows to return a buffer instance that is not the same as passed by the user. So, we will create an own
            //         buffer instance, read data *directly* into the array backing it and then return it to the user.
            //         Note: the allocation costs we are paying for the new buffer are unavoidable anyway, as we would need to create
            //         an array to read into either way.

            IBuffer dataBuffer = buffer as WindowsRuntimeBuffer;

            if (dataBuffer == null)
                dataBuffer = WindowsRuntimeBuffer.Create((int)Math.Min((uint)int.MaxValue, buffer.Capacity));

            // This operation delegate will we run inside of the returned IAsyncOperationWithProgress:
            Func<CancellationToken, IProgress<uint>, Task<IBuffer>> readOperation = async (cancelToken, progressListener) =>
            {
                // No bytes read yet:
                dataBuffer.Length = 0;

                // Get the buffer backing array:
                byte[] data;
                int offset;
                bool managedBufferAssert = dataBuffer.TryGetUnderlyingData(out data, out offset);
                Debug.Assert(managedBufferAssert);

                // Init tracking values:
                bool done = cancelToken.IsCancellationRequested;
                int bytesCompleted = 0;

                // Loop until EOS, cancelled or read enough data according to options:
                while (!done)
                {
                    int bytesread = 0;

                    try
                    {
                        // Read asynchronously:
                        bytesread = await stream.ReadAsync(data!, offset + bytesCompleted, bytesrequested - bytesCompleted, cancelToken)
                                                .ConfigureAwait(continueOnCapturedContext: false);

                        // We will continue here on a different thread when read async completed:
                        bytesCompleted += bytesread;
                        // We will handle a cancelation exception and re-throw all others:
                    }
                    catch (OperationCanceledException)
                    {
                        // We assume that cancelToken.IsCancellationRequested is has been set and simply proceed.
                        // (we check cancelToken.IsCancellationRequested later)
                        Debug.Assert(cancelToken.IsCancellationRequested);

                        // This is because if the cancellation came after we read some bytes we want to return the results we got instead
                        // of an empty cancelled task, so if we have not yet read anything at all, then we can throw cancellation:
                        if (bytesCompleted == 0 && bytesread == 0)
                            throw;
                    }

                    // Update target buffer:
                    dataBuffer.Length = (uint)bytesCompleted;

                    Debug.Assert(bytesCompleted <= bytesrequested);

                    // Check if we are done:
                    done = options == InputStreamOptions.Partial  // If no complete read was requested, any amount of data is OK
                            || bytesread == 0                         // this implies EndOfStream
                            || bytesCompleted == bytesrequested       // read all requested bytes
                            || cancelToken.IsCancellationRequested;   // operation was cancelled

                    // Call user Progress handler:
                    if (progressListener != null)
                        progressListener.Report(dataBuffer.Length);
                }  // while (!done)

                // If we got here, then no error was detected. Return the results buffer:
                return dataBuffer;
            };  // readOperation

            return AsyncInfo.Run<IBuffer, uint>(readOperation);
        }  // ReadAsync_AbstractStream

        #endregion ReadAsync implementations


        #region WriteAsync implementations

        internal static IAsyncOperationWithProgress<uint, uint> WriteAsync_AbstractStream(Stream stream, IBuffer buffer)
        {
            Debug.Assert(stream != null);
            Debug.Assert(stream.CanWrite);
            Debug.Assert(buffer != null);

            // Choose the optimal writing strategy for the kind of buffer supplied:
            Func<CancellationToken, IProgress<uint>, Task<uint>> writeOperation;
            byte[] data;
            int offset;

            // If buffer is backed by a managed array:
            if (buffer.TryGetUnderlyingData(out data, out offset))
            {
                writeOperation = async (cancelToken, progressListener) =>
                {
                    if (cancelToken.IsCancellationRequested)  // CancellationToken is non-nullable
                        return 0;

                    Debug.Assert(buffer.Length <= int.MaxValue);

                    int bytesToWrite = (int)buffer.Length;

                    await stream.WriteAsync(data, offset, bytesToWrite, cancelToken).ConfigureAwait(continueOnCapturedContext: false);

                    if (progressListener != null)
                        progressListener.Report((uint)bytesToWrite);

                    return (uint)bytesToWrite;
                };
                // Otherwise buffer is of an unknown implementation:
            }
            else
            {
                writeOperation = async (cancelToken, progressListener) =>
                {
                    if (cancelToken.IsCancellationRequested)  // CancellationToken is non-nullable
                        return 0;

                    uint bytesToWrite = buffer.Length;
                    Stream dataStream = buffer.AsStream();

                    int buffSize = 0x4000;
                    if (bytesToWrite < buffSize)
                        buffSize = (int)bytesToWrite;
                    
                    if (buffSize > 0)
                        await dataStream.CopyToAsync(stream, buffSize, cancelToken).ConfigureAwait(continueOnCapturedContext: false);

                    if (progressListener != null)
                        progressListener.Report((uint)bytesToWrite);

                    return (uint)bytesToWrite;
                };
            }  // if-else

            // Construct and run the async operation:
            return AsyncInfo.Run<uint, uint>(writeOperation);
        }  // WriteAsync_AbstractStream

        #endregion WriteAsync implementations


        #region FlushAsync implementations

        internal static IAsyncOperation<bool> FlushAsync_AbstractStream(Stream stream)
        {
            Debug.Assert(stream != null);
            Debug.Assert(stream.CanWrite);

            Func<CancellationToken, Task<bool>> flushOperation = async (cancelToken) =>
            {
                if (cancelToken.IsCancellationRequested)  // CancellationToken is non-nullable
                    return false;

                await stream.FlushAsync(cancelToken).ConfigureAwait(continueOnCapturedContext: false);
                return true;
            };

            // Construct and run the async operation:
            return AsyncInfo.Run<bool>(flushOperation);
        }
        #endregion FlushAsync implementations

    }  // class StreamOperationsImplementation
}  // namespace

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

namespace Windows.Storage.Streams
{
    class SR
    {
        public static string Argument_BufferIndexExceedsCapacity = "The specified buffer index is not within the buffer capacity.";

        public static string Argument_BufferLengthExceedsCapacity = "The specified useful data length exceeds the capacity of this buffer.";

        public static string Argument_IndexOutOfArrayBounds = "The specified index is out of bounds of the specified array.";

        public static string Argument_InstancesImplementingIRASThatCanReadMustImplementIIS = "The specified Windows Runtime stream supports the IRandomAccessStream interface and its CanRead property returns TRUE, however it does not implement the IInputStream interface. Windows Runtime streams with such inconsistent capabilities cannot be converted to managed Stream objects. IRandomAccessStream instances whose CanRead property returns TRUE must implement the IInputStream interface.";

        public static string Argument_InstancesImplementingIRASThatCanWriteMustImplementIOS = "The specified Windows Runtime stream supports the IRandomAccessStream interface and its CanWrite property returns TRUE, however it does not implement the IOutputStream interface. Windows Runtime streams with such inconsistent capabilities cannot be converted to managed Stream objects. IRandomAccessStream instances whose CanWrite property returns TRUE must implement the IOutputStream interface.";

        public static string Argument_InsufficientArrayElementsAfterOffset = "The specified array does not contain the specified number of elements starting at the specified offset.";

        public static string Argument_InsufficientBufferCapacity = "The specified buffer capacity is not sufficient to hold data of the specified length.";

        public static string Argument_InsufficientSpaceInSourceBuffer = "The specified source buffer does not contain the specified number of elements starting at the specified offset.";

        public static string Argument_InsufficientSpaceInTargetBuffer = "The specified destination buffer is not large enough to hold the specified number of bytes starting at the specified offset.";

        public static string Argument_NotSufficientCapabilitiesToConvertToWinRtStream = "Cannot convert the specified Stream object to a Windows Runtime stream because it does not have sufficient capabilities. In order to convert a System.IO.Stream instance to a Windows Runtime stream at least one of the properties CanRead, CanWrite, CanSeek must return TRUE; however, none of these properties returns TRUE for the specified Stream.";

        public static string Argument_ObjectMustBeWinRtStreamToConvertToNetFxStream = "The specified object cannot be converted to a System.IO.Stream instance because it is not a Windows Runtime stream. In order to convert an object to a Stream instance it must implement at least one of the following 3 Windows Runtime stream interfaces: IInputStream, IOutputStream, IRandomAccessStream.";

        public static string Argument_RelativePathMayNotBeWhitespaceOnly = "The specified relative path may not consist of whitespace only";

        public static string Argument_StreamPositionBeyondEOS = "The specified stream position is beyond the end of the stream.";

        public static string Argument_UnexpectedAsyncResult = "The specified AsyncResult does not correspond to any outstanding IO operation.";

        public static string Argument_WinRtStreamCannotReadOrWrite = "The specified Windows Runtime stream does not support reading nor writing. Windows Runtime streams with such capabilities cannot be converted to managed Stream objects. Use a Windows Runtime stream that can support reading, writing or both.";

        public static string ArgumentOutOfRange_CannotResizeStreamToNegative = "Cannot set the length of a stream to a negative value.";

        public static string ArgumentOutOfRange_IO_CannotSeekToNegativePosition = "Cannot seek to an absolute stream position that is negative.";

        public static string ArgumentOutOfRange_InvalidInputStreamOptionsEnumValue = "The specified value is not a valid member of the InputStreamOptions enumeration.";

        public static string ArgumentOutOfRange_NeedNonNegNum = "Non-negative number required.";

        public static string ArgumentOutOfRange_WinRtAdapterBufferSizeMayNotBeNegative = "The buffer size for a Windows Runtime stream adapter may not be negative. Use a positive buffer size or 0 to disable buffering.";

        public static string InvalidOperation_CannotCallThisMethodInCurrentState = "The state of this object does not permit invoking this method.";

        public static string InvalidOperation_CannotChangeBufferSizeOfWinRtStreamAdapter = "Cannot convert the specified Windows Runtime stream to a managed System.IO.Stream object with the specified buffer size because this Windows Runtime stream has been previously converted to a managed Stream object with a different buffer size. Ensure that the 'bufferSize' argument matches the existing buffer or use the '{0}'-overload without the 'bufferSize' argument to convert the specified Windows Runtime stream to a Stream object with the same buffer size as previously.";

        public static string InvalidOperation_CannotChangeBufferSizeOfWinRtStreamAdapterToZero = "Cannot convert the specified Windows Runtime stream to a managed System.IO.Stream object without a buffer because this Windows Runtime stream has been previously converted to a managed Stream object with a buffer. Ensure that the 'bufferSize' argument matches the existing buffer or use the '{0}'-overload without the 'bufferSize' argument to convert the specified Windows Runtime stream to a Stream object with the same buffer size as previously.";

        public static string InvalidOperation_CannotGetResultsFromIncompleteOperation = "Cannot call GetResults on this asynchronous info because the underlying operation has not completed.";

        public static string InvalidOperation_CannotSetCompletionHanlderMoreThanOnce = "The 'Completed' handler delegate cannot be set more than once, but this handler has already been set.";

        public static string InvalidOperation_CannotSetStreamSizeCannotWrite = "Cannot set the size of this stream because it cannot be written to.";

        public static string InvalidOperation_IllegalStateChange = "The specified state transition is illegal for the current state of this object.";

        public static string InvalidOperation_InvalidAsyncCompletion = "The asynchronous operation could not be completed.";

        public static string InvalidOperation_MultipleIOCompletionCallbackInvocation = "A callback for the same asynchronous IO operation was invoked more than once.";

        public static string InvalidOperation_TaskProviderReturnedUnstartedTask = "The Task provider delegate specified for this IAsyncInfo instance returned a Task object that was not started. Task instances must be run immediately upon creation.";

        public static string InvalidOperation_UnexpectedAsyncOperationID = "This AsyncResult or Task corresponds to a different asynchronous operation ID than the one that invoked the completion callback.";

        public static string InvalidOperation_UnstartedTaskSpecified = "The specified underlying Task is not started. Task instances must be run immediately upon creation.";

        public static string IO_CannotSeekBeyondInt64MaxValue = "Cannot seek to an absolute stream position that is larger than 2^63 - 1 bytes. (2^63 - 1 = 0x7FFFFFFFFFFFFFFF = Int64.MaxValue).";

        public static string IO_CannotSetSizeBeyondInt64MaxValue = "This Windows Runtime stream is backed by a .NET Stream; its size cannot be set to a value that is larger than 2^63 - 1 bytes. (2^63 - 1 = 0x7FFFFFFFFFFFFFFF = Int64.MaxValue).";

        public static string IO_General = "An IO error occurred in the Windows runtime system.";

        public static string IO_UnderlyingWinRTStreamTooLong_CannotUseLengthOrPosition = "This Stream is backed by a Windows Runtime stream with a length that exceeds 2^63 - 1 bytes. Operations related to the stream's length or position cannot be performed on streams when the length exceeds 2^63 - 1 bytes. (2^63 - 1 = 0x7FFFFFFFFFFFFFFF = Int64.MaxValue = approx. 8000 PetaBytes.)";

        public static string NotImplemented_NativeRoutineNotFound = "A native library routine was not found: {0}.";

        public static string NotSupported_CannotConvertNotReadableToInputStream = "Cannot use the specified Stream as a Windows Runtime IInputStream because this Stream is not readable.";

        public static string NotSupported_CannotConvertNotSeekableToRandomAccessStream = "Cannot use the specified Stream as a Windows Runtime IRandomAccessStream because this Stream does not support seeking.";

        public static string NotSupported_CannotConvertNotWritableToOutputStream = "Cannot use the specified Stream as a Windows Runtime IOutputStream because this Stream is not writable.";

        public static string NotSupported_CannotReadFromStream = "This stream does not support read access.";

        public static string NotSupported_CannotSeekInStream = "This stream does not support seeking.";

        public static string NotSupported_CannotUseLength_StreamNotSeekable = "This stream does not support the Length property because it is not seekable.";

        public static string NotSupported_CannotUsePosition_StreamNotSeekable = "This stream does not support the Position property because it is not seekable.";

        public static string NotSupported_CannotWriteToStream = "This stream does not support write access.";

        public static string NotSupported_CloningNotSupported = "This IRandomAccessStream does not support the {0} method because it requires cloning and this stream does not support cloning.";

        public static string NullReference_IOCompletionCallbackCannotProcessNullAsyncInfo = "The Windows Runtime stream that underlies this System.IO.Stream object has invoked an IO completion callback and specified null for the IAsyncInfo instance that describes the completed IO operation. This behavior is not supported because results cannot be retrieved from a null operation. Either the underlying Windows Runtime stream has a faulty implementation, or you are using a Windows Runtime object in an unsupported runtime environment.";

        public static string NullReference_TaskProviderReturnedNull = "The task provider delegate used to create this asynchronous operation returned null, but a valid Task object was expected.";

        public static string ObjectDisposed_AsyncInfoIsClosed = "The requested invocation is not permitted because this IAsyncInfo instance has already been closed.";

        public static string ObjectDisposed_CannotPerformOperation = "The requested operation cannot be performed because this stream has already been disposed.";

        public static string WinRtCOM_Error = "An error has occurred.";

        public static string ObjectDisposed_StreamClosed = "Cannot access a closed stream.";

        public static string NotSupported_UnseekableStream = "Stream does not support seeking.";

        public static string NotSupported_UnreadableStream = "Stream does not support reading.";

        public static string NotSupported_UnwritableStream = "Stream does not support writing.";

        public static string Argument_InvalidSeekOrigin = "Invalid seek origin.";

        public static string DirectUI_Empty = "Empty.";

        public static string InvalidOperation_SendNotSupportedOnWindowsrTSynchronizationContext = "Send is not supported in the Windows Runtime SynchronizationContext";

        public static string UnauthorizedAccess_InternalBuffer = "MemoryStream's internal buffer cannot be accessed.";

        public static string NotSupported_Inheritable = "Inheritable is not a supported option.";

        public static string NotSupported_Encrypted = "Encrypted is not a supported option.";

        public static string IO_FileNotFound = "Unable to find the specified file.";

        public static string IO_FileNotFound_FileName = "Could not find file '{0}'.";

        public static string IO_PathNotFound_NoPathName = "Could not find a part of the path.";

        public static string IO_PathNotFound_Path = "Could not find a part of the path '{0}'.";

        public static string UnauthorizedAccess_IODenied_NoPathName = "Access to the path is denied.";

        public static string UnauthorizedAccess_IODenied_Path = "Access to the path '{0}' is denied.";

        public static string IO_AlreadyExists_Name = "Cannot create '{0}' because a file or directory with the same name already exists.";

        public static string IO_PathTooLong = "The specified file name or path is too long, or a component of the specified path is too long.";

        public static string IO_SharingViolation_File = "The process cannot access the file '{0}' because it is being used by another process.";

        public static string IO_SharingViolation_NoFileName = "The process cannot access the file because it is being used by another process.";

        public static string IO_FileExists_Name = "The file '{0}' already exists.";

        public static string IO_PathTooLong_Path = "The path '{0}' is too long, or a component of the specified path is too long.";
    
        public static string InvalidAction = "Invalid action value: '{0}'.";

    }
}

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace System.Runtime.InteropServices.WindowsRuntime
{
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Threading;
    using global::Windows.Foundation;
    using global::Windows.Storage.Streams;
    using Com;
    /// <summary>
    /// Contains an implementation of the WinRT IBuffer interface that conforms to all requirements on classes that implement that interface,
    /// such as implementing additional interfaces.
    /// </summary>
    public sealed class WindowsRuntimeBuffer : IBuffer, IBufferByteAccess, IMarshal
    {
        [DllImport("api-ms-win-core-winrt-robuffer-l1-1-0.dll")]
        private static extern int RoGetBufferMarshaler(out IntPtr bufferMarshalerPtr);
        #region Constants

        private const string WinTypesDLL = "WinTypes.dll";
        private const int E_BOUNDS = unchecked((int)0x8000000B);

        #endregion Constants


        #region Static factory methods

        public static IBuffer Create(int capacity)
        {
            if (capacity < 0) throw new ArgumentOutOfRangeException(nameof(capacity));

            return new WindowsRuntimeBuffer(capacity);
        }


        public static IBuffer Create(byte[] data, int offset, int length, int capacity)
        {
            if (data == null) throw new ArgumentNullException(nameof(data));
            if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
            if (length < 0) throw new ArgumentOutOfRangeException(nameof(length));
            if (capacity < 0) throw new ArgumentOutOfRangeException(nameof(capacity));
            if (data.Length - offset < length) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);
            if (data.Length - offset < capacity) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);
            if (capacity < length) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientBufferCapacity);

            byte[] underlyingData = new byte[capacity];
            Array.Copy(data, offset, underlyingData, 0, length);
            return new WindowsRuntimeBuffer(underlyingData, 0, length, capacity);
        }

        #endregion Static factory methods


        #region Static fields and helpers

        // This object handles IMarshal calls for us:
        [ThreadStatic]
        private static IMarshal t_winRtMarshalProxy = null;

        private static void EnsureHasMarshalProxy()
        {
            if (t_winRtMarshalProxy != null)
                return;

            try
            {
                int hr = RoGetBufferMarshaler(out IntPtr proxyPtr);
                IMarshal proxy = new ABI.Com.IMarshal(ObjectReference<ABI.Com.IMarshal.Vftbl>.Attach(ref proxyPtr));
                t_winRtMarshalProxy = proxy;

                if (hr != 0)
                {
                    Exception ex = new Exception(string.Format("{0} ({1}!RoGetBufferMarshaler)", global::Windows.Storage.Streams.SR.WinRtCOM_Error, WinTypesDLL));
                    ex.SetHResult(hr);
                    throw ex;
                }

                if (proxy == null)
                    throw new NullReferenceException(string.Format("{0} ({1}!RoGetBufferMarshaler)", global::Windows.Storage.Streams.SR.WinRtCOM_Error, WinTypesDLL));
            }
            catch (DllNotFoundException ex)
            {
                throw new NotImplementedException(string.Format(global::Windows.Storage.Streams.SR.NotImplemented_NativeRoutineNotFound,
                                                               string.Format("{0}!RoGetBufferMarshaler", WinTypesDLL)),
                                                  ex);
            }
        }

        #endregion Static fields and helpers


        #region Fields

        private readonly byte[] _data;
        private readonly int _dataStartOffs = 0;
        private int _usefulDataLength = 0;
        private readonly int _maxDataCapacity = 0;
        private GCHandle _pinHandle;

        // Pointer to data[dataStartOffs] when data is pinned:
        private IntPtr _dataPtr = IntPtr.Zero;

        #endregion Fields


        #region Constructors

        internal WindowsRuntimeBuffer(int capacity)
        {
            if (capacity < 0)
                throw new ArgumentOutOfRangeException(nameof(capacity));

            _data = new byte[capacity];
            _dataStartOffs = 0;
            _usefulDataLength = 0;
            _maxDataCapacity = capacity;
            _dataPtr = IntPtr.Zero;
        }


        internal WindowsRuntimeBuffer(byte[] data, int offset, int length, int capacity)
        {
            if (data == null) throw new ArgumentNullException(nameof(data));
            if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
            if (length < 0) throw new ArgumentOutOfRangeException(nameof(length));
            if (capacity < 0) throw new ArgumentOutOfRangeException(nameof(capacity));
            if (data.Length - offset < length) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);
            if (data.Length - offset < capacity) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);
            if (capacity < length) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientBufferCapacity);

            _data = data;
            _dataStartOffs = offset;
            _usefulDataLength = length;
            _maxDataCapacity = capacity;
            _dataPtr = IntPtr.Zero;
        }

        #endregion Constructors


        #region Helpers

        internal void GetUnderlyingData(out byte[] underlyingDataArray, out int underlyingDataArrayStartOffset)
        {
            underlyingDataArray = _data;
            underlyingDataArrayStartOffset = _dataStartOffs;
        }


        private unsafe byte* PinUnderlyingData()
        {
            GCHandle gcHandle = default(GCHandle);
            bool ptrWasStored = false;
            IntPtr buffPtr;

            try { }
            finally
            {
                try
                {
                    // Pin the data array:
                    gcHandle = GCHandle.Alloc(_data, GCHandleType.Pinned);
                    buffPtr = gcHandle.AddrOfPinnedObject() + _dataStartOffs;

                    // Store the pin IFF it has not been assigned:
                    ptrWasStored = (Interlocked.CompareExchange(ref _dataPtr, buffPtr, IntPtr.Zero) == IntPtr.Zero);
                }
                finally
                {
                    if (!ptrWasStored)
                    {
                        // There is a race with another thread also trying to create a pin and they were first
                        // in assigning to data pin. That's ok, just give it up.
                        // Unpin again (the pin from the other thread remains):
                        gcHandle.Free();
                    }
                    else
                    {
                        if (_pinHandle.IsAllocated)
                            _pinHandle.Free();

                        // Make sure we keep track of the handle
                        _pinHandle = gcHandle;
                    }
                }
            }

            // Ok, now all is good:
            return (byte*)buffPtr;
        }

        ~WindowsRuntimeBuffer()
        {
            if (_pinHandle.IsAllocated)
                _pinHandle.Free();
        }

        #endregion Helpers


        #region Implementation of Windows.Foundation.IBuffer

        uint IBuffer.Capacity
        {
            get { return unchecked((uint)_maxDataCapacity); }
        }


        uint IBuffer.Length
        {
            get
            {
                return unchecked((uint)_usefulDataLength);
            }

            set
            {
                if (value > ((IBuffer)this).Capacity)
                {
                    ArgumentOutOfRangeException ex = new ArgumentOutOfRangeException(nameof(value), global::Windows.Storage.Streams.SR.Argument_BufferLengthExceedsCapacity);
                    ex.SetHResult(E_BOUNDS);
                    throw ex;
                }

                // Capacity is ensured to not exceed Int32.MaxValue, so Length is within this limit and this cast is safe:
                Debug.Assert(((IBuffer)this).Capacity <= int.MaxValue);
                _usefulDataLength = unchecked((int)value);
            }
        }

        #endregion Implementation of Windows.Foundation.IBuffer


        #region Implementation of IBufferByteAccess

        unsafe IntPtr IBufferByteAccess.Buffer
        {
            get
            {
                // Get pin handle:
                IntPtr buffPtr = Volatile.Read(ref _dataPtr);

                // If we are already pinned, return the pointer and have a nice day:
                if (buffPtr != IntPtr.Zero)
                    return buffPtr;

                // Ok, we are not yet pinned. Let's do it.
                return new IntPtr(PinUnderlyingData());
            }
        }

        #endregion Implementation of IBufferByteAccess

        #region Implementation of IMarshal

        void IMarshal.DisconnectObject(uint dwReserved)
        {
            EnsureHasMarshalProxy();
            t_winRtMarshalProxy!.DisconnectObject(dwReserved);
        }


        void IMarshal.GetMarshalSizeMax(ref Guid riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags, out uint pSize)
        {
            EnsureHasMarshalProxy();
            t_winRtMarshalProxy!.GetMarshalSizeMax(ref riid, pv, dwDestContext, pvDestContext, mshlflags, out pSize);
        }


        void IMarshal.GetUnmarshalClass(ref Guid riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlFlags, out Guid pCid)
        {
            EnsureHasMarshalProxy();
            t_winRtMarshalProxy!.GetUnmarshalClass(ref riid, pv, dwDestContext, pvDestContext, mshlFlags, out pCid);
        }


        void IMarshal.MarshalInterface(IntPtr pStm, ref Guid riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags)
        {
            EnsureHasMarshalProxy();
            t_winRtMarshalProxy!.MarshalInterface(pStm, ref riid, pv, dwDestContext, pvDestContext, mshlflags);
        }


        void IMarshal.ReleaseMarshalData(IntPtr pStm)
        {
            EnsureHasMarshalProxy();
            t_winRtMarshalProxy!.ReleaseMarshalData(pStm);
        }


        void IMarshal.UnmarshalInterface(IntPtr pStm, ref Guid riid, out IntPtr ppv)
        {
            EnsureHasMarshalProxy();
            t_winRtMarshalProxy!.UnmarshalInterface(pStm, ref riid, out ppv);
        }
        #endregion Implementation of IMarshal
    }  // class WindowsRuntimeBuffer
}  // namespace

// WindowsRuntimeBuffer.cs

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace System.Runtime.InteropServices.WindowsRuntime
{
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.IO;
    using global::Windows.Foundation;
    using global::Windows.Storage.Streams;
    /// <summary>
    /// Contains extension methods that expose operations on WinRT <code>Windows.Foundation.IBuffer</code>.
    /// </summary>
    public static class WindowsRuntimeBufferExtensions
    {
        #region (Byte []).AsBuffer extensions

        public static IBuffer AsBuffer(this byte[] source)
        {
            if (source == null) throw new ArgumentNullException(nameof(source));

            return AsBuffer(source, 0, source.Length, source.Length);
        }


        public static IBuffer AsBuffer(this byte[] source, int offset, int length)
        {
            if (source == null) throw new ArgumentNullException(nameof(source));
            if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
            if (length < 0) throw new ArgumentOutOfRangeException(nameof(length));
            if (source.Length - offset < length) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);

            return AsBuffer(source, offset, length, length);
        }


        public static IBuffer AsBuffer(this byte[] source, int offset, int length, int capacity)
        {
            if (source == null) throw new ArgumentNullException(nameof(source));
            if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
            if (length < 0) throw new ArgumentOutOfRangeException(nameof(length));
            if (capacity < 0) throw new ArgumentOutOfRangeException(nameof(capacity));
            if (source.Length - offset < length) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);
            if (source.Length - offset < capacity) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);
            if (capacity < length) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientBufferCapacity);

            return new WindowsRuntimeBuffer(source, offset, length, capacity);
        }

        #endregion (Byte []).AsBuffer extensions


        #region (Byte []).CopyTo extensions for copying to an (IBuffer)

        /// <summary>
        /// Copies the contents of <code>source</code> to <code>destination</code> starting at offset 0.
        /// This method does <em>NOT</em> update <code>destination.Length</code>.
        /// </summary>
        /// <param name="source">Array to copy data from.</param>
        /// <param name="destination">The buffer to copy to.</param>
        public static void CopyTo(this byte[] source, IBuffer destination)
        {
            if (source == null) throw new ArgumentNullException(nameof(source));
            if (destination == null) throw new ArgumentNullException(nameof(destination));

            CopyTo(source, 0, destination, 0, source.Length);
        }


        /// <summary>
        /// Copies <code>count</code> bytes from <code>source</code> starting at offset <code>sourceIndex</code>
        /// to <code>destination</code> starting at <code>destinationIndex</code>.
        /// This method does <em>NOT</em> update <code>destination.Length</code>.
        /// </summary>
        /// <param name="source">Array to copy data from.</param>
        /// <param name="sourceIndex">Position in the array from where to start copying.</param>
        /// <param name="destination">The buffer to copy to.</param>
        /// <param name="destinationIndex">Position in the buffer to where to start copying.</param>
        /// <param name="count">The number of bytes to copy.</param>
        public static void CopyTo(this byte[] source, int sourceIndex, IBuffer destination, uint destinationIndex, int count)
        {
            if (source == null) throw new ArgumentNullException(nameof(source));
            if (destination == null) throw new ArgumentNullException(nameof(destination));
            if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
            if (sourceIndex < 0) throw new ArgumentOutOfRangeException(nameof(sourceIndex));
            if (source.Length < sourceIndex) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_IndexOutOfArrayBounds, nameof(sourceIndex));
            if (source.Length - sourceIndex < count) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);
            if (destination.Capacity < destinationIndex) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_BufferIndexExceedsCapacity);
            if (destination.Capacity - destinationIndex < count) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientSpaceInTargetBuffer);
            if (count == 0) return;

            // If destination is backed by a managed array, use the array instead of the pointer as it does not require pinning:
            byte[] destDataArr;
            int destDataOffs;
            if (destination.TryGetUnderlyingData(out destDataArr, out destDataOffs))
            {
                global::System.Buffer.BlockCopy(source, sourceIndex, destDataArr, (int)(destDataOffs + destinationIndex), count);
                return;
            }

            IntPtr destPtr = destination.GetPointerAtOffset(destinationIndex);
            Marshal.Copy(source, sourceIndex, destPtr, count);
        }

        #endregion (Byte []).CopyTo extensions for copying to an (IBuffer)


        #region (IBuffer).ToArray extensions for copying to a new (Byte [])

        public static byte[] ToArray(this IBuffer source)
        {
            if (source == null) throw new ArgumentNullException(nameof(source));

            return ToArray(source, 0, checked((int)source.Length));
        }


        public static byte[] ToArray(this IBuffer source, uint sourceIndex, int count)
        {
            if (source == null) throw new ArgumentNullException(nameof(source));
            if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
            if (source.Length < sourceIndex) throw new ArgumentException("The specified buffer index is not within the buffer length.");
            if (source.Length - sourceIndex < count) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientSpaceInSourceBuffer);

            if (count == 0)
                return Array.Empty<byte>();

            byte[] destination = new byte[count];
            source.CopyTo(sourceIndex, destination, 0, count);
            return destination;
        }

        #endregion (IBuffer).ToArray extensions for copying to a new (Byte [])


        #region (IBuffer).CopyTo extensions for copying to a (Byte [])

        public static void CopyTo(this IBuffer source, byte[] destination)
        {
            if (source == null) throw new ArgumentNullException(nameof(source));
            if (destination == null) throw new ArgumentNullException(nameof(destination));

            CopyTo(source, 0, destination, 0, checked((int)source.Length));
        }


        public static void CopyTo(this IBuffer source, uint sourceIndex, byte[] destination, int destinationIndex, int count)
        {
            if (source == null) throw new ArgumentNullException(nameof(source));
            if (destination == null) throw new ArgumentNullException(nameof(destination));
            if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
            if (destinationIndex < 0) throw new ArgumentOutOfRangeException(nameof(destinationIndex));
            if (source.Length < sourceIndex) throw new ArgumentException("The specified buffer index is not within the buffer length.");
            if (source.Length - sourceIndex < count) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientSpaceInSourceBuffer);
            if (destination.Length < destinationIndex) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_IndexOutOfArrayBounds);
            if (destination.Length - destinationIndex < count) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);
            if (count == 0) return;

            // If source is backed by a managed array, use the array instead of the pointer as it does not require pinning:
            byte[] srcDataArr;
            int srcDataOffs;
            if (source.TryGetUnderlyingData(out srcDataArr, out srcDataOffs))
            {
                global::System.Buffer.BlockCopy(srcDataArr, (int)(srcDataOffs + sourceIndex), destination, destinationIndex, count);
                return;
            }

            IntPtr srcPtr = source.GetPointerAtOffset(sourceIndex);
            Marshal.Copy(srcPtr, destination, destinationIndex, count);
        }

        #endregion (IBuffer).CopyTo extensions for copying to a (Byte [])


        #region (IBuffer).CopyTo extensions for copying to an (IBuffer)

        public static void CopyTo(this IBuffer source, IBuffer destination)
        {
            if (source == null) throw new ArgumentNullException(nameof(source));
            if (destination == null) throw new ArgumentNullException(nameof(destination));

            CopyTo(source, 0, destination, 0, source.Length);
        }


        public static void CopyTo(this IBuffer source, uint sourceIndex, IBuffer destination, uint destinationIndex, uint count)
        {
            if (source == null) throw new ArgumentNullException(nameof(source));
            if (destination == null) throw new ArgumentNullException(nameof(destination));
            if (source.Length < sourceIndex) throw new ArgumentException("The specified buffer index is not within the buffer length.");
            if (source.Length - sourceIndex < count) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientSpaceInSourceBuffer);
            if (destination.Capacity < destinationIndex) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_BufferIndexExceedsCapacity);
            if (destination.Capacity - destinationIndex < count) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientSpaceInTargetBuffer);
            if (count == 0) return;

            // If source are destination are backed by managed arrays, use the arrays instead of the pointers as it does not require pinning:
            byte[] srcDataArr, destDataArr;
            int srcDataOffs, destDataOffs;

            bool srcIsManaged = source.TryGetUnderlyingData(out srcDataArr, out srcDataOffs);
            bool destIsManaged = destination.TryGetUnderlyingData(out destDataArr, out destDataOffs);

            if (srcIsManaged && destIsManaged)
            {
                Debug.Assert(count <= int.MaxValue);
                Debug.Assert(sourceIndex <= int.MaxValue);
                Debug.Assert(destinationIndex <= int.MaxValue);

                global::System.Buffer.BlockCopy(srcDataArr!, srcDataOffs + (int)sourceIndex, destDataArr!, destDataOffs + (int)destinationIndex, (int)count);
                return;
            }

            IntPtr srcPtr, destPtr;

            if (srcIsManaged)
            {
                Debug.Assert(count <= int.MaxValue);
                Debug.Assert(sourceIndex <= int.MaxValue);

                destPtr = destination.GetPointerAtOffset(destinationIndex);
                Marshal.Copy(srcDataArr!, srcDataOffs + (int)sourceIndex, destPtr, (int)count);
                return;
            }

            if (destIsManaged)
            {
                Debug.Assert(count <= int.MaxValue);
                Debug.Assert(destinationIndex <= int.MaxValue);

                srcPtr = source.GetPointerAtOffset(sourceIndex);
                Marshal.Copy(srcPtr, destDataArr!, destDataOffs + (int)destinationIndex, (int)count);
                return;
            }

            srcPtr = source.GetPointerAtOffset(sourceIndex);
            destPtr = destination.GetPointerAtOffset(destinationIndex);
            MemCopy(srcPtr, destPtr, count);
        }

        #endregion (IBuffer).CopyTo extensions for copying to an (IBuffer)


        #region Access to underlying array optimised for IBuffers backed by managed arrays (to avoid pinning)

        /// <summary>
        /// If the specified <code>IBuffer</code> is backed by a managed array, this method will return <code>true</code> and
        /// set <code>underlyingDataArray</code> to refer to that array
        /// and <code>underlyingDataArrayStartOffset</code> to the value at which the buffer data begins in that array.
        /// If the specified <code>IBuffer</code> is <em>not</em> backed by a managed array, this method will return <code>false</code>.
        /// This method is required by managed APIs that wish to use the buffer's data with other managed APIs that use
        /// arrays without a need for a memory copy.
        /// </summary>
        /// <param name="buffer">An <code>IBuffer</code>.</param>
        /// <param name="underlyingDataArray">Will be set to the data array backing <code>buffer</code> or to <code>null</code>.</param>
        /// <param name="underlyingDataArrayStartOffset">Will be set to the start offset of the buffer data in the backing array
        /// or to <code>-1</code>.</param>
        /// <returns>Whether the <code>IBuffer</code> is backed by a managed byte array.</returns>
        internal static bool TryGetUnderlyingData(this IBuffer buffer, out byte[] underlyingDataArray, out int underlyingDataArrayStartOffset)
        {
            if (buffer == null)
                throw new ArgumentNullException(nameof(buffer));

            WindowsRuntimeBuffer winRtBuffer = buffer as WindowsRuntimeBuffer;
            if (winRtBuffer == null)
            {
                underlyingDataArray = null;
                underlyingDataArrayStartOffset = -1;
                return false;
            }

            winRtBuffer.GetUnderlyingData(out underlyingDataArray, out underlyingDataArrayStartOffset);
            return true;
        }


        /// <summary>
        /// Checks if the underlying memory backing two <code>IBuffer</code> instances is actually the same memory.
        /// When applied to <code>IBuffer</code> instances backed by managed arrays this method is preferable to a naive comparison
        /// (such as <code>((IBufferByteAccess) buffer).Buffer == ((IBufferByteAccess) otherBuffer).Buffer</code>) because it avoids
        /// pinning the backing array which would be necessary if a direct memory pointer was obtained.
        /// </summary>
        /// <param name="buffer">An <code>IBuffer</code> instance.</param>
        /// <param name="otherBuffer">An <code>IBuffer</code> instance or <code>null</code>.</param>
        /// <returns><code>true</code> if the underlying <code>Buffer</code> memory pointer is the same for both specified
        /// <code>IBuffer</code> instances (i.e. if they are backed by the same memory); <code>false</code> otherwise.</returns>
        public static bool IsSameData(this IBuffer buffer, IBuffer otherBuffer)
        {
            if (buffer == null)
                throw new ArgumentNullException(nameof(buffer));

            if (otherBuffer == null)
                return false;

            if (buffer == otherBuffer)
                return true;

            byte[] thisDataArr, otherDataArr;
            int thisDataOffs, otherDataOffs;

            bool thisIsManaged = buffer.TryGetUnderlyingData(out thisDataArr, out thisDataOffs);
            bool otherIsManaged = otherBuffer.TryGetUnderlyingData(out otherDataArr, out otherDataOffs);

            if (thisIsManaged != otherIsManaged)
                return false;

            if (thisIsManaged)
                return (thisDataArr == otherDataArr) && (thisDataOffs == otherDataOffs);

            IBufferByteAccess thisBuff = buffer.As<IBufferByteAccess>();
            IBufferByteAccess otherBuff = otherBuffer.As<IBufferByteAccess>();

            unsafe
            {
                return (thisBuff.Buffer == otherBuff.Buffer);
            }
        }

        #endregion Access to underlying array optimised for IBuffers backed by managed arrays (to avoid pinning)


        #region Extensions for co-operation with memory streams (share mem stream data; expose data as managed/unmanaged mem stream)
        /// <summary>
        /// Creates a new <code>IBuffer</code> instance backed by the same memory as is backing the specified <code>MemoryStream</code>.
        /// The <code>MemoryStream</code> may re-sized in future, as a result the stream will be backed by a different memory region.
        /// In such case, the buffer created by this method will remain backed by the memory behind the stream at the time the buffer was created.<br />
        /// This method can throw an <code>ObjectDisposedException</code> if the specified stream is closed.<br />
        /// This method can throw an <code>UnauthorizedAccessException</code> if the specified stream cannot expose its underlying memory buffer.
        /// </summary>
        /// <param name="underlyingStream">A memory stream to share the data memory with the buffer being created.</param>
        /// <returns>A new <code>IBuffer</code> backed by the same memory as this specified stream.</returns>
        // The naming inconsistency with (Byte []).AsBuffer is intentional: as this extension method will appear on
        // MemoryStream, consistency with method names on MemoryStream is more important. There we already have an API
        // called GetBuffer which returns the underlying array.
        public static IBuffer GetWindowsRuntimeBuffer(this MemoryStream underlyingStream)
        {
            if (underlyingStream == null)
                throw new ArgumentNullException(nameof(underlyingStream));

            ArraySegment<byte> streamData;
            if (!underlyingStream.TryGetBuffer(out streamData))
            {
                throw new UnauthorizedAccessException(global::Windows.Storage.Streams.SR.UnauthorizedAccess_InternalBuffer);
            }
            return new WindowsRuntimeBuffer(streamData.Array!, (int)streamData.Offset, (int)underlyingStream.Length, underlyingStream.Capacity);
        }


        /// <summary>
        /// Creates a new <code>IBuffer</code> instance backed by the same memory as is backing the specified <code>MemoryStream</code>.
        /// The <code>MemoryStream</code> may re-sized in future, as a result the stream will be backed by a different memory region.
        /// In such case buffer created by this method will remain backed by the memory behind the stream at the time the buffer was created.<br />
        /// This method can throw an <code>ObjectDisposedException</code> if the specified stream is closed.<br />
        /// This method can throw an <code>UnauthorizedAccessException</code> if the specified stream cannot expose its underlying memory buffer.
        /// The created buffer begins at position <code>positionInStream</code> in the stream and extends over up to <code>length</code> bytes.
        /// If the stream has less than <code>length</code> bytes after the specified starting position, the created buffer covers only as many
        /// bytes as available in the stream. In either case, the <code>Length</code> and the <code>Capacity</code> properties of the created
        /// buffer are set accordingly: <code>Capacity</code> - number of bytes between <code>positionInStream</code> and the stream capacity end,
        /// but not more than <code>length</code>; <code>Length</code> - number of bytes between <code>positionInStream</code> and the stream
        /// length end, or zero if <code>positionInStream</code> is beyond stream length end, but not more than <code>length</code>.
        /// </summary>
        /// <param name="underlyingStream">A memory stream to share the data memory with the buffer being created.</param>
        /// <param name="positionInStream">The position of the shared memory region.</param>
        /// <param name="length">The maximum size of the shared memory region.</param>
        /// <returns>A new <code>IBuffer</code> backed by the same memory as this specified stream.</returns>
        public static IBuffer GetWindowsRuntimeBuffer(this MemoryStream underlyingStream, int positionInStream, int length)
        {
            // The naming inconsistency with (Byte []).AsBuffer is intentional: as this extension method will appear on
            // MemoryStream, consistency with method names on MemoryStream is more important. There we already have an API
            // called GetBuffer which returns the underlying array.

            if (underlyingStream == null)
                throw new ArgumentNullException(nameof(underlyingStream));

            if (positionInStream < 0)
                throw new ArgumentOutOfRangeException(nameof(positionInStream));

            if (length < 0)
                throw new ArgumentOutOfRangeException(nameof(length));

            if (underlyingStream.Length < positionInStream)
                throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_StreamPositionBeyondEOS);

            ArraySegment<byte> streamData;

            if (!underlyingStream.TryGetBuffer(out streamData))
            {
                throw new UnauthorizedAccessException(global::Windows.Storage.Streams.SR.UnauthorizedAccess_InternalBuffer);
            }

            int originInStream = streamData.Offset;
            int buffCapacity = Math.Min(length, underlyingStream.Capacity - positionInStream);
            int buffLength = Math.Max(0, Math.Min(length, ((int)underlyingStream.Length) - positionInStream));
            return new WindowsRuntimeBuffer(streamData.Array!, originInStream + positionInStream, buffLength, buffCapacity);
        }


        public static Stream AsStream(this IBuffer source)
        {
            if (source == null)
                throw new ArgumentNullException(nameof(source));

            byte[] dataArr;
            int dataOffs;
            if (source.TryGetUnderlyingData(out dataArr, out dataOffs))
            {
                Debug.Assert(source.Capacity < int.MaxValue);
                return new MemoryStream(dataArr, dataOffs, (int)source.Capacity, true);
            }

            unsafe
            {
                IBufferByteAccess bufferByteAccess = source.As<IBufferByteAccess>();
                return new WindowsRuntimeBufferUnmanagedMemoryStream(source, (byte*)bufferByteAccess.Buffer);
            }
        }

        #endregion Extensions for co-operation with memory streams (share mem stream data; expose data as managed/unmanaged mem stream)


        #region Extensions for direct by-offset access to buffer data elements

        public static byte GetByte(this IBuffer source, uint byteOffset)
        {
            if (source == null) throw new ArgumentNullException(nameof(source));
            if (source.Length <= byteOffset) throw new ArgumentException("The specified buffer offset is not within the buffer length.");

            byte[] srcDataArr;
            int srcDataOffs;
            if (source.TryGetUnderlyingData(out srcDataArr, out srcDataOffs))
            {
                return srcDataArr[srcDataOffs + byteOffset];
            }

            IntPtr srcPtr = source.GetPointerAtOffset(byteOffset);
            unsafe
            {
                // Let's avoid an unnesecary call to Marshal.ReadByte():
                byte* ptr = (byte*)srcPtr;
                return *ptr;
            }
        }

        #endregion Extensions for direct by-offset access to buffer data elements


        #region Private plumbing

        private class WindowsRuntimeBufferUnmanagedMemoryStream : UnmanagedMemoryStream
        {
            // We need this class because if we construct an UnmanagedMemoryStream on an IBuffer backed by native memory,
            // we must keep around a reference to the IBuffer from which we got the memory pointer. Otherwise the ref count
            // of the underlying COM object may drop to zero and the memory may get freed.

            private readonly IBuffer _sourceBuffer;

            internal unsafe WindowsRuntimeBufferUnmanagedMemoryStream(IBuffer sourceBuffer, byte* dataPtr)

                : base(dataPtr, (long)sourceBuffer.Length, (long)sourceBuffer.Capacity, FileAccess.ReadWrite)
            {
                _sourceBuffer = sourceBuffer;
            }
        }  // class WindowsRuntimeBufferUnmanagedMemoryStream

        private static IntPtr GetPointerAtOffset(this IBuffer buffer, uint offset)
        {
            Debug.Assert(0 <= offset);
            Debug.Assert(offset < buffer.Capacity);

            unsafe
            {
                IntPtr buffPtr = buffer.As<IBufferByteAccess>().Buffer;
                return new IntPtr((byte*)buffPtr + offset);
            }
        }

        private static unsafe void MemCopy(IntPtr src, IntPtr dst, uint count)
        {
            if (count > int.MaxValue)
            {
                MemCopy(src, dst, int.MaxValue);
                MemCopy(src + int.MaxValue, dst + int.MaxValue, count - int.MaxValue);
                return;
            }

            Debug.Assert(count <= int.MaxValue);
            int bCount = (int)count;


            // Copy via buffer.
            // Note: if becomes perf critical, we will port the routine that
            // copies the data without using Marshal (and byte[])
            byte[] tmp = new byte[bCount];
            Marshal.Copy(src, tmp, 0, bCount);
            Marshal.Copy(tmp, 0, dst, bCount);
            return;
        }
        #endregion Private plumbing
    }  // class WindowsRuntimeBufferExtensions
}  // namespace

// WindowsRuntimeBufferExtensions.cs

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace System.IO
{
    using System.ComponentModel;
    using System.Diagnostics;
    using System.IO;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;
    using System.Threading.Tasks;
    using global::Windows.Foundation;
    using global::Windows.Storage.Streams;
    /// <summary>
    /// Contains extension methods for conversion between WinRT streams and managed streams.
    /// This class is the public facade for the stream adapters library.
    /// </summary>
    public static class WindowsRuntimeStreamExtensions
    {
        #region Constants and static Fields

        private const int DefaultBufferSize = 16384;  // = 0x4000 = 16 KBytes.

        private static readonly ConditionalWeakTable<object, Stream> s_winRtToNetFxAdapterMap
                 = new ConditionalWeakTable<object, Stream>();

        private static readonly ConditionalWeakTable<Stream, NetFxToWinRtStreamAdapter> s_netFxToWinRtAdapterMap
                 = new ConditionalWeakTable<Stream, NetFxToWinRtStreamAdapter>();

        #endregion Constants and static Fields


#if !NETSTANDARD2_0

        #region Helpers

#if DEBUG
        private static void AssertMapContains<TKey, TValue>(ConditionalWeakTable<TKey, TValue> map, TKey key, TValue value,
                                                            bool valueMayBeWrappedInBufferedStream)
                                                                                                where TKey : class
                                                                                                where TValue : class
        {
            TValue valueInMap;

            Debug.Assert(key != null);

            bool hasValueForKey = map.TryGetValue(key, out valueInMap);

            Debug.Assert(hasValueForKey);

            if (valueMayBeWrappedInBufferedStream)
            {
                BufferedStream bufferedValueInMap = valueInMap as BufferedStream;
                Debug.Assert(object.ReferenceEquals(value, valueInMap)
                                || (bufferedValueInMap != null && object.ReferenceEquals(value, bufferedValueInMap.UnderlyingStream)));
            }
            else
            {
                Debug.Assert(object.ReferenceEquals(value, valueInMap));
            }
        }
#endif  // DEBUG

        #endregion Helpers

        private static void EnsureAdapterBufferSize(Stream adapter, int requiredBufferSize, string methodName)
        {
            Debug.Assert(adapter != null);
            Debug.Assert(!string.IsNullOrWhiteSpace(methodName));

            int currentBufferSize = 0;
            BufferedStream bufferedAdapter = adapter as BufferedStream;
            if (bufferedAdapter != null)
                currentBufferSize = bufferedAdapter.BufferSize;

            if (requiredBufferSize != currentBufferSize)
            {
                if (requiredBufferSize == 0)
                    throw new InvalidOperationException(string.Format(global::Windows.Storage.Streams.SR.InvalidOperation_CannotChangeBufferSizeOfWinRtStreamAdapterToZero, methodName));

                throw new InvalidOperationException(string.Format(global::Windows.Storage.Streams.SR.InvalidOperation_CannotChangeBufferSizeOfWinRtStreamAdapter, methodName));
            }
        }


        #region WinRt-to-NetFx conversion

        public static Stream AsStreamForRead(this IInputStream windowsruntimeStream)
        {
            return AsStreamInternal(windowsruntimeStream, DefaultBufferSize, "AsStreamForRead", forceBufferSize: false);
        }


        public static Stream AsStreamForRead(this IInputStream windowsruntimeStream, int bufferSize)
        {
            return AsStreamInternal(windowsruntimeStream, bufferSize, "AsStreamForRead", forceBufferSize: true);
        }


        public static Stream AsStreamForWrite(this IOutputStream windowsruntimeStream)
        {
            return AsStreamInternal(windowsruntimeStream, DefaultBufferSize, "AsStreamForWrite", forceBufferSize: false);
        }


        public static Stream AsStreamForWrite(this IOutputStream windowsruntimeStream, int bufferSize)
        {
            return AsStreamInternal(windowsruntimeStream, bufferSize, "AsStreamForWrite", forceBufferSize: true);
        }


        public static Stream AsStream(this IRandomAccessStream windowsruntimeStream)
        {
            return AsStreamInternal(windowsruntimeStream, DefaultBufferSize, "AsStream", forceBufferSize: false);
        }


        public static Stream AsStream(this IRandomAccessStream windowsruntimeStream, int bufferSize)
        {
            return AsStreamInternal(windowsruntimeStream, bufferSize, "AsStream", forceBufferSize: true);
        }


        private static Stream AsStreamInternal(object windowsruntimeStream, int bufferSize, string invokedMethodName, bool forceBufferSize)
        {
            if (windowsruntimeStream == null)
                throw new ArgumentNullException(nameof(windowsruntimeStream));

            if (bufferSize < 0)
                throw new ArgumentOutOfRangeException(nameof(bufferSize), global::Windows.Storage.Streams.SR.ArgumentOutOfRange_WinRtAdapterBufferSizeMayNotBeNegative);

            Debug.Assert(!string.IsNullOrWhiteSpace(invokedMethodName));

            // If the WinRT stream is actually a wrapped managed stream, we will unwrap it and return the original.
            // In that case we do not need to put the wrapper into the map.

            // We currently do capability-based adapter selection for WinRt->NetFx, but not vice versa (time constraints).
            // Once we added the reverse direction, we will be able replce this entire section with just a few lines.
            NetFxToWinRtStreamAdapter sAdptr = windowsruntimeStream as NetFxToWinRtStreamAdapter;
            if (sAdptr != null)
            {
                Stream wrappedNetFxStream = sAdptr.GetManagedStream();
                if (wrappedNetFxStream == null)
                    throw new ObjectDisposedException(nameof(windowsruntimeStream), global::Windows.Storage.Streams.SR.ObjectDisposed_CannotPerformOperation);

#if DEBUG  // In Chk builds, verify that the original managed stream is correctly entered into the NetFx->WinRT map:
                AssertMapContains(s_netFxToWinRtAdapterMap, wrappedNetFxStream, sAdptr,
                                  valueMayBeWrappedInBufferedStream: false);
#endif  // DEBUG

                return wrappedNetFxStream;
            }

            // We have a real WinRT stream.

            Stream adapter;
            bool adapterExists = s_winRtToNetFxAdapterMap.TryGetValue(windowsruntimeStream, out adapter);

            // There is already an adapter:
            if (adapterExists)
            {
                Debug.Assert((adapter is BufferedStream && ((BufferedStream)adapter).UnderlyingStream is WinRtToNetFxStreamAdapter)
                                || (adapter is WinRtToNetFxStreamAdapter));

                if (forceBufferSize)
                    EnsureAdapterBufferSize(adapter, bufferSize, invokedMethodName);

                return adapter;
            }

            // We do not have an adapter for this WinRT stream yet and we need to create one.
            // Do that in a thread-safe manner in a separate method such that we only have to pay for the compiler allocating
            // the required closure if this code path is hit:

            return AsStreamInternalFactoryHelper(windowsruntimeStream, bufferSize, invokedMethodName, forceBufferSize);
        }


        // Separate method so we only pay for closure allocation if this code is executed:
        private static Stream WinRtToNetFxAdapterMap_GetValue(object winRtStream)
        {
            return s_winRtToNetFxAdapterMap.GetValue(winRtStream, (wrtStr) => WinRtToNetFxStreamAdapter.Create(wrtStr));
        }


        // Separate method so we only pay for closure allocation if this code is executed:
        private static Stream WinRtToNetFxAdapterMap_GetValue(object winRtStream, int bufferSize)
        {
            return s_winRtToNetFxAdapterMap.GetValue(winRtStream, (wrtStr) => new BufferedStream(WinRtToNetFxStreamAdapter.Create(wrtStr), bufferSize));
        }


        private static Stream AsStreamInternalFactoryHelper(object windowsruntimeStream, int bufferSize, string invokedMethodName, bool forceBufferSize)
        {
            Debug.Assert(windowsruntimeStream != null);
            Debug.Assert(bufferSize >= 0);
            Debug.Assert(!string.IsNullOrWhiteSpace(invokedMethodName));

            // Get the adapter for this windowsruntimeStream again (it may have been created concurrently).
            // If none exists yet, create a new one:
            Stream adapter = (bufferSize == 0)
                                ? WinRtToNetFxAdapterMap_GetValue(windowsruntimeStream)
                                : WinRtToNetFxAdapterMap_GetValue(windowsruntimeStream, bufferSize);

            Debug.Assert(adapter != null);
            Debug.Assert((adapter is BufferedStream && ((BufferedStream)adapter).UnderlyingStream is WinRtToNetFxStreamAdapter)
                                || (adapter is WinRtToNetFxStreamAdapter));

            if (forceBufferSize)
                EnsureAdapterBufferSize(adapter, bufferSize, invokedMethodName);

            WinRtToNetFxStreamAdapter actualAdapter = adapter as WinRtToNetFxStreamAdapter;
            if (actualAdapter == null)
                actualAdapter = ((BufferedStream)adapter).UnderlyingStream as WinRtToNetFxStreamAdapter;

            actualAdapter!.SetWonInitializationRace();

            return adapter;
        }

        #endregion WinRt-to-NetFx conversion

        #region NetFx-to-WinRt conversion

        public static IInputStream AsInputStream(this Stream stream)
        {
            if (stream == null)
                throw new ArgumentNullException(nameof(stream));

            if (!stream.CanRead)
                throw new NotSupportedException(global::Windows.Storage.Streams.SR.NotSupported_CannotConvertNotReadableToInputStream);

            object adapter = AsWindowsRuntimeStreamInternal(stream);

            IInputStream winRtStream = adapter as IInputStream;
            Debug.Assert(winRtStream != null);

            return winRtStream;
        }


        public static IOutputStream AsOutputStream(this Stream stream)
        {
            if (stream == null)
                throw new ArgumentNullException(nameof(stream));

            if (!stream.CanWrite)
                throw new NotSupportedException(global::Windows.Storage.Streams.SR.NotSupported_CannotConvertNotWritableToOutputStream);

            object adapter = AsWindowsRuntimeStreamInternal(stream);

            IOutputStream winRtStream = adapter as IOutputStream;
            Debug.Assert(winRtStream != null);

            return winRtStream;
        }


        public static IRandomAccessStream AsRandomAccessStream(this Stream stream)
        {
            if (stream == null)
                throw new ArgumentNullException(nameof(stream));

            if (!stream.CanSeek)
                throw new NotSupportedException(global::Windows.Storage.Streams.SR.NotSupported_CannotConvertNotSeekableToRandomAccessStream);

            object adapter = AsWindowsRuntimeStreamInternal(stream);

            IRandomAccessStream winRtStream = adapter as IRandomAccessStream;
            Debug.Assert(winRtStream != null);

            return winRtStream;
        }


        private static object AsWindowsRuntimeStreamInternal(Stream stream)
        {
            // Check to see if the managed stream is actually a wrapper of a WinRT stream:
            // (This can be either an adapter directly, or an adapter wrapped in a BufferedStream.)
            WinRtToNetFxStreamAdapter sAdptr = stream as WinRtToNetFxStreamAdapter;
            if (sAdptr == null)
            {
                BufferedStream buffAdptr = stream as BufferedStream;
                if (buffAdptr != null)
                    sAdptr = buffAdptr.UnderlyingStream as WinRtToNetFxStreamAdapter;
            }

            // If the managed stream us actually a WinRT stream, we will unwrap it and return the original.
            // In that case we do not need to put the wrapper into the map.
            if (sAdptr != null)
            {
                object wrappedWinRtStream = sAdptr.GetWindowsRuntimeStream<object>();
                if (wrappedWinRtStream == null)
                    throw new ObjectDisposedException(nameof(stream), global::Windows.Storage.Streams.SR.ObjectDisposed_CannotPerformOperation);

#if DEBUG  // In Chk builds, verify that the original WinRT stream is correctly entered into the WinRT->NetFx map:
                AssertMapContains(s_winRtToNetFxAdapterMap, wrappedWinRtStream, sAdptr, valueMayBeWrappedInBufferedStream: true);
#endif  // DEBUG
                return wrappedWinRtStream;
            }

            // We have a real managed Stream.

            // See if the managed stream already has an adapter:
            NetFxToWinRtStreamAdapter adapter;
            bool adapterExists = s_netFxToWinRtAdapterMap.TryGetValue(stream, out adapter);

            // There is already an adapter:
            if (adapterExists)
                return adapter!;

            // We do not have an adapter for this managed stream yet and we need to create one.
            // Do that in a thread-safe manner in a separate method such that we only have to pay for the compiler allocating
            // the required closure if this code path is hit:
            return AsWindowsRuntimeStreamInternalFactoryHelper(stream);
        }


        private static NetFxToWinRtStreamAdapter AsWindowsRuntimeStreamInternalFactoryHelper(Stream stream)
        {
            Debug.Assert(stream != null);

            // Get the adapter for managed stream again (it may have been created concurrently).
            // If none exists yet, create a new one:
            NetFxToWinRtStreamAdapter adapter = s_netFxToWinRtAdapterMap.GetValue(stream, (str) => NetFxToWinRtStreamAdapter.Create(str));

            Debug.Assert(adapter != null);
            adapter.SetWonInitializationRace();

            return adapter;
        }
        #endregion NetFx-to-WinRt conversion

#endif

    }  // class WindowsRuntimeStreamExtensions
}  // namespace

// WindowsRuntimeStreamExtensions.cs

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace Windows.Storage.Streams
{
    using global::System.Diagnostics;
    using global::System.IO;
    using global::System.Runtime.ExceptionServices;
    
    using global::System.Runtime.InteropServices;
    using global::System.Runtime.InteropServices.WindowsRuntime;
    internal static class WinRtIOHelper
    {
        internal const int DefaultIOBufferSize = 0x3000;  // = 12 KBytes = 12288 Bytes


        internal static ExceptionDispatchInfo NativeExceptionToIOExceptionInfo(Exception nativeException)
        {
            // If the interop layer gave us a specific exception type, we assume it knew what it was doing.
            // If it gave us an ExternalException or a generic Exception, we assume that it hit a
            // general/unknown case and wrap it into an IOException as this is what Stream users expect.

            // We will return a captured ExceptionDispatchInfo such that we can invoke .Throw() close to where
            // nativeException was caught - this will result in the most readable call stack.

            Debug.Assert(nativeException != null);

            if (!(nativeException.GetType().Equals(typeof(Exception)) /*|| nativeException is ExternalException */))
                return ExceptionDispatchInfo.Capture(nativeException);

            // If we do not have a meaningful message, we use a general IO error message:
            string message = nativeException.Message;
            if (string.IsNullOrWhiteSpace(message))
                message = global::Windows.Storage.Streams.SR.IO_General;

            return ExceptionDispatchInfo.Capture(new IOException(message, nativeException));
        }


        internal static void EnsureResultsInUserBuffer(IBuffer userBuffer, IBuffer resultBuffer)
        {
            // Results buffer may be different from user specified buffer. If so - copy data to the user.

            Debug.Assert(userBuffer != null);
            Debug.Assert(resultBuffer != null);

            if (resultBuffer.IsSameData(userBuffer))
                return;

            resultBuffer.CopyTo(userBuffer);
            userBuffer.Length = resultBuffer.Length;
        }
    }  // class WinRtIOHelper
}  // namespace

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace Windows.Storage.Streams
{
    using global::System.Diagnostics;
    using global::System.Diagnostics.Contracts;
    using global::System.IO;
    using global::System.Runtime.InteropServices;
    using global::System.Runtime.InteropServices.WindowsRuntime;
    using global::System.Threading.Tasks;
    using global::System.Threading;
    using Windows.Foundation;
    using global::System.Diagnostics.CodeAnalysis;
    /// <summary>
    /// A <code>Stream</code> used to wrap a Windows Runtime stream to expose it as a managed steam.
    /// </summary>
    internal class WinRtToNetFxStreamAdapter : Stream, IDisposable
    {
        #region Construction

        internal static WinRtToNetFxStreamAdapter Create(object windowsruntimeStream)
        {
            if (windowsruntimeStream == null)
                throw new ArgumentNullException(nameof(windowsruntimeStream));

            bool canRead = windowsruntimeStream is IInputStream;
            bool canWrite = windowsruntimeStream is IOutputStream;
            bool canSeek = windowsruntimeStream is IRandomAccessStream;

            if (!canRead && !canWrite && !canSeek)
                throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_ObjectMustBeWinRtStreamToConvertToNetFxStream);

            // Proactively guard against a non-conforming curstomer implementations:
            if (canSeek)
            {
                IRandomAccessStream iras = (IRandomAccessStream)windowsruntimeStream;

                if (!canRead && iras.CanRead)
                    throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InstancesImplementingIRASThatCanReadMustImplementIIS);

                if (!canWrite && iras.CanWrite)
                    throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InstancesImplementingIRASThatCanWriteMustImplementIOS);

                if (!iras.CanRead)
                    canRead = false;

                if (!iras.CanWrite)
                    canWrite = false;
            }

            if (!canRead && !canWrite)
                throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_WinRtStreamCannotReadOrWrite);

            return new WinRtToNetFxStreamAdapter(windowsruntimeStream, canRead, canWrite, canSeek);
        }


        private WinRtToNetFxStreamAdapter(object winRtStream, bool canRead, bool canWrite, bool canSeek)
        {
            Debug.Assert(winRtStream != null);
            Debug.Assert(winRtStream is IInputStream || winRtStream is IOutputStream || winRtStream is IRandomAccessStream);

            Debug.Assert((canSeek && (winRtStream is IRandomAccessStream)) || (!canSeek && !(winRtStream is IRandomAccessStream)));

            Debug.Assert((canRead && (winRtStream is IInputStream))
                                 ||
                               (!canRead && (
                                    !(winRtStream is IInputStream)
                                        ||
                                    (winRtStream is IRandomAccessStream && !((IRandomAccessStream)winRtStream).CanRead)
                               ))
                             );

            Debug.Assert((canWrite && (winRtStream is IOutputStream))
                                 ||
                               (!canWrite && (
                                    !(winRtStream is IOutputStream)
                                        ||
                                    (winRtStream is IRandomAccessStream && !((IRandomAccessStream)winRtStream).CanWrite)
                               ))
                             );

            _winRtStream = winRtStream;
            _canRead = canRead;
            _canWrite = canWrite;
            _canSeek = canSeek;
        }

        #endregion Construction


        #region Instance variables

        private byte[] _oneByteBuffer = null;
        private bool _leaveUnderlyingStreamOpen = true;

        private object _winRtStream;
        private readonly bool _canRead;
        private readonly bool _canWrite;
        private readonly bool _canSeek;

        #endregion Instance variables


        #region Tools and Helpers

        /// <summary>
        /// We keep tables for mappings between managed and WinRT streams to make sure to always return the same adapter for a given underlying stream.
        /// However, in order to avoid global locks on those tables, several instances of this type may be created and then can race to be entered
        /// into the appropriate map table. All except for the winning instances will be thrown away. However, we must ensure that when the losers  are
        /// finalized, the do not dispose the underlying stream. To ensure that, we must call this method on the winner to notify it that it is safe to
        /// dispose the underlying stream.
        /// </summary>
        internal void SetWonInitializationRace()
        {
            _leaveUnderlyingStreamOpen = false;
        }


        public TWinRtStream GetWindowsRuntimeStream<TWinRtStream>() where TWinRtStream : class
        {
            object wrtStr = _winRtStream;

            if (wrtStr == null)
                return null;

            Debug.Assert(wrtStr is TWinRtStream,
                $"Attempted to get the underlying WinRT stream typed as \"{typeof(TWinRtStream)}\", " +
                $"but the underlying WinRT stream cannot be cast to that type. Its actual type is \"{wrtStr.GetType()}\".");

            return wrtStr as TWinRtStream;
        }


        private byte[] OneByteBuffer
        {
            get
            {
                byte[] obb = _oneByteBuffer;
                if (obb == null)  // benign race for multiple init
                    _oneByteBuffer = obb = new byte[1];
                return obb;
            }
        }

        private TWinRtStream EnsureNotDisposed<TWinRtStream>() where TWinRtStream : class
        {
            object wrtStr = _winRtStream;

            if (wrtStr == null)
                throw new ObjectDisposedException(global::Windows.Storage.Streams.SR.ObjectDisposed_CannotPerformOperation);

            return (wrtStr as TWinRtStream);
        }


        private void EnsureNotDisposed()
        {
            if (_winRtStream == null)
                throw new ObjectDisposedException(global::Windows.Storage.Streams.SR.ObjectDisposed_CannotPerformOperation);
        }


        private void EnsureCanRead()
        {
            if (!_canRead)
                throw new NotSupportedException(global::Windows.Storage.Streams.SR.NotSupported_CannotReadFromStream);
        }


        private void EnsureCanWrite()
        {
            if (!_canWrite)
                throw new NotSupportedException(global::Windows.Storage.Streams.SR.NotSupported_CannotWriteToStream);
        }

        #endregion Tools and Helpers


        #region Simple overrides

        protected override void Dispose(bool disposing)
        {
            // WinRT streams should implement IDisposable (IClosable in WinRT), but let's be defensive:
            if (disposing && _winRtStream != null && !_leaveUnderlyingStreamOpen)
            {
                IDisposable disposableWinRtStream = _winRtStream as IDisposable;  // benign race on winRtStream
                if (disposableWinRtStream != null)
                    disposableWinRtStream.Dispose();
            }

            _winRtStream = null;
            base.Dispose(disposing);
        }


        public override bool CanRead
        {
            [Pure]
            get
            { return (_canRead && _winRtStream != null); }
        }


        public override bool CanWrite
        {
            [Pure]
            get
            { return (_canWrite && _winRtStream != null); }
        }


        public override bool CanSeek
        {
            [Pure]
            get
            { return (_canSeek && _winRtStream != null); }
        }

        #endregion Simple overrides


        #region Length and Position functions

        public override long Length
        {
            get
            {
                IRandomAccessStream wrtStr = EnsureNotDisposed<IRandomAccessStream>();

                if (!_canSeek)
                    throw new NotSupportedException(global::Windows.Storage.Streams.SR.NotSupported_CannotUseLength_StreamNotSeekable);

                Debug.Assert(wrtStr != null);

                ulong size = wrtStr.Size;

                // These are over 8000 PetaBytes, we do not expect this to happen. However, let's be defensive:
                if (size > (ulong)long.MaxValue)
                    throw new IOException(global::Windows.Storage.Streams.SR.IO_UnderlyingWinRTStreamTooLong_CannotUseLengthOrPosition);

                return unchecked((long)size);
            }
        }


        public override long Position
        {
            get
            {
                IRandomAccessStream wrtStr = EnsureNotDisposed<IRandomAccessStream>();

                if (!_canSeek)
                    throw new NotSupportedException(global::Windows.Storage.Streams.SR.NotSupported_CannotUsePosition_StreamNotSeekable);

                Debug.Assert(wrtStr != null);

                ulong pos = wrtStr.Position;

                // These are over 8000 PetaBytes, we do not expect this to happen. However, let's be defensive:
                if (pos > (ulong)long.MaxValue)
                    throw new IOException(global::Windows.Storage.Streams.SR.IO_UnderlyingWinRTStreamTooLong_CannotUseLengthOrPosition);

                return unchecked((long)pos);
            }

            set
            {
                if (value < 0)
                    throw new ArgumentOutOfRangeException(nameof(Position), global::Windows.Storage.Streams.SR.ArgumentOutOfRange_IO_CannotSeekToNegativePosition);

                IRandomAccessStream wrtStr = EnsureNotDisposed<IRandomAccessStream>();

                if (!_canSeek)
                    throw new NotSupportedException(global::Windows.Storage.Streams.SR.NotSupported_CannotUsePosition_StreamNotSeekable);

                Debug.Assert(wrtStr != null);

                wrtStr.Seek(unchecked((ulong)value));
            }
        }


        public override long Seek(long offset, SeekOrigin origin)
        {
            IRandomAccessStream wrtStr = EnsureNotDisposed<IRandomAccessStream>();

            if (!_canSeek)
                throw new NotSupportedException(global::Windows.Storage.Streams.SR.NotSupported_CannotSeekInStream);

            Debug.Assert(wrtStr != null);

            switch (origin)
            {
                case SeekOrigin.Begin:
                    {
                        Position = offset;
                        return offset;
                    }

                case SeekOrigin.Current:
                    {
                        long curPos = Position;

                        if (long.MaxValue - curPos < offset)
                            throw new IOException(global::Windows.Storage.Streams.SR.IO_CannotSeekBeyondInt64MaxValue);

                        long newPos = curPos + offset;

                        if (newPos < 0)
                            throw new IOException(global::Windows.Storage.Streams.SR.ArgumentOutOfRange_IO_CannotSeekToNegativePosition);

                        Position = newPos;
                        return newPos;
                    }

                case SeekOrigin.End:
                    {
                        ulong size = wrtStr.Size;
                        long newPos;

                        if (size > (ulong)long.MaxValue)
                        {
                            if (offset >= 0)
                                throw new IOException(global::Windows.Storage.Streams.SR.IO_CannotSeekBeyondInt64MaxValue);

                            Debug.Assert(offset < 0);

                            ulong absOffset = (offset == long.MinValue) ? ((ulong)long.MaxValue) + 1 : (ulong)(-offset);
                            Debug.Assert(absOffset <= size);

                            ulong np = size - absOffset;
                            if (np > (ulong)long.MaxValue)
                                throw new IOException(global::Windows.Storage.Streams.SR.IO_CannotSeekBeyondInt64MaxValue);

                            newPos = (long)np;
                        }
                        else
                        {
                            Debug.Assert(size <= (ulong)long.MaxValue);

                            long s = unchecked((long)size);

                            if (long.MaxValue - s < offset)
                                throw new IOException(global::Windows.Storage.Streams.SR.IO_CannotSeekBeyondInt64MaxValue);

                            newPos = s + offset;

                            if (newPos < 0)
                                throw new IOException(global::Windows.Storage.Streams.SR.ArgumentOutOfRange_IO_CannotSeekToNegativePosition);
                        }

                        Position = newPos;
                        return newPos;
                    }

                default:
                    {
                        throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InvalidSeekOrigin, nameof(origin));
                    }
            }
        }


        public override void SetLength(long value)
        {
            if (value < 0)
                throw new ArgumentOutOfRangeException(nameof(value), global::Windows.Storage.Streams.SR.ArgumentOutOfRange_CannotResizeStreamToNegative);

            IRandomAccessStream wrtStr = EnsureNotDisposed<IRandomAccessStream>();

            if (!_canSeek)
                throw new NotSupportedException(global::Windows.Storage.Streams.SR.NotSupported_CannotSeekInStream);

            EnsureCanWrite();

            Debug.Assert(wrtStr != null);

            wrtStr.Size = unchecked((ulong)value);

            // If the length is set to a value < that the current position, then we need to set the position to that value
            // Because we can't directly set the position, we are going to seek to it.
            if (wrtStr.Size < wrtStr.Position)
                wrtStr.Seek(unchecked((ulong)value));
        }

        #endregion Length and Position functions


        #region Reading

#if !NETSTANDARD2_0
        [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
        private IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool usedByBlockingWrapper)
        {
            // This method is somewhat tricky: We could consider just calling ReadAsync (recall that Task implements IAsyncResult).
            // It would be OK for cases where BeginRead is invoked directly by the public user.
            // However, in cases where it is invoked by Read to achieve a blocking (synchronous) IO operation, the ReadAsync-approach may deadlock:
            //
            // The sync-over-async IO operation will be doing a blocking wait on the completion of the async IO operation assuming that
            // a wait handle would be signalled by the completion handler. Recall that the IAsyncInfo representing the IO operation may
            // not be free-threaded and not "free-marshalled"; it may also belong to an ASTA compartment because the underlying WinRT
            // stream lives in an ASTA compartment. The completion handler is invoked on a pool thread, i.e. in MTA.
            // That handler needs to fetch the results from the async IO operation, which requires a cross-compartment call from MTA into ASTA.
            // But because the ASTA thread is busy waiting this call will deadlock.
            // (Recall that although WaitOne pumps COM, ASTA specifically schedules calls on the outermost ?idle? pump only.)
            //
            // The solution is to make sure that:
            //  - In cases where main thread is waiting for the async IO to complete:
            //    Fetch results on the main thread after it has been signalled by the completion callback.
            //  - In cases where main thread is not waiting for the async IO to complete:
            //    Fetch results in the completion callback.
            //
            // But the Task-plumbing around IAsyncInfo.AsTask *always* fetches results in the completion handler because it has
            // no way of knowing whether or not someone is waiting. So, instead of using ReadAsync here we implement our own IAsyncResult
            // and our own completion handler which can behave differently according to whether it is being used by a blocking IO
            // operation wrapping a BeginRead/EndRead pair, or by an actual async operation based on the old Begin/End pattern.

            if (buffer == null)
                throw new ArgumentNullException(nameof(buffer));

            if (offset < 0)
                throw new ArgumentOutOfRangeException(nameof(offset));

            if (count < 0)
                throw new ArgumentOutOfRangeException(nameof(count));

            if (buffer.Length - offset < count)
                throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientSpaceInTargetBuffer);

            IInputStream wrtStr = EnsureNotDisposed<IInputStream>();
            EnsureCanRead();

            Debug.Assert(wrtStr != null);

            IBuffer userBuffer = buffer.AsBuffer(offset, count);
            IAsyncOperationWithProgress<IBuffer, uint> asyncReadOperation = wrtStr.ReadAsync(userBuffer,
                                                                                               unchecked((uint)count),
                                                                                               InputStreamOptions.Partial);

            StreamReadAsyncResult asyncResult = new StreamReadAsyncResult(asyncReadOperation, userBuffer, callback, state,
                                                                          processCompletedOperationInCallback: !usedByBlockingWrapper);

            // The StreamReadAsyncResult will set a private instance method to act as a Completed handler for asyncOperation.
            // This will cause a CCW to be created for the delegate and the delegate has a reference to its target, i.e. to
            // asyncResult, so asyncResult will not be collected. If we loose the entire AppDomain, then asyncResult and its CCW
            // will be collected but the stub will remain and the callback will fail gracefully. The underlying buffer is the only
            // item to which we expose a direct pointer and this is properly pinned using a mechanism similar to Overlapped.

            return asyncResult;
        }

        public override int EndRead(IAsyncResult asyncResult)
        {
            if (asyncResult == null)
                throw new ArgumentNullException(nameof(asyncResult));

            EnsureNotDisposed();
            EnsureCanRead();

            StreamOperationAsyncResult streamAsyncResult = asyncResult as StreamOperationAsyncResult;
            if (streamAsyncResult == null)
                throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_UnexpectedAsyncResult, nameof(asyncResult));

            streamAsyncResult.Wait();

            try
            {
                // If the async result did NOT process the async IO operation in its completion handler (i.e. check for errors,
                // cache results etc), then we need to do that processing now. This is to allow blocking-over-async IO operations.
                // See the big comment in BeginRead for details.

                if (!streamAsyncResult.ProcessCompletedOperationInCallback)
                    streamAsyncResult.ProcessCompletedOperation();

                // Rethrow errors caught in the completion callback, if any:
                if (streamAsyncResult.HasError)
                {
                    streamAsyncResult.CloseStreamOperation();
                    streamAsyncResult.ThrowCachedError();
                }

                // Done:

                long bytesCompleted = streamAsyncResult.BytesCompleted;
                Debug.Assert(bytesCompleted <= unchecked((long)int.MaxValue));

                return (int)bytesCompleted;
            }
            finally
            {
                // Closing multiple times is Ok.
                streamAsyncResult.CloseStreamOperation();
            }
        }

#if !NETSTANDARD2_0
        [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
        public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
        {
            if (buffer == null)
                throw new ArgumentNullException(nameof(buffer));

            if (offset < 0)
                throw new ArgumentOutOfRangeException(nameof(offset));

            if (count < 0)
                throw new ArgumentOutOfRangeException(nameof(count));

            if (buffer.Length - offset < count)
                throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientSpaceInTargetBuffer);

            EnsureNotDisposed();
            EnsureCanRead();

            // If already cancelled, bail early:
            cancellationToken.ThrowIfCancellationRequested();

            // State is Ok. Do the actual read:
            return ReadAsyncInternal(buffer, offset, count, cancellationToken);
        }

#if !NETSTANDARD2_0
        [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
        public override int Read(byte[] buffer, int offset, int count)
        {
            // Arguments validation and not-disposed validation are done in BeginRead.

            IAsyncResult asyncResult = BeginRead(buffer, offset, count, null, null, usedByBlockingWrapper: true);
            int bytesread = EndRead(asyncResult);
            return bytesread;
        }

#if !NETSTANDARD2_0
        [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
        public override int ReadByte()
        {
            // EnsureNotDisposed will be called in Read->BeginRead.

            byte[] oneByteArray = OneByteBuffer;

            if (0 == Read(oneByteArray, 0, 1))
                return -1;

            int value = oneByteArray[0];
            return value;
        }

        #endregion Reading


        #region Writing


        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            return BeginWrite(buffer, offset, count, callback, state, usedByBlockingWrapper: false);
        }

        private IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool usedByBlockingWrapper)
        {
            // See the large comment in BeginRead about why we are not using this.WriteAsync,
            // and instead using a custom implementation of IAsyncResult.

            if (buffer == null)
                throw new ArgumentNullException(nameof(buffer));

            if (offset < 0)
                throw new ArgumentOutOfRangeException(nameof(offset));

            if (count < 0)
                throw new ArgumentOutOfRangeException(nameof(count));

            if (buffer.Length - offset < count)
                throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);

            IOutputStream wrtStr = EnsureNotDisposed<IOutputStream>();
            EnsureCanWrite();

            Debug.Assert(wrtStr != null);

            IBuffer asyncWriteBuffer = buffer.AsBuffer(offset, count);

            IAsyncOperationWithProgress<uint, uint> asyncWriteOperation = wrtStr.WriteAsync(asyncWriteBuffer);

            StreamWriteAsyncResult asyncResult = new StreamWriteAsyncResult(asyncWriteOperation, callback, state,
                                                                            processCompletedOperationInCallback: !usedByBlockingWrapper);

            // The StreamReadAsyncResult will set a private instance method to act as a Completed handler for asyncOperation.
            // This will cause a CCW to be created for the delegate and the delegate has a reference to its target, i.e. to
            // asyncResult, so asyncResult will not be collected. If we loose the entire AppDomain, then asyncResult and its CCW
            // will be collected but the stub will remain and the callback will fail gracefully. The underlying buffer if the only
            // item to which we expose a direct pointer and this is properly pinned using a mechanism similar to Overlapped.

            return asyncResult;
        }

        public override void EndWrite(IAsyncResult asyncResult)
        {
            if (asyncResult == null)
                throw new ArgumentNullException(nameof(asyncResult));

            EnsureNotDisposed();
            EnsureCanWrite();

            StreamOperationAsyncResult streamAsyncResult = asyncResult as StreamOperationAsyncResult;
            if (streamAsyncResult == null)
                throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_UnexpectedAsyncResult, nameof(asyncResult));

            streamAsyncResult.Wait();

            try
            {
                // If the async result did NOT process the async IO operation in its completion handler (i.e. check for errors,
                // cache results etc), then we need to do that processing now. This is to allow blocking-over-async IO operations.
                // See the big comment in BeginWrite for details.

                if (!streamAsyncResult.ProcessCompletedOperationInCallback)
                    streamAsyncResult.ProcessCompletedOperation();

                // Rethrow errors caught in the completion callback, if any:
                if (streamAsyncResult.HasError)
                {
                    streamAsyncResult.CloseStreamOperation();
                    streamAsyncResult.ThrowCachedError();
                }
            }
            finally
            {
                // Closing multiple times is Ok.
                streamAsyncResult.CloseStreamOperation();
            }
        }

#if !NETSTANDARD2_0
        [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
        public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
        {
            if (buffer == null)
                throw new ArgumentNullException(nameof(buffer));

            if (offset < 0)
                throw new ArgumentOutOfRangeException(nameof(offset));

            if (count < 0)
                throw new ArgumentOutOfRangeException(nameof(count));

            if (buffer.Length - offset < count)
                throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);

            IOutputStream wrtStr = EnsureNotDisposed<IOutputStream>();
            EnsureCanWrite();

            Debug.Assert(wrtStr != null);

            // If already cancelled, bail early:
            cancellationToken.ThrowIfCancellationRequested();

            IBuffer asyncWriteBuffer = buffer.AsBuffer(offset, count);

            IAsyncOperationWithProgress<uint, uint> asyncWriteOperation = wrtStr.WriteAsync(asyncWriteBuffer);
            Task asyncWriteTask = asyncWriteOperation.AsTask(cancellationToken);

            // The underlying IBuffer is the only object to which we expose a direct pointer to native,
            // and that is properly pinned using a mechanism similar to Overlapped.

            return asyncWriteTask;
        }


        public override void Write(byte[] buffer, int offset, int count)
        {
            // Arguments validation and not-disposed validation are done in BeginWrite.

            IAsyncResult asyncResult = BeginWrite(buffer, offset, count, null, null, usedByBlockingWrapper: true);
            EndWrite(asyncResult);
        }


        public override void WriteByte(byte value)
        {
            // EnsureNotDisposed will be called in Write->BeginWrite.

            byte[] oneByteArray = OneByteBuffer;
            oneByteArray[0] = value;

            Write(oneByteArray, 0, 1);
        }

        #endregion Writing


        #region Flushing

        public override void Flush()
        {
            // See the large comment in BeginRead about why we are not using this.FlushAsync,
            // and instead using a custom implementation of IAsyncResult.

            IOutputStream wrtStr = EnsureNotDisposed<IOutputStream>();

            // Calling Flush in a non-writable stream is a no-op, not an error:
            if (!_canWrite)
                return;

            Debug.Assert(wrtStr != null);

            IAsyncOperation<bool> asyncFlushOperation = wrtStr.FlushAsync();
            StreamFlushAsyncResult asyncResult = new StreamFlushAsyncResult(asyncFlushOperation, processCompletedOperationInCallback: false);

            asyncResult.Wait();

            try
            {
                // We got signaled, so process the async Flush operation back on this thread:
                // (This is to allow blocking-over-async IO operations. See the big comment in BeginRead for details.)
                asyncResult.ProcessCompletedOperation();

                // Rethrow errors cached by the async result, if any:
                if (asyncResult.HasError)
                {
                    asyncResult.CloseStreamOperation();
                    asyncResult.ThrowCachedError();
                }
            }
            finally
            {
                // Closing multiple times is Ok.
                asyncResult.CloseStreamOperation();
            }
        }

#if !NETSTANDARD2_0
        [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
        public override Task FlushAsync(CancellationToken cancellationToken)
        {
            IOutputStream wrtStr = EnsureNotDisposed<IOutputStream>();

            // Calling Flush in a non-writable stream is a no-op, not an error:
            if (!_canWrite)
                return Task.CompletedTask;

            Debug.Assert(wrtStr != null);

            cancellationToken.ThrowIfCancellationRequested();

            IAsyncOperation<bool> asyncFlushOperation = wrtStr.FlushAsync();
            Task asyncFlushTask = asyncFlushOperation.AsTask(cancellationToken);
            return asyncFlushTask;
        }

        #endregion Flushing


        #region ReadAsyncInternal implementation
        // Moved it to the end while using Dev10 VS because it does not understand async and everything that follows looses intellisense.
        // Should move this code into the Reading regios once using Dev11 VS becomes the norm.

#if !NETSTANDARD2_0
        [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
        private async Task<int> ReadAsyncInternal(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
        {
            Debug.Assert(buffer != null);
            Debug.Assert(offset >= 0);
            Debug.Assert(count >= 0);
            Debug.Assert(buffer.Length - offset >= count);
            Debug.Assert(_canRead);

            IInputStream wrtStr = EnsureNotDisposed<IInputStream>();

            Debug.Assert(wrtStr != null);

            try
            {
                IBuffer userBuffer = buffer.AsBuffer(offset, count);
                IAsyncOperationWithProgress<IBuffer, uint> asyncReadOperation = wrtStr.ReadAsync(userBuffer,
                                                                                                   unchecked((uint)count),
                                                                                                   InputStreamOptions.Partial);

                IBuffer resultBuffer = await asyncReadOperation.AsTask(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);

                // If cancellationToken was cancelled until now, then we are currently propagating the corresponding cancellation exception.
                // (It will be correctly rethrown by the catch block below and overall we will return a cancelled task.)
                // But if the underlying operation managed to complete before it was cancelled, we want
                // the entire task to complete as well. This is ok as the continuation is very lightweight:

                if (resultBuffer == null)
                    return 0;

                WinRtIOHelper.EnsureResultsInUserBuffer(userBuffer, resultBuffer);

                Debug.Assert(resultBuffer.Length <= unchecked((uint)int.MaxValue));
                return (int)resultBuffer.Length;
            }
            catch (Exception ex)
            {
                // If the interop layer gave us an Exception, we assume that it hit a general/unknown case and wrap it into
                // an IOException as this is what Stream users expect.
                WinRtIOHelper.NativeExceptionToIOExceptionInfo(ex).Throw();
                return 0;
            }
        }
        #endregion ReadAsyncInternal implementation

    }  // class WinRtToNetFxStreamAdapter
}  // namespace

// WinRtToNetFxStreamAdapter.cs
