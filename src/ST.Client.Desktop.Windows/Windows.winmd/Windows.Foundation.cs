// This file was generated by cswinrt.exe

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using WinRT;
using WinRT.Interop;


#pragma warning disable 0169 // warning CS0169: The field '...' is never used
#pragma warning disable 0649 // warning CS0169: Field '...' is never assigned to
#pragma warning disable CA2207, CA1063, CA1033, CA1001, CA2213

namespace Windows.Foundation
{
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(FoundationContract), 65536u)]
    public delegate void AsyncActionCompletedHandler(IAsyncAction asyncInfo, AsyncStatus asyncStatus);
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(FoundationContract), 65536u)]
    public delegate void AsyncActionProgressHandler<TProgress>(IAsyncActionWithProgress<TProgress> asyncInfo, TProgress progressInfo);
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(FoundationContract), 65536u)]
    public delegate void AsyncActionWithProgressCompletedHandler<TProgress>(IAsyncActionWithProgress<TProgress> asyncInfo, AsyncStatus asyncStatus);
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(FoundationContract), 65536u)]
    public delegate void AsyncOperationCompletedHandler<TResult>(IAsyncOperation<TResult> asyncInfo, AsyncStatus asyncStatus);
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(FoundationContract), 65536u)]
    public delegate void AsyncOperationProgressHandler<TResult, TProgress>(IAsyncOperationWithProgress<TResult, TProgress> asyncInfo, TProgress progressInfo);
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(FoundationContract), 65536u)]
    public delegate void AsyncOperationWithProgressCompletedHandler<TResult, TProgress>(IAsyncOperationWithProgress<TResult, TProgress> asyncInfo, AsyncStatus asyncStatus);
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(FoundationContract), 65536u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    public enum AsyncStatus : int
    {
        Canceled = unchecked((int)0x2),
        Completed = unchecked((int)0x1),
        Error = unchecked((int)0x3),
        Started = unchecked((int)0),
    }
    [global::WinRT.WindowsRuntimeType("Windows")]

    [global::WinRT.ProjectedRuntimeClass(nameof(_default))]
    [global::WinRT.ObjectReferenceWrapper(nameof(_inner))]
    [Windows.Foundation.Metadata.ContractVersion(typeof(FoundationContract), 65536u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    public sealed class Deferral : global::System.IDisposable, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<Deferral>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private IObjectReference _inner = null;
        private readonly Lazy<IDeferral> _defaultLazy;
        private readonly Dictionary<Type, object> _lazyInterfaces;

        private IDeferral _default => _defaultLazy.Value;

        internal class _IDeferralFactory : IWinRTObject
        {
            private IObjectReference _obj;
            private IntPtr ThisPtr => _obj.ThisPtr;
            public _IDeferralFactory()
            {
                _obj = ActivationFactory<Deferral>.As(GuidGenerator.GetIID(typeof(Windows.Foundation.IDeferralFactory).GetHelperType()));
            }

            private static WeakLazy<_IDeferralFactory> _instance = new WeakLazy<_IDeferralFactory>();
            internal static _IDeferralFactory Instance => _instance.Value;

            IObjectReference IWinRTObject.NativeObject => _obj;
            bool IWinRTObject.HasUnwrappableNativeObject => false;
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();


            public unsafe IntPtr Create(DeferralCompletedHandler handler)
            {
                IObjectReference __handler = default;
                IntPtr __retval = default;
                try
                {
                    __handler = global::ABI.Windows.Foundation.DeferralCompletedHandler.CreateMarshaler(handler);
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, global::ABI.Windows.Foundation.DeferralCompletedHandler.GetAbi(__handler), out __retval));
                    return __retval;
                }
                finally
                {
                    global::ABI.Windows.Foundation.DeferralCompletedHandler.DisposeMarshaler(__handler);
                }
            }

        }

        public Deferral(DeferralCompletedHandler handler) : this(((Func<IObjectReference>)(() => {
            IntPtr ptr = (_IDeferralFactory.Instance.Create(handler));
            try
            {
                return (ComWrappersSupport.GetObjectReferenceForInterface(ptr));
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(ptr);
            }
        }))())
        {
            ComWrappersSupport.RegisterObjectForInterface(this, ThisPtr);
            ComWrappersHelper.Init(_inner, false);
        }

        public static Deferral FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<Deferral>.FromAbi(thisPtr);
        }

        internal Deferral(IObjectReference objRef)
        {
            _inner = objRef.As(GuidGenerator.GetIID(typeof(IDeferral).GetHelperType()));
            _defaultLazy = new Lazy<IDeferral>(() => (IDeferral)new SingleInterfaceOptimizedObject(typeof(IDeferral), _inner));
            _lazyInterfaces = new Dictionary<Type, object>()
            {
                {typeof(global::System.IDisposable), new Lazy<global::System.IDisposable>(() => (global::System.IDisposable)(object)new SingleInterfaceOptimizedObject(typeof(global::System.IDisposable), _inner ?? ((IWinRTObject)this).NativeObject))},
            };
        }

        public static bool operator ==(Deferral x, Deferral y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(Deferral x, Deferral y) => !(x == y);
        public bool Equals(Deferral other) => this == other;
        public override bool Equals(object obj) => obj is Deferral that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();

        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();

        private struct InterfaceTag<I>{};

        private IDeferral AsInternal(InterfaceTag<IDeferral> _) => _default;

        public void Complete() => _default.Complete();

        private global::System.IDisposable AsInternal(InterfaceTag<global::System.IDisposable> _) =>  ((Lazy<global::System.IDisposable>)_lazyInterfaces[typeof(global::System.IDisposable)]).Value;

        public void Dispose() => AsInternal(new InterfaceTag<global::System.IDisposable>()).Dispose();

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || typeof(global::WinRT.IInspectable).GUID == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs<IUnknownVftbl>(iid, out ObjectReference<IUnknownVftbl> objRef) >= 0)
            {
                using (objRef)
                {
                    ppv = objRef.GetRef();
                    return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
                }
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(FoundationContract), 65536u)]
    public delegate void DeferralCompletedHandler();
    [Windows.Foundation.Metadata.ContractVersion(262144u)]
    public enum FoundationContract
    {
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    public static class GuidHelper
    {

        internal static BaseActivationFactory _factory = new BaseActivationFactory("Windows.Foundation", "Windows.Foundation.GuidHelper");
        public static I As<I>() => _factory.AsInterface<I>();

        internal class _IGuidHelperStatics : IWinRTObject
        {
            private IObjectReference _obj;
            public _IGuidHelperStatics()
            {
                _obj = (new BaseActivationFactory("Windows.Foundation", "Windows.Foundation.GuidHelper"))._As(GuidGenerator.GetIID(typeof(Windows.Foundation.IGuidHelperStatics).GetHelperType()));
            }

            private static readonly WeakLazy<_IGuidHelperStatics> _instance = new WeakLazy<_IGuidHelperStatics>();
            internal static IGuidHelperStatics Instance => (IGuidHelperStatics)_instance.Value;

            IObjectReference IWinRTObject.NativeObject => _obj;
            bool IWinRTObject.HasUnwrappableNativeObject => false;
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();
        }

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.17763.0")]
        public static Guid CreateNewGuid() => _IGuidHelperStatics.Instance.CreateNewGuid();

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.17763.0")]
        public static bool Equals(in Guid target, in Guid value) => _IGuidHelperStatics.Instance.Equals(in target, in value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.17763.0")]
        public static Guid Empty => _IGuidHelperStatics.Instance.Empty;
    }[global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("5A648006-843A-4DA9-865B-9D26E5DFAD7B")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(FoundationContract), 65536u)]
    public interface IAsyncAction : IAsyncInfo
    {
        void GetResults();
        AsyncActionCompletedHandler Completed { get; set; }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("1F6DB258-E803-48A1-9546-EB7353398884")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(FoundationContract), 65536u)]
    public interface IAsyncActionWithProgress<TProgress> : IAsyncInfo
    {
        void GetResults();
        AsyncActionProgressHandler<TProgress> Progress { get; set; }
        AsyncActionWithProgressCompletedHandler<TProgress> Completed { get; set; }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("00000036-0000-0000-C000-000000000046")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(FoundationContract), 65536u)]
    public interface IAsyncInfo
    {
        void Cancel();
        void Close();
        global::System.Exception ErrorCode { get; }
        uint Id { get; }
        AsyncStatus Status { get; }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("B5D036D7-E297-498F-BA60-0289E76E23DD")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(FoundationContract), 65536u)]
    public interface IAsyncOperationWithProgress<TResult, TProgress> : IAsyncInfo
    {
        TResult GetResults();
        AsyncOperationProgressHandler<TResult, TProgress> Progress { get; set; }
        AsyncOperationWithProgressCompletedHandler<TResult, TProgress> Completed { get; set; }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("9FC2B0BB-E446-44E2-AA61-9CAB8F636AF2")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(FoundationContract), 65536u)]
    public interface IAsyncOperation<TResult> : IAsyncInfo
    {
        TResult GetResults();
        AsyncOperationCompletedHandler<TResult> Completed { get; set; }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("D6269732-3B7F-46A7-B40B-4FDCA2A2C693")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(FoundationContract), 65536u)]
    internal interface IDeferral : global::System.IDisposable
    {
        void Complete();
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("65A1ECC5-3FB5-4832-8CA9-F061B281D13A")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(FoundationContract), 65536u)]
    internal interface IDeferralFactory
    {
        Deferral Create(DeferralCompletedHandler handler);
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("4EDB8EE2-96DD-49A7-94F7-4607DDAB8E3C")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(UniversalApiContract), 65536u)]
    public interface IGetActivationFactory
    {
        object GetActivationFactory(string activatableClassId);
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("59C7966B-AE52-5283-AD7F-A1B9E9678ADD")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(UniversalApiContract), 458752u)]
    internal interface IGuidHelperStatics
    {
        Guid CreateNewGuid();
        bool Equals(in Guid target, in Guid value);
        Guid Empty { get; }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("FBC4DD2A-245B-11E4-AF98-689423260CF8")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(UniversalApiContract), 65536u)]
    public interface IMemoryBuffer : global::System.IDisposable
    {
        IMemoryBufferReference CreateReference();
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("FBC4DD2B-245B-11E4-AF98-689423260CF8")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(UniversalApiContract), 65536u)]
    internal interface IMemoryBufferFactory
    {
        MemoryBuffer Create(uint capacity);
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("FBC4DD29-245B-11E4-AF98-689423260CF8")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(UniversalApiContract), 65536u)]
    public interface IMemoryBufferReference : global::System.IDisposable
    {
        uint Capacity { get; }
        event TypedEventHandler<IMemoryBufferReference, object> Closed;
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("629BDBC8-D932-4FF4-96B9-8D96C5C1E858")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(FoundationContract), 65536u)]
    internal interface IPropertyValueStatics
    {
        object CreateEmpty();
        object CreateUInt8(byte value);
        object CreateInt16(short value);
        object CreateUInt16(ushort value);
        object CreateInt32(int value);
        object CreateUInt32(uint value);
        object CreateInt64(long value);
        object CreateUInt64(ulong value);
        object CreateSingle(float value);
        object CreateDouble(double value);
        object CreateChar16(char value);
        object CreateBoolean(bool value);
        object CreateString(string value);
        object CreateInspectable(object value);
        object CreateGuid(Guid value);
        object CreateDateTime(global::System.DateTimeOffset value);
        object CreateTimeSpan(global::System.TimeSpan value);
        object CreatePoint(Point value);
        object CreateSize(Size value);
        object CreateRect(Rect value);
        object CreateUInt8Array(byte[] value);
        object CreateInt16Array(short[] value);
        object CreateUInt16Array(ushort[] value);
        object CreateInt32Array(int[] value);
        object CreateUInt32Array(uint[] value);
        object CreateInt64Array(long[] value);
        object CreateUInt64Array(ulong[] value);
        object CreateSingleArray(float[] value);
        object CreateDoubleArray(double[] value);
        object CreateChar16Array(char[] value);
        object CreateBooleanArray(bool[] value);
        object CreateStringArray(string[] value);
        object CreateInspectableArray(object[] value);
        object CreateGuidArray(Guid[] value);
        object CreateDateTimeArray(global::System.DateTimeOffset[] value);
        object CreateTimeSpanArray(global::System.TimeSpan[] value);
        object CreatePointArray(Point[] value);
        object CreateSizeArray(Size[] value);
        object CreateRectArray(Rect[] value);
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("96369F54-8EB6-48F0-ABCE-C1B211E627C3")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(FoundationContract), 65536u)]
    public interface IStringable
    {
        string ToString();
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("C1D432BA-C824-4452-A7FD-512BC3BBE9A1")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(UniversalApiContract), 65536u)]
    internal interface IUriEscapeStatics
    {
        string UnescapeComponent(string toUnescape);
        string EscapeComponent(string toEscape);
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("9E365E57-48B2-4160-956F-C7385120BBFC")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(UniversalApiContract), 65536u)]
    internal interface IUriRuntimeClass
    {
        bool Equals(global::System.Uri pUri);
        global::System.Uri CombineUri(string relativeUri);
        string AbsoluteUri { get; }
        string DisplayUri { get; }
        string Domain { get; }
        string Extension { get; }
        string Fragment { get; }
        string Host { get; }
        string Password { get; }
        string Path { get; }
        int Port { get; }
        string Query { get; }
        WwwFormUrlDecoder QueryParsed { get; }
        string RawUri { get; }
        string SchemeName { get; }
        bool Suspicious { get; }
        string UserName { get; }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("44A9796F-723E-4FDF-A218-033E75B0C084")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(UniversalApiContract), 65536u)]
    internal interface IUriRuntimeClassFactory
    {
        global::System.Uri CreateUri(string uri);
        global::System.Uri CreateWithRelativeUri(string baseUri, string relativeUri);
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("758D9661-221C-480F-A339-50656673F46F")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(UniversalApiContract), 65536u)]
    internal interface IUriRuntimeClassWithAbsoluteCanonicalUri
    {
        string AbsoluteCanonicalUri { get; }
        string DisplayIri { get; }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("125E7431-F678-4E8E-B670-20A9B06C512D")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(UniversalApiContract), 65536u)]
    public interface IWwwFormUrlDecoderEntry
    {
        string Name { get; }
        string Value { get; }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("D45A0451-F225-4542-9296-0E1DF5D254DF")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(UniversalApiContract), 65536u)]
    internal interface IWwwFormUrlDecoderRuntimeClass : global::System.Collections.Generic.IEnumerable<IWwwFormUrlDecoderEntry>, global::System.Collections.Generic.IReadOnlyList<IWwwFormUrlDecoderEntry>
    {
        string GetFirstValueByName(string name);
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Guid("5B8C6B3D-24AE-41B5-A1BF-F0C3D544845B")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(UniversalApiContract), 65536u)]
    internal interface IWwwFormUrlDecoderRuntimeClassFactory
    {
        WwwFormUrlDecoder CreateWwwFormUrlDecoder(string query);
    }
    [global::WinRT.WindowsRuntimeType("Windows")]

    [global::WinRT.ProjectedRuntimeClass(nameof(_default))]
    [global::WinRT.ObjectReferenceWrapper(nameof(_inner))]
    [Windows.Foundation.Metadata.ContractVersion(typeof(UniversalApiContract), 65536u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    public sealed class MemoryBuffer : IMemoryBuffer, global::System.IDisposable, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<MemoryBuffer>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private IObjectReference _inner = null;
        private readonly Lazy<IMemoryBuffer> _defaultLazy;
        private readonly Dictionary<Type, object> _lazyInterfaces;

        private IMemoryBuffer _default => _defaultLazy.Value;

        internal class _IMemoryBufferFactory : IWinRTObject
        {
            private IObjectReference _obj;
            private IntPtr ThisPtr => _obj.ThisPtr;
            public _IMemoryBufferFactory()
            {
                _obj = ActivationFactory<MemoryBuffer>.As(GuidGenerator.GetIID(typeof(Windows.Foundation.IMemoryBufferFactory).GetHelperType()));
            }

            private static WeakLazy<_IMemoryBufferFactory> _instance = new WeakLazy<_IMemoryBufferFactory>();
            internal static _IMemoryBufferFactory Instance => _instance.Value;

            IObjectReference IWinRTObject.NativeObject => _obj;
            bool IWinRTObject.HasUnwrappableNativeObject => false;
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();


            public unsafe IntPtr Create(uint capacity)
            {
                IntPtr __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint, out IntPtr, int>**)ThisPtr)[6](ThisPtr, capacity, out __retval));
                return __retval;
            }

        }

        public MemoryBuffer(uint capacity) : this(((Func<IObjectReference>)(() => {
            IntPtr ptr = (_IMemoryBufferFactory.Instance.Create(capacity));
            try
            {
                return (ComWrappersSupport.GetObjectReferenceForInterface(ptr));
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(ptr);
            }
        }))())
        {
            ComWrappersSupport.RegisterObjectForInterface(this, ThisPtr);
            ComWrappersHelper.Init(_inner, false);
        }

        public static MemoryBuffer FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<MemoryBuffer>.FromAbi(thisPtr);
        }

        internal MemoryBuffer(IObjectReference objRef)
        {
            _inner = objRef.As(GuidGenerator.GetIID(typeof(IMemoryBuffer).GetHelperType()));
            _defaultLazy = new Lazy<IMemoryBuffer>(() => (IMemoryBuffer)new SingleInterfaceOptimizedObject(typeof(IMemoryBuffer), _inner));
            _lazyInterfaces = new Dictionary<Type, object>()
            {
                {typeof(global::System.IDisposable), new Lazy<global::System.IDisposable>(() => (global::System.IDisposable)(object)new SingleInterfaceOptimizedObject(typeof(global::System.IDisposable), _inner ?? ((IWinRTObject)this).NativeObject))},
            };
        }

        public static bool operator ==(MemoryBuffer x, MemoryBuffer y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(MemoryBuffer x, MemoryBuffer y) => !(x == y);
        public bool Equals(MemoryBuffer other) => this == other;
        public override bool Equals(object obj) => obj is MemoryBuffer that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();

        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();

        private struct InterfaceTag<I>{};

        private IMemoryBuffer AsInternal(InterfaceTag<IMemoryBuffer> _) => _default;

        public IMemoryBufferReference CreateReference() => _default.CreateReference();

        IMemoryBufferReference IMemoryBuffer.CreateReference() => CreateReference();
        private global::System.IDisposable AsInternal(InterfaceTag<global::System.IDisposable> _) =>  ((Lazy<global::System.IDisposable>)_lazyInterfaces[typeof(global::System.IDisposable)]).Value;

        public void Dispose() => AsInternal(new InterfaceTag<global::System.IDisposable>()).Dispose();

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || typeof(global::WinRT.IInspectable).GUID == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs<IUnknownVftbl>(iid, out ObjectReference<IUnknownVftbl> objRef) >= 0)
            {
                using (objRef)
                {
                    ppv = objRef.GetRef();
                    return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
                }
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(FoundationContract), 65536u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    public enum PropertyType : int
    {
        Empty = unchecked((int)0),
        UInt8 = unchecked((int)0x1),
        Int16 = unchecked((int)0x2),
        UInt16 = unchecked((int)0x3),
        Int32 = unchecked((int)0x4),
        UInt32 = unchecked((int)0x5),
        Int64 = unchecked((int)0x6),
        UInt64 = unchecked((int)0x7),
        Single = unchecked((int)0x8),
        Double = unchecked((int)0x9),
        Char16 = unchecked((int)0xa),
        Boolean = unchecked((int)0xb),
        String = unchecked((int)0xc),
        Inspectable = unchecked((int)0xd),
        DateTime = unchecked((int)0xe),
        TimeSpan = unchecked((int)0xf),
        Guid = unchecked((int)0x10),
        Point = unchecked((int)0x11),
        Size = unchecked((int)0x12),
        Rect = unchecked((int)0x13),
        OtherType = unchecked((int)0x14),
        UInt8Array = unchecked((int)0x401),
        Int16Array = unchecked((int)0x402),
        UInt16Array = unchecked((int)0x403),
        Int32Array = unchecked((int)0x404),
        UInt32Array = unchecked((int)0x405),
        Int64Array = unchecked((int)0x406),
        UInt64Array = unchecked((int)0x407),
        SingleArray = unchecked((int)0x408),
        DoubleArray = unchecked((int)0x409),
        Char16Array = unchecked((int)0x40a),
        BooleanArray = unchecked((int)0x40b),
        StringArray = unchecked((int)0x40c),
        InspectableArray = unchecked((int)0x40d),
        DateTimeArray = unchecked((int)0x40e),
        TimeSpanArray = unchecked((int)0x40f),
        GuidArray = unchecked((int)0x410),
        PointArray = unchecked((int)0x411),
        SizeArray = unchecked((int)0x412),
        RectArray = unchecked((int)0x413),
        OtherTypeArray = unchecked((int)0x414),
    }
    [global::WinRT.WindowsRuntimeType("Windows")]
    public static class PropertyValue
    {

        internal static BaseActivationFactory _factory = new BaseActivationFactory("Windows.Foundation", "Windows.Foundation.PropertyValue");
        public static I As<I>() => _factory.AsInterface<I>();

        internal class _IPropertyValueStatics : IWinRTObject
        {
            private IObjectReference _obj;
            public _IPropertyValueStatics()
            {
                _obj = (new BaseActivationFactory("Windows.Foundation", "Windows.Foundation.PropertyValue"))._As(GuidGenerator.GetIID(typeof(Windows.Foundation.IPropertyValueStatics).GetHelperType()));
            }

            private static readonly WeakLazy<_IPropertyValueStatics> _instance = new WeakLazy<_IPropertyValueStatics>();
            internal static IPropertyValueStatics Instance => (IPropertyValueStatics)_instance.Value;

            IObjectReference IWinRTObject.NativeObject => _obj;
            bool IWinRTObject.HasUnwrappableNativeObject => false;
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();
        }

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateEmpty() => _IPropertyValueStatics.Instance.CreateEmpty();

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateUInt8(byte value) => _IPropertyValueStatics.Instance.CreateUInt8(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateInt16(short value) => _IPropertyValueStatics.Instance.CreateInt16(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateUInt16(ushort value) => _IPropertyValueStatics.Instance.CreateUInt16(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateInt32(int value) => _IPropertyValueStatics.Instance.CreateInt32(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateUInt32(uint value) => _IPropertyValueStatics.Instance.CreateUInt32(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateInt64(long value) => _IPropertyValueStatics.Instance.CreateInt64(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateUInt64(ulong value) => _IPropertyValueStatics.Instance.CreateUInt64(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateSingle(float value) => _IPropertyValueStatics.Instance.CreateSingle(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateDouble(double value) => _IPropertyValueStatics.Instance.CreateDouble(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateChar16(char value) => _IPropertyValueStatics.Instance.CreateChar16(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateBoolean(bool value) => _IPropertyValueStatics.Instance.CreateBoolean(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateString(string value) => _IPropertyValueStatics.Instance.CreateString(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateInspectable(object value) => _IPropertyValueStatics.Instance.CreateInspectable(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateGuid(Guid value) => _IPropertyValueStatics.Instance.CreateGuid(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateDateTime(global::System.DateTimeOffset value) => _IPropertyValueStatics.Instance.CreateDateTime(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateTimeSpan(global::System.TimeSpan value) => _IPropertyValueStatics.Instance.CreateTimeSpan(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreatePoint(Point value) => _IPropertyValueStatics.Instance.CreatePoint(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateSize(Size value) => _IPropertyValueStatics.Instance.CreateSize(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateRect(Rect value) => _IPropertyValueStatics.Instance.CreateRect(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateUInt8Array(byte[] value) => _IPropertyValueStatics.Instance.CreateUInt8Array(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateInt16Array(short[] value) => _IPropertyValueStatics.Instance.CreateInt16Array(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateUInt16Array(ushort[] value) => _IPropertyValueStatics.Instance.CreateUInt16Array(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateInt32Array(int[] value) => _IPropertyValueStatics.Instance.CreateInt32Array(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateUInt32Array(uint[] value) => _IPropertyValueStatics.Instance.CreateUInt32Array(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateInt64Array(long[] value) => _IPropertyValueStatics.Instance.CreateInt64Array(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateUInt64Array(ulong[] value) => _IPropertyValueStatics.Instance.CreateUInt64Array(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateSingleArray(float[] value) => _IPropertyValueStatics.Instance.CreateSingleArray(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateDoubleArray(double[] value) => _IPropertyValueStatics.Instance.CreateDoubleArray(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateChar16Array(char[] value) => _IPropertyValueStatics.Instance.CreateChar16Array(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateBooleanArray(bool[] value) => _IPropertyValueStatics.Instance.CreateBooleanArray(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateStringArray(string[] value) => _IPropertyValueStatics.Instance.CreateStringArray(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateInspectableArray(object[] value) => _IPropertyValueStatics.Instance.CreateInspectableArray(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateGuidArray(Guid[] value) => _IPropertyValueStatics.Instance.CreateGuidArray(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateDateTimeArray(global::System.DateTimeOffset[] value) => _IPropertyValueStatics.Instance.CreateDateTimeArray(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateTimeSpanArray(global::System.TimeSpan[] value) => _IPropertyValueStatics.Instance.CreateTimeSpanArray(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreatePointArray(Point[] value) => _IPropertyValueStatics.Instance.CreatePointArray(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateSizeArray(Size[] value) => _IPropertyValueStatics.Instance.CreateSizeArray(value);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
        public static object CreateRectArray(Rect[] value) => _IPropertyValueStatics.Instance.CreateRectArray(value);
    }[global::WinRT.WindowsRuntimeType("Windows")]
    [Windows.Foundation.Metadata.ContractVersion(typeof(FoundationContract), 65536u)]
    public delegate void TypedEventHandler<TSender, TResult>(TSender sender, TResult args);
    [Windows.Foundation.Metadata.ContractVersion(655360u)]
    public enum UniversalApiContract
    {
    }
    [global::WinRT.WindowsRuntimeType("Windows")]

    [global::WinRT.ProjectedRuntimeClass(nameof(_default))]
    [global::WinRT.ObjectReferenceWrapper(nameof(_inner))]
    [Windows.Foundation.Metadata.ContractVersion(typeof(UniversalApiContract), 65536u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    public sealed class WwwFormUrlDecoder : global::System.Collections.Generic.IReadOnlyList<IWwwFormUrlDecoderEntry>, global::System.Collections.Generic.IEnumerable<IWwwFormUrlDecoderEntry>, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<WwwFormUrlDecoder>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private IObjectReference _inner = null;
        private readonly Lazy<IWwwFormUrlDecoderRuntimeClass> _defaultLazy;
        private readonly Dictionary<Type, object> _lazyInterfaces;

        private IWwwFormUrlDecoderRuntimeClass _default => _defaultLazy.Value;

        internal class _IWwwFormUrlDecoderRuntimeClassFactory : IWinRTObject
        {
            private IObjectReference _obj;
            private IntPtr ThisPtr => _obj.ThisPtr;
            public _IWwwFormUrlDecoderRuntimeClassFactory()
            {
                _obj = ActivationFactory<WwwFormUrlDecoder>.As(GuidGenerator.GetIID(typeof(Windows.Foundation.IWwwFormUrlDecoderRuntimeClassFactory).GetHelperType()));
            }

            private static WeakLazy<_IWwwFormUrlDecoderRuntimeClassFactory> _instance = new WeakLazy<_IWwwFormUrlDecoderRuntimeClassFactory>();
            internal static _IWwwFormUrlDecoderRuntimeClassFactory Instance => _instance.Value;

            IObjectReference IWinRTObject.NativeObject => _obj;
            bool IWinRTObject.HasUnwrappableNativeObject => false;
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();


            public unsafe IntPtr CreateWwwFormUrlDecoder(string query)
            {
                MarshalString __query = default;
                IntPtr __retval = default;
                try
                {
                    __query = MarshalString.CreateMarshaler(query);
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, MarshalString.GetAbi(__query), out __retval));
                    return __retval;
                }
                finally
                {
                    MarshalString.DisposeMarshaler(__query);
                }
            }

        }

        public WwwFormUrlDecoder(string query) : this(((Func<IObjectReference>)(() => {
            IntPtr ptr = (_IWwwFormUrlDecoderRuntimeClassFactory.Instance.CreateWwwFormUrlDecoder(query));
            try
            {
                return (ComWrappersSupport.GetObjectReferenceForInterface(ptr));
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(ptr);
            }
        }))())
        {
            ComWrappersSupport.RegisterObjectForInterface(this, ThisPtr);
            ComWrappersHelper.Init(_inner, false);
        }

        public static WwwFormUrlDecoder FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<WwwFormUrlDecoder>.FromAbi(thisPtr);
        }

        internal WwwFormUrlDecoder(IObjectReference objRef)
        {
            _inner = objRef.As(GuidGenerator.GetIID(typeof(IWwwFormUrlDecoderRuntimeClass).GetHelperType()));
            _defaultLazy = new Lazy<IWwwFormUrlDecoderRuntimeClass>(() => (IWwwFormUrlDecoderRuntimeClass)new SingleInterfaceOptimizedObject(typeof(IWwwFormUrlDecoderRuntimeClass), _inner));
            _lazyInterfaces = new Dictionary<Type, object>()
            {
                {typeof(global::System.Collections.Generic.IReadOnlyList<IWwwFormUrlDecoderEntry>), new Lazy<global::System.Collections.Generic.IReadOnlyList<IWwwFormUrlDecoderEntry>>(() => (global::System.Collections.Generic.IReadOnlyList<IWwwFormUrlDecoderEntry>)(object)new SingleInterfaceOptimizedObject(typeof(global::System.Collections.Generic.IReadOnlyList<IWwwFormUrlDecoderEntry>), _inner ?? ((IWinRTObject)this).NativeObject))},
                {typeof(global::System.Collections.Generic.IEnumerable<IWwwFormUrlDecoderEntry>), new Lazy<global::System.Collections.Generic.IEnumerable<IWwwFormUrlDecoderEntry>>(() => (global::System.Collections.Generic.IEnumerable<IWwwFormUrlDecoderEntry>)(object)new SingleInterfaceOptimizedObject(typeof(global::System.Collections.Generic.IEnumerable<IWwwFormUrlDecoderEntry>), _inner ?? ((IWinRTObject)this).NativeObject))},
            };
        }

        public static bool operator ==(WwwFormUrlDecoder x, WwwFormUrlDecoder y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(WwwFormUrlDecoder x, WwwFormUrlDecoder y) => !(x == y);
        public bool Equals(WwwFormUrlDecoder other) => this == other;
        public override bool Equals(object obj) => obj is WwwFormUrlDecoder that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();

        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();

        private struct InterfaceTag<I>{};

        private IWwwFormUrlDecoderRuntimeClass AsInternal(InterfaceTag<IWwwFormUrlDecoderRuntimeClass> _) => _default;

        public string GetFirstValueByName(string name) => _default.GetFirstValueByName(name);

        private global::System.Collections.Generic.IReadOnlyList<IWwwFormUrlDecoderEntry> AsInternal(InterfaceTag<global::System.Collections.Generic.IReadOnlyList<IWwwFormUrlDecoderEntry>> _) =>  ((Lazy<global::System.Collections.Generic.IReadOnlyList<IWwwFormUrlDecoderEntry>>)_lazyInterfaces[typeof(global::System.Collections.Generic.IReadOnlyList<IWwwFormUrlDecoderEntry>)]).Value;

        public int Count => AsInternal(new InterfaceTag<global::System.Collections.Generic.IReadOnlyList<IWwwFormUrlDecoderEntry>>()).Count;
        [global::System.Runtime.CompilerServices.IndexerName("ReadOnlyListItem")]
        public IWwwFormUrlDecoderEntry this[int index] => AsInternal(new InterfaceTag<global::System.Collections.Generic.IReadOnlyList<IWwwFormUrlDecoderEntry>>())[index];

        private global::System.Collections.Generic.IEnumerable<IWwwFormUrlDecoderEntry> AsInternal(InterfaceTag<global::System.Collections.Generic.IEnumerable<IWwwFormUrlDecoderEntry>> _) =>  ((Lazy<global::System.Collections.Generic.IEnumerable<IWwwFormUrlDecoderEntry>>)_lazyInterfaces[typeof(global::System.Collections.Generic.IEnumerable<IWwwFormUrlDecoderEntry>)]).Value;

        public IEnumerator<IWwwFormUrlDecoderEntry> GetEnumerator() => AsInternal(new InterfaceTag<global::System.Collections.Generic.IEnumerable<IWwwFormUrlDecoderEntry>>()).GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || typeof(global::WinRT.IInspectable).GUID == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs<IUnknownVftbl>(iid, out ObjectReference<IUnknownVftbl> objRef) >= 0)
            {
                using (objRef)
                {
                    ppv = objRef.GetRef();
                    return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
                }
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows")]

    [global::WinRT.ProjectedRuntimeClass(nameof(_default))]
    [global::WinRT.ObjectReferenceWrapper(nameof(_inner))]
    [Windows.Foundation.Metadata.ContractVersion(typeof(UniversalApiContract), 65536u)]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    public sealed class WwwFormUrlDecoderEntry : IWwwFormUrlDecoderEntry, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<WwwFormUrlDecoderEntry>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private IObjectReference _inner = null;
        private readonly Lazy<IWwwFormUrlDecoderEntry> _defaultLazy;
        private readonly Dictionary<Type, object> _lazyInterfaces;

        private IWwwFormUrlDecoderEntry _default => _defaultLazy.Value;

        public static WwwFormUrlDecoderEntry FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<WwwFormUrlDecoderEntry>.FromAbi(thisPtr);
        }

        internal WwwFormUrlDecoderEntry(IObjectReference objRef)
        {
            _inner = objRef.As(GuidGenerator.GetIID(typeof(IWwwFormUrlDecoderEntry).GetHelperType()));
            _defaultLazy = new Lazy<IWwwFormUrlDecoderEntry>(() => (IWwwFormUrlDecoderEntry)new SingleInterfaceOptimizedObject(typeof(IWwwFormUrlDecoderEntry), _inner));
            _lazyInterfaces = new Dictionary<Type, object>()
            {
            };
        }

        public static bool operator ==(WwwFormUrlDecoderEntry x, WwwFormUrlDecoderEntry y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(WwwFormUrlDecoderEntry x, WwwFormUrlDecoderEntry y) => !(x == y);
        public bool Equals(WwwFormUrlDecoderEntry other) => this == other;
        public override bool Equals(object obj) => obj is WwwFormUrlDecoderEntry that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();

        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();

        private struct InterfaceTag<I>{};

        private IWwwFormUrlDecoderEntry AsInternal(InterfaceTag<IWwwFormUrlDecoderEntry> _) => _default;

        string IWwwFormUrlDecoderEntry.Name {get => Name; }
        string IWwwFormUrlDecoderEntry.Value {get => Value; }
        public string Name => _default.Name;

        public string Value => _default.Value;

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || typeof(global::WinRT.IInspectable).GUID == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs<IUnknownVftbl>(iid, out ObjectReference<IUnknownVftbl> objRef) >= 0)
            {
                using (objRef)
                {
                    ppv = objRef.GetRef();
                    return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
                }
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
}

#pragma warning disable CA1416
namespace ABI.Windows.Foundation
{
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [Guid("A4ED5C81-76C9-40BD-8BE6-B1D90FB20AE7")]
    public static class AsyncActionCompletedHandler
    {

        private static readonly global::WinRT.Interop.IDelegateVftbl AbiToProjectionVftable;
        public static readonly IntPtr AbiToProjectionVftablePtr;

        static unsafe AsyncActionCompletedHandler()
        {
            AbiToProjectionVftable = new global::WinRT.Interop.IDelegateVftbl
            {
                IUnknownVftbl = global::WinRT.Interop.IUnknownVftbl.AbiToProjectionVftbl,
                Invoke = (IntPtr)(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, global::Windows.Foundation.AsyncStatus, int>)&Do_Abi_Invoke
            };
            var nativeVftbl = ComWrappersSupport.AllocateVtableMemory(typeof(AsyncActionCompletedHandler), Marshal.SizeOf<global::WinRT.Interop.IDelegateVftbl>());
            Marshal.StructureToPtr(AbiToProjectionVftable, nativeVftbl, false);
            AbiToProjectionVftablePtr = nativeVftbl;
        }

        public static unsafe IObjectReference CreateMarshaler(global::Windows.Foundation.AsyncActionCompletedHandler managedDelegate) => 
        managedDelegate is null ? null : MarshalDelegate.CreateMarshaler(managedDelegate, GuidGenerator.GetIID(typeof(AsyncActionCompletedHandler)));

        public static IntPtr GetAbi(IObjectReference value) => MarshalInterfaceHelper<global::Windows.Foundation.AsyncActionCompletedHandler>.GetAbi(value);

        public static unsafe global::Windows.Foundation.AsyncActionCompletedHandler FromAbi(IntPtr nativeDelegate)
        {
            var abiDelegate = ObjectReference<IDelegateVftbl>.FromAbi(nativeDelegate);
            return abiDelegate is null ? null : (global::Windows.Foundation.AsyncActionCompletedHandler)ComWrappersSupport.TryRegisterObjectForInterface(new global::Windows.Foundation.AsyncActionCompletedHandler(new NativeDelegateWrapper(abiDelegate).Invoke), nativeDelegate);
        }

        [global::WinRT.ObjectReferenceWrapper(nameof(_nativeDelegate))]
        #if NETSTANDARD2_0
        private class NativeDelegateWrapper
        #else
        private class NativeDelegateWrapper : IWinRTObject
        #endif
        {
            private readonly ObjectReference<global::WinRT.Interop.IDelegateVftbl> _nativeDelegate;
            #if NETSTANDARD2_0
            private readonly AgileReference _agileReference = default;
            #endif

            public NativeDelegateWrapper(ObjectReference<global::WinRT.Interop.IDelegateVftbl> nativeDelegate)
            {
                _nativeDelegate = nativeDelegate;
                #if NETSTANDARD2_0
                if (_nativeDelegate.TryAs<ABI.WinRT.Interop.IAgileObject.Vftbl>(out var objRef) < 0)
                {
                    _agileReference = new AgileReference(_nativeDelegate);
                }
                #else
                if (_nativeDelegate.TryAs<IUnknownVftbl>(IAgileObject.IID, out var objRef) < 0)
                {
                    var agileReference = new AgileReference(_nativeDelegate);
                    ((IWinRTObject)this).AdditionalTypeData.TryAdd(typeof(AgileReference).TypeHandle, agileReference);
                }
                #endif
                else
                {
                    objRef.Dispose();
                }
            }

            #if !NETSTANDARD2_0
            IObjectReference IWinRTObject.NativeObject => _nativeDelegate;
            bool IWinRTObject.HasUnwrappableNativeObject => true;
            global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();
            #endif

            public unsafe void Invoke(global::Windows.Foundation.IAsyncAction asyncInfo, global::Windows.Foundation.AsyncStatus asyncStatus)
            {
                #if NETSTANDARD2_0
                var agileReference = _agileReference;
                #else
                var agileReference = ((IWinRTObject)this).AdditionalTypeData.TryGetValue(typeof(AgileReference).TypeHandle, out var agileObj) ? (AgileReference)agileObj : null;
                #endif
                using var agileDelegate = agileReference?.Get()?.As<global::WinRT.Interop.IDelegateVftbl>(GuidGenerator.GetIID(typeof(AsyncActionCompletedHandler))); 
                var delegateToInvoke = agileDelegate ?? _nativeDelegate;
                IntPtr ThisPtr = delegateToInvoke.ThisPtr;
                var abiInvoke = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, global::Windows.Foundation.AsyncStatus, int>)(delegateToInvoke.Vftbl.Invoke);
                IObjectReference __asyncInfo = default;
                try
                {
                    __asyncInfo = MarshalInterface<global::Windows.Foundation.IAsyncAction>.CreateMarshaler(asyncInfo);
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR(abiInvoke(ThisPtr, MarshalInterface<global::Windows.Foundation.IAsyncAction>.GetAbi(__asyncInfo), asyncStatus));
                }
                finally
                {
                    MarshalInterface<global::Windows.Foundation.IAsyncAction>.DisposeMarshaler(__asyncInfo);
                }

            }
        }

        public static IntPtr FromManaged(global::Windows.Foundation.AsyncActionCompletedHandler managedDelegate) => CreateMarshaler(managedDelegate)?.GetRef() ?? IntPtr.Zero;

        public static void DisposeMarshaler(IObjectReference value) => MarshalInterfaceHelper<global::Windows.Foundation.AsyncActionCompletedHandler>.DisposeMarshaler(value);

        public static void DisposeAbi(IntPtr abi) => MarshalInterfaceHelper<global::Windows.Foundation.AsyncActionCompletedHandler>.DisposeAbi(abi);

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_Invoke(IntPtr thisPtr, IntPtr asyncInfo, global::Windows.Foundation.AsyncStatus asyncStatus)
        {


            try
            {
                global::WinRT.ComWrappersSupport.MarshalDelegateInvoke(thisPtr, (global::Windows.Foundation.AsyncActionCompletedHandler invoke) =>
                {
                    invoke(MarshalInterface<global::Windows.Foundation.IAsyncAction>.FromAbi(asyncInfo), asyncStatus);
                });

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
    }

    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [Guid("6D844858-0CFF-4590-AE89-95A5A5C8B4B8")]
    public static class AsyncActionProgressHandler<TProgress>
    {
        public static Guid PIID = GuidGenerator.CreateIID(typeof(global::Windows.Foundation.AsyncActionProgressHandler<TProgress>));
        private static readonly Type Abi_Invoke_Type = Expression.GetDelegateType(new Type[] { typeof(void*), typeof(IntPtr), Marshaler<TProgress>.AbiType, typeof(int) });

        private static readonly global::WinRT.Interop.IDelegateVftbl AbiToProjectionVftable;
        public static readonly IntPtr AbiToProjectionVftablePtr;

        static unsafe AsyncActionProgressHandler()
        {
            AbiInvokeDelegate = global::System.Delegate.CreateDelegate(Abi_Invoke_Type, typeof(AsyncActionProgressHandler<TProgress>).GetMethod(nameof(Do_Abi_Invoke), BindingFlags.Static | BindingFlags.NonPublic).MakeGenericMethod(new Type[]{ Marshaler<TProgress>.AbiType })
            );
            AbiToProjectionVftable = new global::WinRT.Interop.IDelegateVftbl
            {
                IUnknownVftbl = global::WinRT.Interop.IUnknownVftbl.AbiToProjectionVftbl,
                Invoke = Marshal.GetFunctionPointerForDelegate(AbiInvokeDelegate)
            };
            var nativeVftbl = ComWrappersSupport.AllocateVtableMemory(typeof(AsyncActionProgressHandler<TProgress>), Marshal.SizeOf<global::WinRT.Interop.IDelegateVftbl>());
            Marshal.StructureToPtr(AbiToProjectionVftable, nativeVftbl, false);
            AbiToProjectionVftablePtr = nativeVftbl;
        }

        public static global::System.Delegate AbiInvokeDelegate { get; }

        public static unsafe IObjectReference CreateMarshaler(global::Windows.Foundation.AsyncActionProgressHandler<TProgress> managedDelegate) => 
        managedDelegate is null ? null : MarshalDelegate.CreateMarshaler(managedDelegate, GuidGenerator.GetIID(typeof(AsyncActionProgressHandler<TProgress>)));

        public static IntPtr GetAbi(IObjectReference value) => MarshalInterfaceHelper<global::Windows.Foundation.AsyncActionProgressHandler<TProgress>>.GetAbi(value);

        public static unsafe global::Windows.Foundation.AsyncActionProgressHandler<TProgress> FromAbi(IntPtr nativeDelegate)
        {
            var abiDelegate = ObjectReference<IDelegateVftbl>.FromAbi(nativeDelegate);
            return abiDelegate is null ? null : (global::Windows.Foundation.AsyncActionProgressHandler<TProgress>)ComWrappersSupport.TryRegisterObjectForInterface(new global::Windows.Foundation.AsyncActionProgressHandler<TProgress>(new NativeDelegateWrapper(abiDelegate).Invoke), nativeDelegate);
        }

        [global::WinRT.ObjectReferenceWrapper(nameof(_nativeDelegate))]
        #if NETSTANDARD2_0
        private class NativeDelegateWrapper
        #else
        private class NativeDelegateWrapper : IWinRTObject
        #endif
        {
            private readonly ObjectReference<global::WinRT.Interop.IDelegateVftbl> _nativeDelegate;
            #if NETSTANDARD2_0
            private readonly AgileReference _agileReference = default;
            #endif

            public NativeDelegateWrapper(ObjectReference<global::WinRT.Interop.IDelegateVftbl> nativeDelegate)
            {
                _nativeDelegate = nativeDelegate;
                #if NETSTANDARD2_0
                if (_nativeDelegate.TryAs<ABI.WinRT.Interop.IAgileObject.Vftbl>(out var objRef) < 0)
                {
                    _agileReference = new AgileReference(_nativeDelegate);
                }
                #else
                if (_nativeDelegate.TryAs<IUnknownVftbl>(IAgileObject.IID, out var objRef) < 0)
                {
                    var agileReference = new AgileReference(_nativeDelegate);
                    ((IWinRTObject)this).AdditionalTypeData.TryAdd(typeof(AgileReference).TypeHandle, agileReference);
                }
                #endif
                else
                {
                    objRef.Dispose();
                }
            }

            #if !NETSTANDARD2_0
            IObjectReference IWinRTObject.NativeObject => _nativeDelegate;
            bool IWinRTObject.HasUnwrappableNativeObject => true;
            global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();
            #endif

            public unsafe void Invoke(global::Windows.Foundation.IAsyncActionWithProgress<TProgress> asyncInfo, TProgress progressInfo)
            {
                #if NETSTANDARD2_0
                var agileReference = _agileReference;
                #else
                var agileReference = ((IWinRTObject)this).AdditionalTypeData.TryGetValue(typeof(AgileReference).TypeHandle, out var agileObj) ? (AgileReference)agileObj : null;
                #endif
                using var agileDelegate = agileReference?.Get()?.As<global::WinRT.Interop.IDelegateVftbl>(GuidGenerator.GetIID(typeof(AsyncActionProgressHandler<TProgress>))); 
                var delegateToInvoke = agileDelegate ?? _nativeDelegate;
                IntPtr ThisPtr = delegateToInvoke.ThisPtr;
                var abiInvoke = Marshal.GetDelegateForFunctionPointer(delegateToInvoke.Vftbl.Invoke, Abi_Invoke_Type);
                IObjectReference __asyncInfo = default;
                object __progressInfo = default;
                var __params = new object[]{ ThisPtr, null, null };
                try
                {
                    __asyncInfo = MarshalInterface<global::Windows.Foundation.IAsyncActionWithProgress<TProgress>>.CreateMarshaler(asyncInfo);
                    __params[1] = MarshalInterface<global::Windows.Foundation.IAsyncActionWithProgress<TProgress>>.GetAbi(__asyncInfo);
                    __progressInfo = Marshaler<TProgress>.CreateMarshaler(progressInfo);
                    __params[2] = Marshaler<TProgress>.GetAbi(__progressInfo);
                    abiInvoke.DynamicInvokeAbi(__params);
                }
                finally
                {
                    MarshalInterface<global::Windows.Foundation.IAsyncActionWithProgress<TProgress>>.DisposeMarshaler(__asyncInfo);
                    Marshaler<TProgress>.DisposeMarshaler(__progressInfo);
                }

            }
        }

        public static IntPtr FromManaged(global::Windows.Foundation.AsyncActionProgressHandler<TProgress> managedDelegate) => CreateMarshaler(managedDelegate)?.GetRef() ?? IntPtr.Zero;

        public static void DisposeMarshaler(IObjectReference value) => MarshalInterfaceHelper<global::Windows.Foundation.AsyncActionProgressHandler<TProgress>>.DisposeMarshaler(value);

        public static void DisposeAbi(IntPtr abi) => MarshalInterfaceHelper<global::Windows.Foundation.AsyncActionProgressHandler<TProgress>>.DisposeAbi(abi);

        private static unsafe int Do_Abi_Invoke<TProgressAbi>(void* thisPtr, IntPtr asyncInfo, TProgressAbi progressInfo)
        {


            try
            {
                global::WinRT.ComWrappersSupport.MarshalDelegateInvoke(new IntPtr(thisPtr), (global::System.Delegate invoke) =>
                {
                    invoke.DynamicInvoke(MarshalInterface<global::Windows.Foundation.IAsyncActionWithProgress<TProgress>>.FromAbi(asyncInfo), Marshaler<TProgress>.FromAbi(progressInfo));
                });

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
    }

    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [Guid("9C029F91-CC84-44FD-AC26-0A6C4E555281")]
    public static class AsyncActionWithProgressCompletedHandler<TProgress>
    {
        public static Guid PIID = GuidGenerator.CreateIID(typeof(global::Windows.Foundation.AsyncActionWithProgressCompletedHandler<TProgress>));
        private static readonly Type Abi_Invoke_Type = Expression.GetDelegateType(new Type[] { typeof(void*), typeof(IntPtr), typeof(global::Windows.Foundation.AsyncStatus), typeof(int) });

        private static readonly global::WinRT.Interop.IDelegateVftbl AbiToProjectionVftable;
        public static readonly IntPtr AbiToProjectionVftablePtr;

        static unsafe AsyncActionWithProgressCompletedHandler()
        {
            AbiInvokeDelegate = global::System.Delegate.CreateDelegate(Abi_Invoke_Type, typeof(AsyncActionWithProgressCompletedHandler<TProgress>).GetMethod(nameof(Do_Abi_Invoke), BindingFlags.Static | BindingFlags.NonPublic));
            AbiToProjectionVftable = new global::WinRT.Interop.IDelegateVftbl
            {
                IUnknownVftbl = global::WinRT.Interop.IUnknownVftbl.AbiToProjectionVftbl,
                Invoke = Marshal.GetFunctionPointerForDelegate(AbiInvokeDelegate)
            };
            var nativeVftbl = ComWrappersSupport.AllocateVtableMemory(typeof(AsyncActionWithProgressCompletedHandler<TProgress>), Marshal.SizeOf<global::WinRT.Interop.IDelegateVftbl>());
            Marshal.StructureToPtr(AbiToProjectionVftable, nativeVftbl, false);
            AbiToProjectionVftablePtr = nativeVftbl;
        }

        public static global::System.Delegate AbiInvokeDelegate { get; }

        public static unsafe IObjectReference CreateMarshaler(global::Windows.Foundation.AsyncActionWithProgressCompletedHandler<TProgress> managedDelegate) => 
        managedDelegate is null ? null : MarshalDelegate.CreateMarshaler(managedDelegate, GuidGenerator.GetIID(typeof(AsyncActionWithProgressCompletedHandler<TProgress>)));

        public static IntPtr GetAbi(IObjectReference value) => MarshalInterfaceHelper<global::Windows.Foundation.AsyncActionWithProgressCompletedHandler<TProgress>>.GetAbi(value);

        public static unsafe global::Windows.Foundation.AsyncActionWithProgressCompletedHandler<TProgress> FromAbi(IntPtr nativeDelegate)
        {
            var abiDelegate = ObjectReference<IDelegateVftbl>.FromAbi(nativeDelegate);
            return abiDelegate is null ? null : (global::Windows.Foundation.AsyncActionWithProgressCompletedHandler<TProgress>)ComWrappersSupport.TryRegisterObjectForInterface(new global::Windows.Foundation.AsyncActionWithProgressCompletedHandler<TProgress>(new NativeDelegateWrapper(abiDelegate).Invoke), nativeDelegate);
        }

        [global::WinRT.ObjectReferenceWrapper(nameof(_nativeDelegate))]
        #if NETSTANDARD2_0
        private class NativeDelegateWrapper
        #else
        private class NativeDelegateWrapper : IWinRTObject
        #endif
        {
            private readonly ObjectReference<global::WinRT.Interop.IDelegateVftbl> _nativeDelegate;
            #if NETSTANDARD2_0
            private readonly AgileReference _agileReference = default;
            #endif

            public NativeDelegateWrapper(ObjectReference<global::WinRT.Interop.IDelegateVftbl> nativeDelegate)
            {
                _nativeDelegate = nativeDelegate;
                #if NETSTANDARD2_0
                if (_nativeDelegate.TryAs<ABI.WinRT.Interop.IAgileObject.Vftbl>(out var objRef) < 0)
                {
                    _agileReference = new AgileReference(_nativeDelegate);
                }
                #else
                if (_nativeDelegate.TryAs<IUnknownVftbl>(IAgileObject.IID, out var objRef) < 0)
                {
                    var agileReference = new AgileReference(_nativeDelegate);
                    ((IWinRTObject)this).AdditionalTypeData.TryAdd(typeof(AgileReference).TypeHandle, agileReference);
                }
                #endif
                else
                {
                    objRef.Dispose();
                }
            }

            #if !NETSTANDARD2_0
            IObjectReference IWinRTObject.NativeObject => _nativeDelegate;
            bool IWinRTObject.HasUnwrappableNativeObject => true;
            global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();
            #endif

            public unsafe void Invoke(global::Windows.Foundation.IAsyncActionWithProgress<TProgress> asyncInfo, global::Windows.Foundation.AsyncStatus asyncStatus)
            {
                #if NETSTANDARD2_0
                var agileReference = _agileReference;
                #else
                var agileReference = ((IWinRTObject)this).AdditionalTypeData.TryGetValue(typeof(AgileReference).TypeHandle, out var agileObj) ? (AgileReference)agileObj : null;
                #endif
                using var agileDelegate = agileReference?.Get()?.As<global::WinRT.Interop.IDelegateVftbl>(GuidGenerator.GetIID(typeof(AsyncActionWithProgressCompletedHandler<TProgress>))); 
                var delegateToInvoke = agileDelegate ?? _nativeDelegate;
                IntPtr ThisPtr = delegateToInvoke.ThisPtr;
                var abiInvoke = Marshal.GetDelegateForFunctionPointer(delegateToInvoke.Vftbl.Invoke, Abi_Invoke_Type);
                IObjectReference __asyncInfo = default;
                var __params = new object[]{ ThisPtr, null, asyncStatus };
                try
                {
                    __asyncInfo = MarshalInterface<global::Windows.Foundation.IAsyncActionWithProgress<TProgress>>.CreateMarshaler(asyncInfo);
                    __params[1] = MarshalInterface<global::Windows.Foundation.IAsyncActionWithProgress<TProgress>>.GetAbi(__asyncInfo);
                    abiInvoke.DynamicInvokeAbi(__params);
                }
                finally
                {
                    MarshalInterface<global::Windows.Foundation.IAsyncActionWithProgress<TProgress>>.DisposeMarshaler(__asyncInfo);
                }

            }
        }

        public static IntPtr FromManaged(global::Windows.Foundation.AsyncActionWithProgressCompletedHandler<TProgress> managedDelegate) => CreateMarshaler(managedDelegate)?.GetRef() ?? IntPtr.Zero;

        public static void DisposeMarshaler(IObjectReference value) => MarshalInterfaceHelper<global::Windows.Foundation.AsyncActionWithProgressCompletedHandler<TProgress>>.DisposeMarshaler(value);

        public static void DisposeAbi(IntPtr abi) => MarshalInterfaceHelper<global::Windows.Foundation.AsyncActionWithProgressCompletedHandler<TProgress>>.DisposeAbi(abi);

        private static unsafe int Do_Abi_Invoke(void* thisPtr, IntPtr asyncInfo, global::Windows.Foundation.AsyncStatus asyncStatus)
        {


            try
            {
                global::WinRT.ComWrappersSupport.MarshalDelegateInvoke(new IntPtr(thisPtr), (global::System.Delegate invoke) =>
                {
                    invoke.DynamicInvoke(MarshalInterface<global::Windows.Foundation.IAsyncActionWithProgress<TProgress>>.FromAbi(asyncInfo), asyncStatus);
                });

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
    }

    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [Guid("FCDCF02C-E5D8-4478-915A-4D90B74B83A5")]
    public static class AsyncOperationCompletedHandler<TResult>
    {
        public static Guid PIID = GuidGenerator.CreateIID(typeof(global::Windows.Foundation.AsyncOperationCompletedHandler<TResult>));
        private static readonly Type Abi_Invoke_Type = Expression.GetDelegateType(new Type[] { typeof(void*), typeof(IntPtr), typeof(global::Windows.Foundation.AsyncStatus), typeof(int) });

        private static readonly global::WinRT.Interop.IDelegateVftbl AbiToProjectionVftable;
        public static readonly IntPtr AbiToProjectionVftablePtr;

        static unsafe AsyncOperationCompletedHandler()
        {
            AbiInvokeDelegate = global::System.Delegate.CreateDelegate(Abi_Invoke_Type, typeof(AsyncOperationCompletedHandler<TResult>).GetMethod(nameof(Do_Abi_Invoke), BindingFlags.Static | BindingFlags.NonPublic));
            AbiToProjectionVftable = new global::WinRT.Interop.IDelegateVftbl
            {
                IUnknownVftbl = global::WinRT.Interop.IUnknownVftbl.AbiToProjectionVftbl,
                Invoke = Marshal.GetFunctionPointerForDelegate(AbiInvokeDelegate)
            };
            var nativeVftbl = ComWrappersSupport.AllocateVtableMemory(typeof(AsyncOperationCompletedHandler<TResult>), Marshal.SizeOf<global::WinRT.Interop.IDelegateVftbl>());
            Marshal.StructureToPtr(AbiToProjectionVftable, nativeVftbl, false);
            AbiToProjectionVftablePtr = nativeVftbl;
        }

        public static global::System.Delegate AbiInvokeDelegate { get; }

        public static unsafe IObjectReference CreateMarshaler(global::Windows.Foundation.AsyncOperationCompletedHandler<TResult> managedDelegate) => 
        managedDelegate is null ? null : MarshalDelegate.CreateMarshaler(managedDelegate, GuidGenerator.GetIID(typeof(AsyncOperationCompletedHandler<TResult>)));

        public static IntPtr GetAbi(IObjectReference value) => MarshalInterfaceHelper<global::Windows.Foundation.AsyncOperationCompletedHandler<TResult>>.GetAbi(value);

        public static unsafe global::Windows.Foundation.AsyncOperationCompletedHandler<TResult> FromAbi(IntPtr nativeDelegate)
        {
            var abiDelegate = ObjectReference<IDelegateVftbl>.FromAbi(nativeDelegate);
            return abiDelegate is null ? null : (global::Windows.Foundation.AsyncOperationCompletedHandler<TResult>)ComWrappersSupport.TryRegisterObjectForInterface(new global::Windows.Foundation.AsyncOperationCompletedHandler<TResult>(new NativeDelegateWrapper(abiDelegate).Invoke), nativeDelegate);
        }

        [global::WinRT.ObjectReferenceWrapper(nameof(_nativeDelegate))]
        #if NETSTANDARD2_0
        private class NativeDelegateWrapper
        #else
        private class NativeDelegateWrapper : IWinRTObject
        #endif
        {
            private readonly ObjectReference<global::WinRT.Interop.IDelegateVftbl> _nativeDelegate;
            #if NETSTANDARD2_0
            private readonly AgileReference _agileReference = default;
            #endif

            public NativeDelegateWrapper(ObjectReference<global::WinRT.Interop.IDelegateVftbl> nativeDelegate)
            {
                _nativeDelegate = nativeDelegate;
                #if NETSTANDARD2_0
                if (_nativeDelegate.TryAs<ABI.WinRT.Interop.IAgileObject.Vftbl>(out var objRef) < 0)
                {
                    _agileReference = new AgileReference(_nativeDelegate);
                }
                #else
                if (_nativeDelegate.TryAs<IUnknownVftbl>(IAgileObject.IID, out var objRef) < 0)
                {
                    var agileReference = new AgileReference(_nativeDelegate);
                    ((IWinRTObject)this).AdditionalTypeData.TryAdd(typeof(AgileReference).TypeHandle, agileReference);
                }
                #endif
                else
                {
                    objRef.Dispose();
                }
            }

            #if !NETSTANDARD2_0
            IObjectReference IWinRTObject.NativeObject => _nativeDelegate;
            bool IWinRTObject.HasUnwrappableNativeObject => true;
            global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();
            #endif

            public unsafe void Invoke(global::Windows.Foundation.IAsyncOperation<TResult> asyncInfo, global::Windows.Foundation.AsyncStatus asyncStatus)
            {
                #if NETSTANDARD2_0
                var agileReference = _agileReference;
                #else
                var agileReference = ((IWinRTObject)this).AdditionalTypeData.TryGetValue(typeof(AgileReference).TypeHandle, out var agileObj) ? (AgileReference)agileObj : null;
                #endif
                using var agileDelegate = agileReference?.Get()?.As<global::WinRT.Interop.IDelegateVftbl>(GuidGenerator.GetIID(typeof(AsyncOperationCompletedHandler<TResult>))); 
                var delegateToInvoke = agileDelegate ?? _nativeDelegate;
                IntPtr ThisPtr = delegateToInvoke.ThisPtr;
                var abiInvoke = Marshal.GetDelegateForFunctionPointer(delegateToInvoke.Vftbl.Invoke, Abi_Invoke_Type);
                IObjectReference __asyncInfo = default;
                var __params = new object[]{ ThisPtr, null, asyncStatus };
                try
                {
                    __asyncInfo = MarshalInterface<global::Windows.Foundation.IAsyncOperation<TResult>>.CreateMarshaler(asyncInfo);
                    __params[1] = MarshalInterface<global::Windows.Foundation.IAsyncOperation<TResult>>.GetAbi(__asyncInfo);
                    abiInvoke.DynamicInvokeAbi(__params);
                }
                finally
                {
                    MarshalInterface<global::Windows.Foundation.IAsyncOperation<TResult>>.DisposeMarshaler(__asyncInfo);
                }

            }
        }

        public static IntPtr FromManaged(global::Windows.Foundation.AsyncOperationCompletedHandler<TResult> managedDelegate) => CreateMarshaler(managedDelegate)?.GetRef() ?? IntPtr.Zero;

        public static void DisposeMarshaler(IObjectReference value) => MarshalInterfaceHelper<global::Windows.Foundation.AsyncOperationCompletedHandler<TResult>>.DisposeMarshaler(value);

        public static void DisposeAbi(IntPtr abi) => MarshalInterfaceHelper<global::Windows.Foundation.AsyncOperationCompletedHandler<TResult>>.DisposeAbi(abi);

        private static unsafe int Do_Abi_Invoke(void* thisPtr, IntPtr asyncInfo, global::Windows.Foundation.AsyncStatus asyncStatus)
        {


            try
            {
                global::WinRT.ComWrappersSupport.MarshalDelegateInvoke(new IntPtr(thisPtr), (global::System.Delegate invoke) =>
                {
                    invoke.DynamicInvoke(MarshalInterface<global::Windows.Foundation.IAsyncOperation<TResult>>.FromAbi(asyncInfo), asyncStatus);
                });

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
    }

    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [Guid("55690902-0AAB-421A-8778-F8CE5026D758")]
    public static class AsyncOperationProgressHandler<TResult, TProgress>
    {
        public static Guid PIID = GuidGenerator.CreateIID(typeof(global::Windows.Foundation.AsyncOperationProgressHandler<TResult, TProgress>));
        private static readonly Type Abi_Invoke_Type = Expression.GetDelegateType(new Type[] { typeof(void*), typeof(IntPtr), Marshaler<TProgress>.AbiType, typeof(int) });

        private static readonly global::WinRT.Interop.IDelegateVftbl AbiToProjectionVftable;
        public static readonly IntPtr AbiToProjectionVftablePtr;

        static unsafe AsyncOperationProgressHandler()
        {
            AbiInvokeDelegate = global::System.Delegate.CreateDelegate(Abi_Invoke_Type, typeof(AsyncOperationProgressHandler<TResult, TProgress>).GetMethod(nameof(Do_Abi_Invoke), BindingFlags.Static | BindingFlags.NonPublic).MakeGenericMethod(new Type[]{ Marshaler<TProgress>.AbiType })
            );
            AbiToProjectionVftable = new global::WinRT.Interop.IDelegateVftbl
            {
                IUnknownVftbl = global::WinRT.Interop.IUnknownVftbl.AbiToProjectionVftbl,
                Invoke = Marshal.GetFunctionPointerForDelegate(AbiInvokeDelegate)
            };
            var nativeVftbl = ComWrappersSupport.AllocateVtableMemory(typeof(AsyncOperationProgressHandler<TResult, TProgress>), Marshal.SizeOf<global::WinRT.Interop.IDelegateVftbl>());
            Marshal.StructureToPtr(AbiToProjectionVftable, nativeVftbl, false);
            AbiToProjectionVftablePtr = nativeVftbl;
        }

        public static global::System.Delegate AbiInvokeDelegate { get; }

        public static unsafe IObjectReference CreateMarshaler(global::Windows.Foundation.AsyncOperationProgressHandler<TResult, TProgress> managedDelegate) => 
        managedDelegate is null ? null : MarshalDelegate.CreateMarshaler(managedDelegate, GuidGenerator.GetIID(typeof(AsyncOperationProgressHandler<TResult, TProgress>)));

        public static IntPtr GetAbi(IObjectReference value) => MarshalInterfaceHelper<global::Windows.Foundation.AsyncOperationProgressHandler<TResult, TProgress>>.GetAbi(value);

        public static unsafe global::Windows.Foundation.AsyncOperationProgressHandler<TResult, TProgress> FromAbi(IntPtr nativeDelegate)
        {
            var abiDelegate = ObjectReference<IDelegateVftbl>.FromAbi(nativeDelegate);
            return abiDelegate is null ? null : (global::Windows.Foundation.AsyncOperationProgressHandler<TResult, TProgress>)ComWrappersSupport.TryRegisterObjectForInterface(new global::Windows.Foundation.AsyncOperationProgressHandler<TResult, TProgress>(new NativeDelegateWrapper(abiDelegate).Invoke), nativeDelegate);
        }

        [global::WinRT.ObjectReferenceWrapper(nameof(_nativeDelegate))]
        #if NETSTANDARD2_0
        private class NativeDelegateWrapper
        #else
        private class NativeDelegateWrapper : IWinRTObject
        #endif
        {
            private readonly ObjectReference<global::WinRT.Interop.IDelegateVftbl> _nativeDelegate;
            #if NETSTANDARD2_0
            private readonly AgileReference _agileReference = default;
            #endif

            public NativeDelegateWrapper(ObjectReference<global::WinRT.Interop.IDelegateVftbl> nativeDelegate)
            {
                _nativeDelegate = nativeDelegate;
                #if NETSTANDARD2_0
                if (_nativeDelegate.TryAs<ABI.WinRT.Interop.IAgileObject.Vftbl>(out var objRef) < 0)
                {
                    _agileReference = new AgileReference(_nativeDelegate);
                }
                #else
                if (_nativeDelegate.TryAs<IUnknownVftbl>(IAgileObject.IID, out var objRef) < 0)
                {
                    var agileReference = new AgileReference(_nativeDelegate);
                    ((IWinRTObject)this).AdditionalTypeData.TryAdd(typeof(AgileReference).TypeHandle, agileReference);
                }
                #endif
                else
                {
                    objRef.Dispose();
                }
            }

            #if !NETSTANDARD2_0
            IObjectReference IWinRTObject.NativeObject => _nativeDelegate;
            bool IWinRTObject.HasUnwrappableNativeObject => true;
            global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();
            #endif

            public unsafe void Invoke(global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress> asyncInfo, TProgress progressInfo)
            {
                #if NETSTANDARD2_0
                var agileReference = _agileReference;
                #else
                var agileReference = ((IWinRTObject)this).AdditionalTypeData.TryGetValue(typeof(AgileReference).TypeHandle, out var agileObj) ? (AgileReference)agileObj : null;
                #endif
                using var agileDelegate = agileReference?.Get()?.As<global::WinRT.Interop.IDelegateVftbl>(GuidGenerator.GetIID(typeof(AsyncOperationProgressHandler<TResult, TProgress>))); 
                var delegateToInvoke = agileDelegate ?? _nativeDelegate;
                IntPtr ThisPtr = delegateToInvoke.ThisPtr;
                var abiInvoke = Marshal.GetDelegateForFunctionPointer(delegateToInvoke.Vftbl.Invoke, Abi_Invoke_Type);
                IObjectReference __asyncInfo = default;
                object __progressInfo = default;
                var __params = new object[]{ ThisPtr, null, null };
                try
                {
                    __asyncInfo = MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>>.CreateMarshaler(asyncInfo);
                    __params[1] = MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>>.GetAbi(__asyncInfo);
                    __progressInfo = Marshaler<TProgress>.CreateMarshaler(progressInfo);
                    __params[2] = Marshaler<TProgress>.GetAbi(__progressInfo);
                    abiInvoke.DynamicInvokeAbi(__params);
                }
                finally
                {
                    MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>>.DisposeMarshaler(__asyncInfo);
                    Marshaler<TProgress>.DisposeMarshaler(__progressInfo);
                }

            }
        }

        public static IntPtr FromManaged(global::Windows.Foundation.AsyncOperationProgressHandler<TResult, TProgress> managedDelegate) => CreateMarshaler(managedDelegate)?.GetRef() ?? IntPtr.Zero;

        public static void DisposeMarshaler(IObjectReference value) => MarshalInterfaceHelper<global::Windows.Foundation.AsyncOperationProgressHandler<TResult, TProgress>>.DisposeMarshaler(value);

        public static void DisposeAbi(IntPtr abi) => MarshalInterfaceHelper<global::Windows.Foundation.AsyncOperationProgressHandler<TResult, TProgress>>.DisposeAbi(abi);

        private static unsafe int Do_Abi_Invoke<TProgressAbi>(void* thisPtr, IntPtr asyncInfo, TProgressAbi progressInfo)
        {


            try
            {
                global::WinRT.ComWrappersSupport.MarshalDelegateInvoke(new IntPtr(thisPtr), (global::System.Delegate invoke) =>
                {
                    invoke.DynamicInvoke(MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>>.FromAbi(asyncInfo), Marshaler<TProgress>.FromAbi(progressInfo));
                });

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
    }

    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [Guid("E85DF41D-6AA7-46E3-A8E2-F009D840C627")]
    public static class AsyncOperationWithProgressCompletedHandler<TResult, TProgress>
    {
        public static Guid PIID = GuidGenerator.CreateIID(typeof(global::Windows.Foundation.AsyncOperationWithProgressCompletedHandler<TResult, TProgress>));
        private static readonly Type Abi_Invoke_Type = Expression.GetDelegateType(new Type[] { typeof(void*), typeof(IntPtr), typeof(global::Windows.Foundation.AsyncStatus), typeof(int) });

        private static readonly global::WinRT.Interop.IDelegateVftbl AbiToProjectionVftable;
        public static readonly IntPtr AbiToProjectionVftablePtr;

        static unsafe AsyncOperationWithProgressCompletedHandler()
        {
            AbiInvokeDelegate = global::System.Delegate.CreateDelegate(Abi_Invoke_Type, typeof(AsyncOperationWithProgressCompletedHandler<TResult, TProgress>).GetMethod(nameof(Do_Abi_Invoke), BindingFlags.Static | BindingFlags.NonPublic));
            AbiToProjectionVftable = new global::WinRT.Interop.IDelegateVftbl
            {
                IUnknownVftbl = global::WinRT.Interop.IUnknownVftbl.AbiToProjectionVftbl,
                Invoke = Marshal.GetFunctionPointerForDelegate(AbiInvokeDelegate)
            };
            var nativeVftbl = ComWrappersSupport.AllocateVtableMemory(typeof(AsyncOperationWithProgressCompletedHandler<TResult, TProgress>), Marshal.SizeOf<global::WinRT.Interop.IDelegateVftbl>());
            Marshal.StructureToPtr(AbiToProjectionVftable, nativeVftbl, false);
            AbiToProjectionVftablePtr = nativeVftbl;
        }

        public static global::System.Delegate AbiInvokeDelegate { get; }

        public static unsafe IObjectReference CreateMarshaler(global::Windows.Foundation.AsyncOperationWithProgressCompletedHandler<TResult, TProgress> managedDelegate) => 
        managedDelegate is null ? null : MarshalDelegate.CreateMarshaler(managedDelegate, GuidGenerator.GetIID(typeof(AsyncOperationWithProgressCompletedHandler<TResult, TProgress>)));

        public static IntPtr GetAbi(IObjectReference value) => MarshalInterfaceHelper<global::Windows.Foundation.AsyncOperationWithProgressCompletedHandler<TResult, TProgress>>.GetAbi(value);

        public static unsafe global::Windows.Foundation.AsyncOperationWithProgressCompletedHandler<TResult, TProgress> FromAbi(IntPtr nativeDelegate)
        {
            var abiDelegate = ObjectReference<IDelegateVftbl>.FromAbi(nativeDelegate);
            return abiDelegate is null ? null : (global::Windows.Foundation.AsyncOperationWithProgressCompletedHandler<TResult, TProgress>)ComWrappersSupport.TryRegisterObjectForInterface(new global::Windows.Foundation.AsyncOperationWithProgressCompletedHandler<TResult, TProgress>(new NativeDelegateWrapper(abiDelegate).Invoke), nativeDelegate);
        }

        [global::WinRT.ObjectReferenceWrapper(nameof(_nativeDelegate))]
        #if NETSTANDARD2_0
        private class NativeDelegateWrapper
        #else
        private class NativeDelegateWrapper : IWinRTObject
        #endif
        {
            private readonly ObjectReference<global::WinRT.Interop.IDelegateVftbl> _nativeDelegate;
            #if NETSTANDARD2_0
            private readonly AgileReference _agileReference = default;
            #endif

            public NativeDelegateWrapper(ObjectReference<global::WinRT.Interop.IDelegateVftbl> nativeDelegate)
            {
                _nativeDelegate = nativeDelegate;
                #if NETSTANDARD2_0
                if (_nativeDelegate.TryAs<ABI.WinRT.Interop.IAgileObject.Vftbl>(out var objRef) < 0)
                {
                    _agileReference = new AgileReference(_nativeDelegate);
                }
                #else
                if (_nativeDelegate.TryAs<IUnknownVftbl>(IAgileObject.IID, out var objRef) < 0)
                {
                    var agileReference = new AgileReference(_nativeDelegate);
                    ((IWinRTObject)this).AdditionalTypeData.TryAdd(typeof(AgileReference).TypeHandle, agileReference);
                }
                #endif
                else
                {
                    objRef.Dispose();
                }
            }

            #if !NETSTANDARD2_0
            IObjectReference IWinRTObject.NativeObject => _nativeDelegate;
            bool IWinRTObject.HasUnwrappableNativeObject => true;
            global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();
            #endif

            public unsafe void Invoke(global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress> asyncInfo, global::Windows.Foundation.AsyncStatus asyncStatus)
            {
                #if NETSTANDARD2_0
                var agileReference = _agileReference;
                #else
                var agileReference = ((IWinRTObject)this).AdditionalTypeData.TryGetValue(typeof(AgileReference).TypeHandle, out var agileObj) ? (AgileReference)agileObj : null;
                #endif
                using var agileDelegate = agileReference?.Get()?.As<global::WinRT.Interop.IDelegateVftbl>(GuidGenerator.GetIID(typeof(AsyncOperationWithProgressCompletedHandler<TResult, TProgress>))); 
                var delegateToInvoke = agileDelegate ?? _nativeDelegate;
                IntPtr ThisPtr = delegateToInvoke.ThisPtr;
                var abiInvoke = Marshal.GetDelegateForFunctionPointer(delegateToInvoke.Vftbl.Invoke, Abi_Invoke_Type);
                IObjectReference __asyncInfo = default;
                var __params = new object[]{ ThisPtr, null, asyncStatus };
                try
                {
                    __asyncInfo = MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>>.CreateMarshaler(asyncInfo);
                    __params[1] = MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>>.GetAbi(__asyncInfo);
                    abiInvoke.DynamicInvokeAbi(__params);
                }
                finally
                {
                    MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>>.DisposeMarshaler(__asyncInfo);
                }

            }
        }

        public static IntPtr FromManaged(global::Windows.Foundation.AsyncOperationWithProgressCompletedHandler<TResult, TProgress> managedDelegate) => CreateMarshaler(managedDelegate)?.GetRef() ?? IntPtr.Zero;

        public static void DisposeMarshaler(IObjectReference value) => MarshalInterfaceHelper<global::Windows.Foundation.AsyncOperationWithProgressCompletedHandler<TResult, TProgress>>.DisposeMarshaler(value);

        public static void DisposeAbi(IntPtr abi) => MarshalInterfaceHelper<global::Windows.Foundation.AsyncOperationWithProgressCompletedHandler<TResult, TProgress>>.DisposeAbi(abi);

        private static unsafe int Do_Abi_Invoke(void* thisPtr, IntPtr asyncInfo, global::Windows.Foundation.AsyncStatus asyncStatus)
        {


            try
            {
                global::WinRT.ComWrappersSupport.MarshalDelegateInvoke(new IntPtr(thisPtr), (global::System.Delegate invoke) =>
                {
                    invoke.DynamicInvoke(MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>>.FromAbi(asyncInfo), asyncStatus);
                });

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
    }

    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct Deferral
    {
        public static IObjectReference CreateMarshaler(global::Windows.Foundation.Deferral obj) => obj is null ? null : MarshalInspectable<global::Windows.Foundation.Deferral>.CreateMarshaler(obj).As<IUnknownVftbl>(GuidGenerator.GetIID(typeof(global::Windows.Foundation.IDeferral).GetHelperType()));
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Foundation.Deferral FromAbi(IntPtr thisPtr) => global::Windows.Foundation.Deferral.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Foundation.Deferral obj) => obj is null ? IntPtr.Zero : CreateMarshaler(obj).GetRef();
        public static unsafe MarshalInterfaceHelper<global::Windows.Foundation.Deferral>.MarshalerArray CreateMarshalerArray(global::Windows.Foundation.Deferral[] array) => MarshalInterfaceHelper<global::Windows.Foundation.Deferral>.CreateMarshalerArray(array, (o) => CreateMarshaler(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Foundation.Deferral>.GetAbiArray(box);
        public static unsafe global::Windows.Foundation.Deferral[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Foundation.Deferral>.FromAbiArray(box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Foundation.Deferral[] array) => MarshalInterfaceHelper<global::Windows.Foundation.Deferral>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Foundation.Deferral>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Foundation.Deferral>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [Guid("ED32A372-F3C8-4FAA-9CFB-470148DA3888")]
    public static class DeferralCompletedHandler
    {

        private static readonly global::WinRT.Interop.IDelegateVftbl AbiToProjectionVftable;
        public static readonly IntPtr AbiToProjectionVftablePtr;

        static unsafe DeferralCompletedHandler()
        {
            AbiToProjectionVftable = new global::WinRT.Interop.IDelegateVftbl
            {
                IUnknownVftbl = global::WinRT.Interop.IUnknownVftbl.AbiToProjectionVftbl,
                Invoke = (IntPtr)(delegate* unmanaged[Stdcall]<IntPtr, int>)&Do_Abi_Invoke
            };
            var nativeVftbl = ComWrappersSupport.AllocateVtableMemory(typeof(DeferralCompletedHandler), Marshal.SizeOf<global::WinRT.Interop.IDelegateVftbl>());
            Marshal.StructureToPtr(AbiToProjectionVftable, nativeVftbl, false);
            AbiToProjectionVftablePtr = nativeVftbl;
        }

        public static unsafe IObjectReference CreateMarshaler(global::Windows.Foundation.DeferralCompletedHandler managedDelegate) => 
        managedDelegate is null ? null : MarshalDelegate.CreateMarshaler(managedDelegate, GuidGenerator.GetIID(typeof(DeferralCompletedHandler)));

        public static IntPtr GetAbi(IObjectReference value) => MarshalInterfaceHelper<global::Windows.Foundation.DeferralCompletedHandler>.GetAbi(value);

        public static unsafe global::Windows.Foundation.DeferralCompletedHandler FromAbi(IntPtr nativeDelegate)
        {
            var abiDelegate = ObjectReference<IDelegateVftbl>.FromAbi(nativeDelegate);
            return abiDelegate is null ? null : (global::Windows.Foundation.DeferralCompletedHandler)ComWrappersSupport.TryRegisterObjectForInterface(new global::Windows.Foundation.DeferralCompletedHandler(new NativeDelegateWrapper(abiDelegate).Invoke), nativeDelegate);
        }

        [global::WinRT.ObjectReferenceWrapper(nameof(_nativeDelegate))]
        #if NETSTANDARD2_0
        private class NativeDelegateWrapper
        #else
        private class NativeDelegateWrapper : IWinRTObject
        #endif
        {
            private readonly ObjectReference<global::WinRT.Interop.IDelegateVftbl> _nativeDelegate;
            #if NETSTANDARD2_0
            private readonly AgileReference _agileReference = default;
            #endif

            public NativeDelegateWrapper(ObjectReference<global::WinRT.Interop.IDelegateVftbl> nativeDelegate)
            {
                _nativeDelegate = nativeDelegate;
                #if NETSTANDARD2_0
                if (_nativeDelegate.TryAs<ABI.WinRT.Interop.IAgileObject.Vftbl>(out var objRef) < 0)
                {
                    _agileReference = new AgileReference(_nativeDelegate);
                }
                #else
                if (_nativeDelegate.TryAs<IUnknownVftbl>(IAgileObject.IID, out var objRef) < 0)
                {
                    var agileReference = new AgileReference(_nativeDelegate);
                    ((IWinRTObject)this).AdditionalTypeData.TryAdd(typeof(AgileReference).TypeHandle, agileReference);
                }
                #endif
                else
                {
                    objRef.Dispose();
                }
            }

            #if !NETSTANDARD2_0
            IObjectReference IWinRTObject.NativeObject => _nativeDelegate;
            bool IWinRTObject.HasUnwrappableNativeObject => true;
            global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();
            #endif

            public unsafe void Invoke()
            {
                #if NETSTANDARD2_0
                var agileReference = _agileReference;
                #else
                var agileReference = ((IWinRTObject)this).AdditionalTypeData.TryGetValue(typeof(AgileReference).TypeHandle, out var agileObj) ? (AgileReference)agileObj : null;
                #endif
                using var agileDelegate = agileReference?.Get()?.As<global::WinRT.Interop.IDelegateVftbl>(GuidGenerator.GetIID(typeof(DeferralCompletedHandler))); 
                var delegateToInvoke = agileDelegate ?? _nativeDelegate;
                IntPtr ThisPtr = delegateToInvoke.ThisPtr;
                var abiInvoke = (delegate* unmanaged[Stdcall]<IntPtr, int>)(delegateToInvoke.Vftbl.Invoke);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR(abiInvoke(ThisPtr));

            }
        }

        public static IntPtr FromManaged(global::Windows.Foundation.DeferralCompletedHandler managedDelegate) => CreateMarshaler(managedDelegate)?.GetRef() ?? IntPtr.Zero;

        public static void DisposeMarshaler(IObjectReference value) => MarshalInterfaceHelper<global::Windows.Foundation.DeferralCompletedHandler>.DisposeMarshaler(value);

        public static void DisposeAbi(IntPtr abi) => MarshalInterfaceHelper<global::Windows.Foundation.DeferralCompletedHandler>.DisposeAbi(abi);

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_Invoke(IntPtr thisPtr)
        {


            try
            {
                global::WinRT.ComWrappersSupport.MarshalDelegateInvoke(thisPtr, (global::Windows.Foundation.DeferralCompletedHandler invoke) =>
                {
                    invoke();
                });

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("5A648006-843A-4DA9-865B-9D26E5DFAD7B")]
    internal unsafe interface IAsyncAction : global::Windows.Foundation.IAsyncAction
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IAsyncAction()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IAsyncAction), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 3);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_put_Completed_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_get_Completed_1;
            ((delegate* unmanaged[Stdcall]<IntPtr, int>*)AbiToProjectionVftablePtr)[8] = &Do_Abi_GetResults_2;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_GetResults_2(IntPtr thisPtr)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncAction>(thisPtr).GetResults();

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_put_Completed_0(IntPtr thisPtr, IntPtr handler)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncAction>(thisPtr).Completed = global::ABI.Windows.Foundation.AsyncActionCompletedHandler.FromAbi(handler);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Completed_1(IntPtr thisPtr, IntPtr* handler)
        {
            global::Windows.Foundation.AsyncActionCompletedHandler __handler = default;

            *handler = default;

            try
            {
                __handler = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncAction>(thisPtr).Completed;
                *handler = global::ABI.Windows.Foundation.AsyncActionCompletedHandler.FromManaged(__handler);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe void global::Windows.Foundation.IAsyncAction.GetResults()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncAction).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int>**)ThisPtr)[8](ThisPtr));
        }

        unsafe global::Windows.Foundation.AsyncActionCompletedHandler global::Windows.Foundation.IAsyncAction.Completed
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncAction).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[7](ThisPtr, out __retval));
                    return AsyncActionCompletedHandler.FromAbi(__retval);
                }
                finally
                {
                    AsyncActionCompletedHandler.DisposeAbi(__retval);
                }
            }
            set
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncAction).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IObjectReference __value = default;
                try
                {
                    __value = AsyncActionCompletedHandler.CreateMarshaler(value);
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>**)ThisPtr)[6](ThisPtr, AsyncActionCompletedHandler.GetAbi(__value)));
                }
                finally
                {
                    AsyncActionCompletedHandler.DisposeMarshaler(__value);
                }
            }
        }

        void global::Windows.Foundation.IAsyncInfo.Cancel() => ((global::Windows.Foundation.IAsyncInfo)(IWinRTObject)this).Cancel();

        void global::Windows.Foundation.IAsyncInfo.Close() => ((global::Windows.Foundation.IAsyncInfo)(IWinRTObject)this).Close();

        global::System.Exception global::Windows.Foundation.IAsyncInfo.ErrorCode => ((global::Windows.Foundation.IAsyncInfo)(IWinRTObject)this).ErrorCode;

        uint global::Windows.Foundation.IAsyncInfo.Id => ((global::Windows.Foundation.IAsyncInfo)(IWinRTObject)this).Id;

        global::Windows.Foundation.AsyncStatus global::Windows.Foundation.IAsyncInfo.Status => ((global::Windows.Foundation.IAsyncInfo)(IWinRTObject)this).Status;
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("1F6DB258-E803-48A1-9546-EB7353398884")]
    internal unsafe interface IAsyncActionWithProgress<TProgress> : global::Windows.Foundation.IAsyncActionWithProgress<TProgress>
    {
        public static Guid PIID = Vftbl.PIID;

        [Guid("1F6DB258-E803-48A1-9546-EB7353398884")]
        public struct Vftbl
        {
            internal IInspectable.Vftbl IInspectableVftbl;
            private void* _put_Progress_0;
            public delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int> put_Progress_0 { get => (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>)_put_Progress_0; set => _put_Progress_0=(void*)value; }
            private void* _get_Progress_1;
            public delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int> get_Progress_1 { get => (delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>)_get_Progress_1; set => _get_Progress_1=(void*)value; }
            private void* _put_Completed_2;
            public delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int> put_Completed_2 { get => (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>)_put_Completed_2; set => _put_Completed_2=(void*)value; }
            private void* _get_Completed_3;
            public delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int> get_Completed_3 { get => (delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>)_get_Completed_3; set => _get_Completed_3=(void*)value; }
            private void* _GetResults_4;
            public delegate* unmanaged[Stdcall]<IntPtr, int> GetResults_4 { get => (delegate* unmanaged[Stdcall]<IntPtr, int>)_GetResults_4; set => _GetResults_4=(void*)value; }
            public static Guid PIID = GuidGenerator.CreateIID(typeof(IAsyncActionWithProgress<TProgress>));

            internal unsafe Vftbl(IntPtr thisPtr) : this()
            {
                var vftblPtr = Marshal.PtrToStructure<VftblPtr>(thisPtr);
                var vftbl = (IntPtr*)vftblPtr.Vftbl;
                IInspectableVftbl = Marshal.PtrToStructure<IInspectable.Vftbl>(vftblPtr.Vftbl);
                put_Progress_0 = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>)(vftbl[6]);
                get_Progress_1 = (delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>)(vftbl[7]);
                put_Completed_2 = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>)(vftbl[8]);
                get_Completed_3 = (delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>)(vftbl[9]);
                GetResults_4 = (delegate* unmanaged[Stdcall]<IntPtr, int>)(vftbl[10]);
            }

            private static readonly Vftbl AbiToProjectionVftable;
            public static readonly IntPtr AbiToProjectionVftablePtr;
            private static Delegate[] DelegateCache = new Delegate[5];
            static unsafe Vftbl()
            {
                AbiToProjectionVftable = new Vftbl
                {
                    IInspectableVftbl = global::WinRT.IInspectable.Vftbl.AbiToProjectionVftable, 
                    _put_Progress_0 = (void*)Marshal.GetFunctionPointerForDelegate(DelegateCache[0] = new IAsyncActionWithProgress_Delegates.put_Progress_0(Do_Abi_put_Progress_0)),
                    _get_Progress_1 = (void*)Marshal.GetFunctionPointerForDelegate(DelegateCache[1] = new IAsyncActionWithProgress_Delegates.get_Progress_1(Do_Abi_get_Progress_1)),
                    _put_Completed_2 = (void*)Marshal.GetFunctionPointerForDelegate(DelegateCache[2] = new IAsyncActionWithProgress_Delegates.put_Completed_2(Do_Abi_put_Completed_2)),
                    _get_Completed_3 = (void*)Marshal.GetFunctionPointerForDelegate(DelegateCache[3] = new IAsyncActionWithProgress_Delegates.get_Completed_3(Do_Abi_get_Completed_3)),
                    _GetResults_4 = (void*)Marshal.GetFunctionPointerForDelegate(DelegateCache[4] = new IAsyncActionWithProgress_Delegates.GetResults_4(Do_Abi_GetResults_4))
                };
                var nativeVftbl = (IntPtr*)ComWrappersSupport.AllocateVtableMemory(typeof(Vftbl), Marshal.SizeOf<global::WinRT.IInspectable.Vftbl>() + sizeof(IntPtr) * 5);
                Marshal.StructureToPtr(AbiToProjectionVftable.IInspectableVftbl, (IntPtr)nativeVftbl, false);
                nativeVftbl[6] = (IntPtr)AbiToProjectionVftable._put_Progress_0;nativeVftbl[7] = (IntPtr)AbiToProjectionVftable._get_Progress_1;nativeVftbl[8] = (IntPtr)AbiToProjectionVftable._put_Completed_2;nativeVftbl[9] = (IntPtr)AbiToProjectionVftable._get_Completed_3;nativeVftbl[10] = (IntPtr)AbiToProjectionVftable._GetResults_4;
                AbiToProjectionVftablePtr = (IntPtr)nativeVftbl;
            }


            private static unsafe int Do_Abi_GetResults_4(IntPtr thisPtr)
            {


                try
                {
                    global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncActionWithProgress<TProgress>>(thisPtr).GetResults();

                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            private static unsafe int Do_Abi_put_Progress_0(IntPtr thisPtr, IntPtr handler)
            {


                try
                {
                    global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncActionWithProgress<TProgress>>(thisPtr).Progress = global::ABI.Windows.Foundation.AsyncActionProgressHandler<TProgress>.FromAbi(handler);

                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            private static unsafe int Do_Abi_get_Progress_1(IntPtr thisPtr, IntPtr* __return_value__)
            {
                global::Windows.Foundation.AsyncActionProgressHandler<TProgress> ____return_value__ = default;

                *__return_value__ = default;

                try
                {
                    ____return_value__ = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncActionWithProgress<TProgress>>(thisPtr).Progress;
                    *__return_value__ = global::ABI.Windows.Foundation.AsyncActionProgressHandler<TProgress>.FromManaged(____return_value__);

                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            private static unsafe int Do_Abi_put_Completed_2(IntPtr thisPtr, IntPtr handler)
            {


                try
                {
                    global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncActionWithProgress<TProgress>>(thisPtr).Completed = global::ABI.Windows.Foundation.AsyncActionWithProgressCompletedHandler<TProgress>.FromAbi(handler);

                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            private static unsafe int Do_Abi_get_Completed_3(IntPtr thisPtr, IntPtr* __return_value__)
            {
                global::Windows.Foundation.AsyncActionWithProgressCompletedHandler<TProgress> ____return_value__ = default;

                *__return_value__ = default;

                try
                {
                    ____return_value__ = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncActionWithProgress<TProgress>>(thisPtr).Completed;
                    *__return_value__ = global::ABI.Windows.Foundation.AsyncActionWithProgressCompletedHandler<TProgress>.FromManaged(____return_value__);

                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }
        }
        unsafe void global::Windows.Foundation.IAsyncActionWithProgress<TProgress>.GetResults()
        {
            var _obj = ((ObjectReference<Vftbl>)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncActionWithProgress<TProgress>).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR(_obj.Vftbl.GetResults_4(ThisPtr));
        }

        unsafe global::Windows.Foundation.AsyncActionProgressHandler<TProgress> global::Windows.Foundation.IAsyncActionWithProgress<TProgress>.Progress
        {
            get
            {
                var _obj = ((ObjectReference<Vftbl>)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncActionWithProgress<TProgress>).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR(_obj.Vftbl.get_Progress_1(ThisPtr, out __retval));
                    return AsyncActionProgressHandler<TProgress>.FromAbi(__retval);
                }
                finally
                {
                    AsyncActionProgressHandler<TProgress>.DisposeAbi(__retval);
                }
            }
            set
            {
                var _obj = ((ObjectReference<Vftbl>)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncActionWithProgress<TProgress>).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IObjectReference __value = default;
                try
                {
                    __value = AsyncActionProgressHandler<TProgress>.CreateMarshaler(value);
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR(_obj.Vftbl.put_Progress_0(ThisPtr, AsyncActionProgressHandler<TProgress>.GetAbi(__value)));
                }
                finally
                {
                    AsyncActionProgressHandler<TProgress>.DisposeMarshaler(__value);
                }
            }
        }

        unsafe global::Windows.Foundation.AsyncActionWithProgressCompletedHandler<TProgress> global::Windows.Foundation.IAsyncActionWithProgress<TProgress>.Completed
        {
            get
            {
                var _obj = ((ObjectReference<Vftbl>)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncActionWithProgress<TProgress>).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR(_obj.Vftbl.get_Completed_3(ThisPtr, out __retval));
                    return AsyncActionWithProgressCompletedHandler<TProgress>.FromAbi(__retval);
                }
                finally
                {
                    AsyncActionWithProgressCompletedHandler<TProgress>.DisposeAbi(__retval);
                }
            }
            set
            {
                var _obj = ((ObjectReference<Vftbl>)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncActionWithProgress<TProgress>).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IObjectReference __value = default;
                try
                {
                    __value = AsyncActionWithProgressCompletedHandler<TProgress>.CreateMarshaler(value);
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR(_obj.Vftbl.put_Completed_2(ThisPtr, AsyncActionWithProgressCompletedHandler<TProgress>.GetAbi(__value)));
                }
                finally
                {
                    AsyncActionWithProgressCompletedHandler<TProgress>.DisposeMarshaler(__value);
                }
            }
        }

        void global::Windows.Foundation.IAsyncInfo.Cancel() => ((global::Windows.Foundation.IAsyncInfo)(IWinRTObject)this).Cancel();

        void global::Windows.Foundation.IAsyncInfo.Close() => ((global::Windows.Foundation.IAsyncInfo)(IWinRTObject)this).Close();

        global::System.Exception global::Windows.Foundation.IAsyncInfo.ErrorCode => ((global::Windows.Foundation.IAsyncInfo)(IWinRTObject)this).ErrorCode;

        uint global::Windows.Foundation.IAsyncInfo.Id => ((global::Windows.Foundation.IAsyncInfo)(IWinRTObject)this).Id;

        global::Windows.Foundation.AsyncStatus global::Windows.Foundation.IAsyncInfo.Status => ((global::Windows.Foundation.IAsyncInfo)(IWinRTObject)this).Status;
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public static class IAsyncActionWithProgress_Delegates
    {
        public unsafe delegate int put_Progress_0(IntPtr thisPtr, IntPtr handler);
        public unsafe delegate int get_Progress_1(IntPtr thisPtr, IntPtr* __return_value__);
        public unsafe delegate int put_Completed_2(IntPtr thisPtr, IntPtr handler);
        public unsafe delegate int get_Completed_3(IntPtr thisPtr, IntPtr* __return_value__);
        public unsafe delegate int GetResults_4(IntPtr thisPtr);
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("00000036-0000-0000-C000-000000000046")]
    internal unsafe interface IAsyncInfo : global::Windows.Foundation.IAsyncInfo
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IAsyncInfo()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IAsyncInfo), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 5);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_get_Id_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Foundation.AsyncStatus*, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_get_Status_1;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::ABI.System.Exception*, int>*)AbiToProjectionVftablePtr)[8] = &Do_Abi_get_ErrorCode_2;
            ((delegate* unmanaged[Stdcall]<IntPtr, int>*)AbiToProjectionVftablePtr)[9] = &Do_Abi_Cancel_3;
            ((delegate* unmanaged[Stdcall]<IntPtr, int>*)AbiToProjectionVftablePtr)[10] = &Do_Abi_Close_4;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_Cancel_3(IntPtr thisPtr)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncInfo>(thisPtr).Cancel();

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_Close_4(IntPtr thisPtr)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncInfo>(thisPtr).Close();

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_ErrorCode_2(IntPtr thisPtr, global::ABI.System.Exception* __return_value__)
        {
            global::System.Exception ____return_value__ = default;

            *__return_value__ = default;

            try
            {
                ____return_value__ = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncInfo>(thisPtr).ErrorCode;
                *__return_value__ = global::ABI.System.Exception.FromManaged(____return_value__);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Id_0(IntPtr thisPtr, uint* __return_value__)
        {
            uint ____return_value__ = default;

            *__return_value__ = default;

            try
            {
                ____return_value__ = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncInfo>(thisPtr).Id;
                *__return_value__ = ____return_value__;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Status_1(IntPtr thisPtr, global::Windows.Foundation.AsyncStatus* __return_value__)
        {
            global::Windows.Foundation.AsyncStatus ____return_value__ = default;

            *__return_value__ = default;

            try
            {
                ____return_value__ = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncInfo>(thisPtr).Status;
                *__return_value__ = ____return_value__;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe void global::Windows.Foundation.IAsyncInfo.Cancel()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncInfo).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int>**)ThisPtr)[9](ThisPtr));
        }

        unsafe void global::Windows.Foundation.IAsyncInfo.Close()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncInfo).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int>**)ThisPtr)[10](ThisPtr));
        }

        unsafe global::System.Exception global::Windows.Foundation.IAsyncInfo.ErrorCode
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncInfo).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                global::ABI.System.Exception __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out global::ABI.System.Exception, int>**)ThisPtr)[8](ThisPtr, out __retval));
                    return global::ABI.System.Exception.FromAbi(__retval);
                }
                finally
                {
                    global::ABI.System.Exception.DisposeAbi(__retval);
                }
            }
        }

        unsafe uint global::Windows.Foundation.IAsyncInfo.Id
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncInfo).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                uint __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out uint, int>**)ThisPtr)[6](ThisPtr, out __retval));
                return __retval;
            }
        }

        unsafe global::Windows.Foundation.AsyncStatus global::Windows.Foundation.IAsyncInfo.Status
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncInfo).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                global::Windows.Foundation.AsyncStatus __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out global::Windows.Foundation.AsyncStatus, int>**)ThisPtr)[7](ThisPtr, out __retval));
                return __retval;
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("B5D036D7-E297-498F-BA60-0289E76E23DD")]
    internal unsafe interface IAsyncOperationWithProgress<TResult, TProgress> : global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>
    {
        public static Guid PIID = Vftbl.PIID;

        [Guid("B5D036D7-E297-498F-BA60-0289E76E23DD")]
        public struct Vftbl
        {
            internal IInspectable.Vftbl IInspectableVftbl;
            private void* _put_Progress_0;
            public delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int> put_Progress_0 { get => (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>)_put_Progress_0; set => _put_Progress_0=(void*)value; }
            private void* _get_Progress_1;
            public delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int> get_Progress_1 { get => (delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>)_get_Progress_1; set => _get_Progress_1=(void*)value; }
            private void* _put_Completed_2;
            public delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int> put_Completed_2 { get => (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>)_put_Completed_2; set => _put_Completed_2=(void*)value; }
            private void* _get_Completed_3;
            public delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int> get_Completed_3 { get => (delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>)_get_Completed_3; set => _get_Completed_3=(void*)value; }
            public global::System.Delegate GetResults_4;public static Guid PIID = GuidGenerator.CreateIID(typeof(IAsyncOperationWithProgress<TResult, TProgress>));
            public static readonly Type GetResults_4_Type = Expression.GetDelegateType(new Type[]{ typeof(void*), Marshaler<TResult>.AbiType.MakeByRefType(), typeof(int) });

            internal unsafe Vftbl(IntPtr thisPtr) : this()
            {
                var vftblPtr = Marshal.PtrToStructure<VftblPtr>(thisPtr);
                var vftbl = (IntPtr*)vftblPtr.Vftbl;
                IInspectableVftbl = Marshal.PtrToStructure<IInspectable.Vftbl>(vftblPtr.Vftbl);
                put_Progress_0 = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>)(vftbl[6]);
                get_Progress_1 = (delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>)(vftbl[7]);
                put_Completed_2 = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>)(vftbl[8]);
                get_Completed_3 = (delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>)(vftbl[9]);
                GetResults_4 = Marshal.GetDelegateForFunctionPointer(vftbl[10], GetResults_4_Type);
            }

            private static readonly Vftbl AbiToProjectionVftable;
            public static readonly IntPtr AbiToProjectionVftablePtr;
            private static Delegate[] DelegateCache = new Delegate[5];
            static unsafe Vftbl()
            {
                AbiToProjectionVftable = new Vftbl
                {
                    IInspectableVftbl = global::WinRT.IInspectable.Vftbl.AbiToProjectionVftable, 
                    _put_Progress_0 = (void*)Marshal.GetFunctionPointerForDelegate(DelegateCache[0] = new IAsyncOperationWithProgress_Delegates.put_Progress_0(Do_Abi_put_Progress_0)),
                    _get_Progress_1 = (void*)Marshal.GetFunctionPointerForDelegate(DelegateCache[1] = new IAsyncOperationWithProgress_Delegates.get_Progress_1(Do_Abi_get_Progress_1)),
                    _put_Completed_2 = (void*)Marshal.GetFunctionPointerForDelegate(DelegateCache[2] = new IAsyncOperationWithProgress_Delegates.put_Completed_2(Do_Abi_put_Completed_2)),
                    _get_Completed_3 = (void*)Marshal.GetFunctionPointerForDelegate(DelegateCache[3] = new IAsyncOperationWithProgress_Delegates.get_Completed_3(Do_Abi_get_Completed_3)),
                    GetResults_4 = global::System.Delegate.CreateDelegate(GetResults_4_Type, typeof(Vftbl).GetMethod("Do_Abi_GetResults_4", BindingFlags.NonPublic | BindingFlags.Static).MakeGenericMethod(Marshaler<TResult>.AbiType))
                };
                var nativeVftbl = (IntPtr*)ComWrappersSupport.AllocateVtableMemory(typeof(Vftbl), Marshal.SizeOf<global::WinRT.IInspectable.Vftbl>() + sizeof(IntPtr) * 5);
                Marshal.StructureToPtr(AbiToProjectionVftable.IInspectableVftbl, (IntPtr)nativeVftbl, false);
                nativeVftbl[6] = (IntPtr)AbiToProjectionVftable._put_Progress_0;nativeVftbl[7] = (IntPtr)AbiToProjectionVftable._get_Progress_1;nativeVftbl[8] = (IntPtr)AbiToProjectionVftable._put_Completed_2;nativeVftbl[9] = (IntPtr)AbiToProjectionVftable._get_Completed_3;nativeVftbl[10] = Marshal.GetFunctionPointerForDelegate(AbiToProjectionVftable.GetResults_4);

                AbiToProjectionVftablePtr = (IntPtr)nativeVftbl;
            }


            private static unsafe int Do_Abi_GetResults_4<TResultAbi>(void* thisPtr, out TResultAbi __return_value__)
            {
                TResult ____return_value__ = default;

                __return_value__ = default;

                try
                {
                    ____return_value__ = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>>(new IntPtr(thisPtr)).GetResults();
                    __return_value__ = (TResultAbi)Marshaler<TResult>.FromManaged(____return_value__);

                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            private static unsafe int Do_Abi_put_Progress_0(IntPtr thisPtr, IntPtr handler)
            {


                try
                {
                    global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>>(thisPtr).Progress = global::ABI.Windows.Foundation.AsyncOperationProgressHandler<TResult, TProgress>.FromAbi(handler);

                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            private static unsafe int Do_Abi_get_Progress_1(IntPtr thisPtr, IntPtr* __return_value__)
            {
                global::Windows.Foundation.AsyncOperationProgressHandler<TResult, TProgress> ____return_value__ = default;

                *__return_value__ = default;

                try
                {
                    ____return_value__ = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>>(thisPtr).Progress;
                    *__return_value__ = global::ABI.Windows.Foundation.AsyncOperationProgressHandler<TResult, TProgress>.FromManaged(____return_value__);

                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            private static unsafe int Do_Abi_put_Completed_2(IntPtr thisPtr, IntPtr handler)
            {


                try
                {
                    global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>>(thisPtr).Completed = global::ABI.Windows.Foundation.AsyncOperationWithProgressCompletedHandler<TResult, TProgress>.FromAbi(handler);

                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            private static unsafe int Do_Abi_get_Completed_3(IntPtr thisPtr, IntPtr* __return_value__)
            {
                global::Windows.Foundation.AsyncOperationWithProgressCompletedHandler<TResult, TProgress> ____return_value__ = default;

                *__return_value__ = default;

                try
                {
                    ____return_value__ = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>>(thisPtr).Completed;
                    *__return_value__ = global::ABI.Windows.Foundation.AsyncOperationWithProgressCompletedHandler<TResult, TProgress>.FromManaged(____return_value__);

                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }
        }
        unsafe TResult global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>.GetResults()
        {
            var _obj = ((ObjectReference<Vftbl>)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            var __params = new object[]{ ThisPtr, null };
            try
            {
                _obj.Vftbl.GetResults_4.DynamicInvokeAbi(__params);
                return Marshaler<TResult>.FromAbi(__params[1]);
            }
            finally
            {
                Marshaler<TResult>.DisposeAbi(__params[1]);
            }
        }

        unsafe global::Windows.Foundation.AsyncOperationProgressHandler<TResult, TProgress> global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>.Progress
        {
            get
            {
                var _obj = ((ObjectReference<Vftbl>)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR(_obj.Vftbl.get_Progress_1(ThisPtr, out __retval));
                    return AsyncOperationProgressHandler<TResult, TProgress>.FromAbi(__retval);
                }
                finally
                {
                    AsyncOperationProgressHandler<TResult, TProgress>.DisposeAbi(__retval);
                }
            }
            set
            {
                var _obj = ((ObjectReference<Vftbl>)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IObjectReference __value = default;
                try
                {
                    __value = AsyncOperationProgressHandler<TResult, TProgress>.CreateMarshaler(value);
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR(_obj.Vftbl.put_Progress_0(ThisPtr, AsyncOperationProgressHandler<TResult, TProgress>.GetAbi(__value)));
                }
                finally
                {
                    AsyncOperationProgressHandler<TResult, TProgress>.DisposeMarshaler(__value);
                }
            }
        }

        unsafe global::Windows.Foundation.AsyncOperationWithProgressCompletedHandler<TResult, TProgress> global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>.Completed
        {
            get
            {
                var _obj = ((ObjectReference<Vftbl>)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR(_obj.Vftbl.get_Completed_3(ThisPtr, out __retval));
                    return AsyncOperationWithProgressCompletedHandler<TResult, TProgress>.FromAbi(__retval);
                }
                finally
                {
                    AsyncOperationWithProgressCompletedHandler<TResult, TProgress>.DisposeAbi(__retval);
                }
            }
            set
            {
                var _obj = ((ObjectReference<Vftbl>)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IObjectReference __value = default;
                try
                {
                    __value = AsyncOperationWithProgressCompletedHandler<TResult, TProgress>.CreateMarshaler(value);
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR(_obj.Vftbl.put_Completed_2(ThisPtr, AsyncOperationWithProgressCompletedHandler<TResult, TProgress>.GetAbi(__value)));
                }
                finally
                {
                    AsyncOperationWithProgressCompletedHandler<TResult, TProgress>.DisposeMarshaler(__value);
                }
            }
        }

        void global::Windows.Foundation.IAsyncInfo.Cancel() => ((global::Windows.Foundation.IAsyncInfo)(IWinRTObject)this).Cancel();

        void global::Windows.Foundation.IAsyncInfo.Close() => ((global::Windows.Foundation.IAsyncInfo)(IWinRTObject)this).Close();

        global::System.Exception global::Windows.Foundation.IAsyncInfo.ErrorCode => ((global::Windows.Foundation.IAsyncInfo)(IWinRTObject)this).ErrorCode;

        uint global::Windows.Foundation.IAsyncInfo.Id => ((global::Windows.Foundation.IAsyncInfo)(IWinRTObject)this).Id;

        global::Windows.Foundation.AsyncStatus global::Windows.Foundation.IAsyncInfo.Status => ((global::Windows.Foundation.IAsyncInfo)(IWinRTObject)this).Status;
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public static class IAsyncOperationWithProgress_Delegates
    {
        public unsafe delegate int put_Progress_0(IntPtr thisPtr, IntPtr handler);
        public unsafe delegate int get_Progress_1(IntPtr thisPtr, IntPtr* __return_value__);
        public unsafe delegate int put_Completed_2(IntPtr thisPtr, IntPtr handler);
        public unsafe delegate int get_Completed_3(IntPtr thisPtr, IntPtr* __return_value__);
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("9FC2B0BB-E446-44E2-AA61-9CAB8F636AF2")]
    internal unsafe interface IAsyncOperation<TResult> : global::Windows.Foundation.IAsyncOperation<TResult>
    {
        public static Guid PIID = Vftbl.PIID;

        [Guid("9FC2B0BB-E446-44E2-AA61-9CAB8F636AF2")]
        public struct Vftbl
        {
            internal IInspectable.Vftbl IInspectableVftbl;
            private void* _put_Completed_0;
            public delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int> put_Completed_0 { get => (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>)_put_Completed_0; set => _put_Completed_0=(void*)value; }
            private void* _get_Completed_1;
            public delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int> get_Completed_1 { get => (delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>)_get_Completed_1; set => _get_Completed_1=(void*)value; }
            public global::System.Delegate GetResults_2;public static Guid PIID = GuidGenerator.CreateIID(typeof(IAsyncOperation<TResult>));
            public static readonly Type GetResults_2_Type = Expression.GetDelegateType(new Type[]{ typeof(void*), Marshaler<TResult>.AbiType.MakeByRefType(), typeof(int) });

            internal unsafe Vftbl(IntPtr thisPtr) : this()
            {
                var vftblPtr = Marshal.PtrToStructure<VftblPtr>(thisPtr);
                var vftbl = (IntPtr*)vftblPtr.Vftbl;
                IInspectableVftbl = Marshal.PtrToStructure<IInspectable.Vftbl>(vftblPtr.Vftbl);
                put_Completed_0 = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>)(vftbl[6]);
                get_Completed_1 = (delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>)(vftbl[7]);
                GetResults_2 = Marshal.GetDelegateForFunctionPointer(vftbl[8], GetResults_2_Type);
            }

            private static readonly Vftbl AbiToProjectionVftable;
            public static readonly IntPtr AbiToProjectionVftablePtr;
            private static Delegate[] DelegateCache = new Delegate[3];
            static unsafe Vftbl()
            {
                AbiToProjectionVftable = new Vftbl
                {
                    IInspectableVftbl = global::WinRT.IInspectable.Vftbl.AbiToProjectionVftable, 
                    _put_Completed_0 = (void*)Marshal.GetFunctionPointerForDelegate(DelegateCache[0] = new IAsyncOperation_Delegates.put_Completed_0(Do_Abi_put_Completed_0)),
                    _get_Completed_1 = (void*)Marshal.GetFunctionPointerForDelegate(DelegateCache[1] = new IAsyncOperation_Delegates.get_Completed_1(Do_Abi_get_Completed_1)),
                    GetResults_2 = global::System.Delegate.CreateDelegate(GetResults_2_Type, typeof(Vftbl).GetMethod("Do_Abi_GetResults_2", BindingFlags.NonPublic | BindingFlags.Static).MakeGenericMethod(Marshaler<TResult>.AbiType))
                };
                var nativeVftbl = (IntPtr*)ComWrappersSupport.AllocateVtableMemory(typeof(Vftbl), Marshal.SizeOf<global::WinRT.IInspectable.Vftbl>() + sizeof(IntPtr) * 3);
                Marshal.StructureToPtr(AbiToProjectionVftable.IInspectableVftbl, (IntPtr)nativeVftbl, false);
                nativeVftbl[6] = (IntPtr)AbiToProjectionVftable._put_Completed_0;nativeVftbl[7] = (IntPtr)AbiToProjectionVftable._get_Completed_1;nativeVftbl[8] = Marshal.GetFunctionPointerForDelegate(AbiToProjectionVftable.GetResults_2);

                AbiToProjectionVftablePtr = (IntPtr)nativeVftbl;
            }


            private static unsafe int Do_Abi_GetResults_2<TResultAbi>(void* thisPtr, out TResultAbi __return_value__)
            {
                TResult ____return_value__ = default;

                __return_value__ = default;

                try
                {
                    ____return_value__ = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncOperation<TResult>>(new IntPtr(thisPtr)).GetResults();
                    __return_value__ = (TResultAbi)Marshaler<TResult>.FromManaged(____return_value__);

                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            private static unsafe int Do_Abi_put_Completed_0(IntPtr thisPtr, IntPtr handler)
            {


                try
                {
                    global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncOperation<TResult>>(thisPtr).Completed = global::ABI.Windows.Foundation.AsyncOperationCompletedHandler<TResult>.FromAbi(handler);

                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            private static unsafe int Do_Abi_get_Completed_1(IntPtr thisPtr, IntPtr* __return_value__)
            {
                global::Windows.Foundation.AsyncOperationCompletedHandler<TResult> ____return_value__ = default;

                *__return_value__ = default;

                try
                {
                    ____return_value__ = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IAsyncOperation<TResult>>(thisPtr).Completed;
                    *__return_value__ = global::ABI.Windows.Foundation.AsyncOperationCompletedHandler<TResult>.FromManaged(____return_value__);

                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }
        }
        unsafe TResult global::Windows.Foundation.IAsyncOperation<TResult>.GetResults()
        {
            var _obj = ((ObjectReference<Vftbl>)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncOperation<TResult>).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            var __params = new object[]{ ThisPtr, null };
            try
            {
                _obj.Vftbl.GetResults_2.DynamicInvokeAbi(__params);
                return Marshaler<TResult>.FromAbi(__params[1]);
            }
            finally
            {
                Marshaler<TResult>.DisposeAbi(__params[1]);
            }
        }

        unsafe global::Windows.Foundation.AsyncOperationCompletedHandler<TResult> global::Windows.Foundation.IAsyncOperation<TResult>.Completed
        {
            get
            {
                var _obj = ((ObjectReference<Vftbl>)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncOperation<TResult>).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR(_obj.Vftbl.get_Completed_1(ThisPtr, out __retval));
                    return AsyncOperationCompletedHandler<TResult>.FromAbi(__retval);
                }
                finally
                {
                    AsyncOperationCompletedHandler<TResult>.DisposeAbi(__retval);
                }
            }
            set
            {
                var _obj = ((ObjectReference<Vftbl>)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IAsyncOperation<TResult>).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IObjectReference __value = default;
                try
                {
                    __value = AsyncOperationCompletedHandler<TResult>.CreateMarshaler(value);
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR(_obj.Vftbl.put_Completed_0(ThisPtr, AsyncOperationCompletedHandler<TResult>.GetAbi(__value)));
                }
                finally
                {
                    AsyncOperationCompletedHandler<TResult>.DisposeMarshaler(__value);
                }
            }
        }

        void global::Windows.Foundation.IAsyncInfo.Cancel() => ((global::Windows.Foundation.IAsyncInfo)(IWinRTObject)this).Cancel();

        void global::Windows.Foundation.IAsyncInfo.Close() => ((global::Windows.Foundation.IAsyncInfo)(IWinRTObject)this).Close();

        global::System.Exception global::Windows.Foundation.IAsyncInfo.ErrorCode => ((global::Windows.Foundation.IAsyncInfo)(IWinRTObject)this).ErrorCode;

        uint global::Windows.Foundation.IAsyncInfo.Id => ((global::Windows.Foundation.IAsyncInfo)(IWinRTObject)this).Id;

        global::Windows.Foundation.AsyncStatus global::Windows.Foundation.IAsyncInfo.Status => ((global::Windows.Foundation.IAsyncInfo)(IWinRTObject)this).Status;
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public static class IAsyncOperation_Delegates
    {
        public unsafe delegate int put_Completed_0(IntPtr thisPtr, IntPtr handler);
        public unsafe delegate int get_Completed_1(IntPtr thisPtr, IntPtr* __return_value__);
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("D6269732-3B7F-46A7-B40B-4FDCA2A2C693")]
    internal unsafe interface IDeferral : global::Windows.Foundation.IDeferral
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IDeferral()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IDeferral), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 1);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_Complete_0;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_Complete_0(IntPtr thisPtr)
        {


            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IDeferral>(thisPtr).Complete();

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe void global::Windows.Foundation.IDeferral.Complete()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IDeferral).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int>**)ThisPtr)[6](ThisPtr));
        }

        void global::System.IDisposable.Dispose() => ((global::System.IDisposable)(IWinRTObject)this).Dispose();
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("65A1ECC5-3FB5-4832-8CA9-F061B281D13A")]
    internal unsafe interface IDeferralFactory : global::Windows.Foundation.IDeferralFactory
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IDeferralFactory()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IDeferralFactory), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 1);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_Create_0;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_Create_0(IntPtr thisPtr, IntPtr handler, IntPtr* result)
        {
            global::Windows.Foundation.Deferral __result = default;

            *result = default;

            try
            {
                __result = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IDeferralFactory>(thisPtr).Create(global::ABI.Windows.Foundation.DeferralCompletedHandler.FromAbi(handler));
                *result = global::ABI.Windows.Foundation.Deferral.FromManaged(__result);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Foundation.Deferral global::Windows.Foundation.IDeferralFactory.Create(global::Windows.Foundation.DeferralCompletedHandler handler)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IDeferralFactory).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IObjectReference __handler = default;
            IntPtr __retval = default;
            try
            {
                __handler = DeferralCompletedHandler.CreateMarshaler(handler);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, DeferralCompletedHandler.GetAbi(__handler), out __retval));
                return global::ABI.Windows.Foundation.Deferral.FromAbi(__retval);
            }
            finally
            {
                DeferralCompletedHandler.DisposeMarshaler(__handler);
                global::ABI.Windows.Foundation.Deferral.DisposeAbi(__retval);
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("4EDB8EE2-96DD-49A7-94F7-4607DDAB8E3C")]
    internal unsafe interface IGetActivationFactory : global::Windows.Foundation.IGetActivationFactory
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IGetActivationFactory()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IGetActivationFactory), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 1);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_GetActivationFactory_0;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_GetActivationFactory_0(IntPtr thisPtr, IntPtr activatableClassId, IntPtr* factory)
        {
            object __factory = default;

            *factory = default;

            try
            {
                __factory = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IGetActivationFactory>(thisPtr).GetActivationFactory(MarshalString.FromAbi(activatableClassId));
                *factory = MarshalInspectable<object>.FromManaged(__factory);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe object global::Windows.Foundation.IGetActivationFactory.GetActivationFactory(string activatableClassId)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IGetActivationFactory).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalString __activatableClassId = default;
            IntPtr __retval = default;
            try
            {
                __activatableClassId = MarshalString.CreateMarshaler(activatableClassId);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, MarshalString.GetAbi(__activatableClassId), out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalString.DisposeMarshaler(__activatableClassId);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("59C7966B-AE52-5283-AD7F-A1B9E9678ADD")]
    internal unsafe interface IGuidHelperStatics : global::Windows.Foundation.IGuidHelperStatics
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IGuidHelperStatics()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IGuidHelperStatics), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 3);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, Guid*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_CreateNewGuid_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, Guid*, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_get_Empty_1;
            ((delegate* unmanaged[Stdcall]<IntPtr, Guid*, Guid*, byte*, int>*)AbiToProjectionVftablePtr)[8] = &Do_Abi_Equals_2;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateNewGuid_0(IntPtr thisPtr, Guid* result)
        {
            Guid __result = default;

            *result = default;

            try
            {
                __result = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IGuidHelperStatics>(thisPtr).CreateNewGuid();
                *result = __result;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_Equals_2(IntPtr thisPtr, Guid* target, Guid* value, byte* result)
        {
            bool __result = default;

            *result = default;

            try
            {
                __result = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IGuidHelperStatics>(thisPtr).Equals(*target, *value);
                *result = (byte)(__result ? 1 : 0);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Empty_1(IntPtr thisPtr, Guid* value)
        {
            Guid __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IGuidHelperStatics>(thisPtr).Empty;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe Guid global::Windows.Foundation.IGuidHelperStatics.CreateNewGuid()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IGuidHelperStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            Guid __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out Guid, int>**)ThisPtr)[6](ThisPtr, out __retval));
            return __retval;
        }

        unsafe bool global::Windows.Foundation.IGuidHelperStatics.Equals(in Guid target, in Guid value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IGuidHelperStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            byte __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, in Guid, in Guid, out byte, int>**)ThisPtr)[8](ThisPtr, target, value, out __retval));
            return __retval != 0;
        }

        unsafe Guid global::Windows.Foundation.IGuidHelperStatics.Empty
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IGuidHelperStatics).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                Guid __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out Guid, int>**)ThisPtr)[7](ThisPtr, out __retval));
                return __retval;
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("FBC4DD2A-245B-11E4-AF98-689423260CF8")]
    internal unsafe interface IMemoryBuffer : global::Windows.Foundation.IMemoryBuffer
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IMemoryBuffer()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IMemoryBuffer), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 1);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_CreateReference_0;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateReference_0(IntPtr thisPtr, IntPtr* reference)
        {
            global::Windows.Foundation.IMemoryBufferReference __reference = default;

            *reference = default;

            try
            {
                __reference = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IMemoryBuffer>(thisPtr).CreateReference();
                *reference = MarshalInterface<global::Windows.Foundation.IMemoryBufferReference>.FromManaged(__reference);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Foundation.IMemoryBufferReference global::Windows.Foundation.IMemoryBuffer.CreateReference()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IMemoryBuffer).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, out __retval));
                return MarshalInterface<global::Windows.Foundation.IMemoryBufferReference>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Foundation.IMemoryBufferReference>.DisposeAbi(__retval);
            }
        }

        void global::System.IDisposable.Dispose() => ((global::System.IDisposable)(IWinRTObject)this).Dispose();
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("FBC4DD2B-245B-11E4-AF98-689423260CF8")]
    internal unsafe interface IMemoryBufferFactory : global::Windows.Foundation.IMemoryBufferFactory
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IMemoryBufferFactory()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IMemoryBufferFactory), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 1);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_Create_0;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_Create_0(IntPtr thisPtr, uint capacity, IntPtr* value)
        {
            global::Windows.Foundation.MemoryBuffer __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IMemoryBufferFactory>(thisPtr).Create(capacity);
                *value = global::ABI.Windows.Foundation.MemoryBuffer.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Foundation.MemoryBuffer global::Windows.Foundation.IMemoryBufferFactory.Create(uint capacity)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IMemoryBufferFactory).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint, out IntPtr, int>**)ThisPtr)[6](ThisPtr, capacity, out __retval));
                return global::ABI.Windows.Foundation.MemoryBuffer.FromAbi(__retval);
            }
            finally
            {
                global::ABI.Windows.Foundation.MemoryBuffer.DisposeAbi(__retval);
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("FBC4DD29-245B-11E4-AF98-689423260CF8")]
    internal unsafe interface IMemoryBufferReference : global::Windows.Foundation.IMemoryBufferReference
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IMemoryBufferReference()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IMemoryBufferReference), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 3);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_get_Capacity_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, global::WinRT.EventRegistrationToken*, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_add_Closed_1;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::WinRT.EventRegistrationToken, int>*)AbiToProjectionVftablePtr)[8] = &Do_Abi_remove_Closed_2;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Capacity_0(IntPtr thisPtr, uint* value)
        {
            uint __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IMemoryBufferReference>(thisPtr).Capacity;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        private static global::System.Runtime.CompilerServices.ConditionalWeakTable<global::Windows.Foundation.IMemoryBufferReference, global::WinRT.EventRegistrationTokenTable<global::Windows.Foundation.TypedEventHandler<global::Windows.Foundation.IMemoryBufferReference, object>>> _Closed_TokenTables = new global::System.Runtime.CompilerServices.ConditionalWeakTable<global::Windows.Foundation.IMemoryBufferReference, global::WinRT.EventRegistrationTokenTable<global::Windows.Foundation.TypedEventHandler<global::Windows.Foundation.IMemoryBufferReference, object>>>();
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_add_Closed_1(IntPtr thisPtr, IntPtr handler, global::WinRT.EventRegistrationToken* cookie)
        {
            *cookie = default;
            try
            {
                var __this = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IMemoryBufferReference>(thisPtr);
                var __handler = TypedEventHandler<global::Windows.Foundation.IMemoryBufferReference, object>.FromAbi(handler);
                *cookie = _Closed_TokenTables.GetOrCreateValue(__this).AddEventHandler(__handler);
                __this.Closed += __handler;
                return 0;
            }
            catch (Exception __ex)
            {
                return __ex.HResult;
            }
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_remove_Closed_2(IntPtr thisPtr, global::WinRT.EventRegistrationToken cookie)
        {
            try
            {
                var __this = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IMemoryBufferReference>(thisPtr);
                if(__this != null && _Closed_TokenTables.TryGetValue(__this, out var __table) && __table.RemoveEventHandler(cookie, out var __handler))
                {
                    __this.Closed -= __handler;
                }
                return 0;
            }
            catch (Exception __ex)
            {
                return __ex.HResult;
            }
        }

        unsafe uint global::Windows.Foundation.IMemoryBufferReference.Capacity
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IMemoryBufferReference).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                uint __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out uint, int>**)ThisPtr)[6](ThisPtr, out __retval));
                return __retval;
            }
        }

        event global::Windows.Foundation.TypedEventHandler<global::Windows.Foundation.IMemoryBufferReference, object> global::Windows.Foundation.IMemoryBufferReference.Closed
        {
            add => _Closed.GetValue((IWinRTObject)this, (key) =>
            {

                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IMemoryBufferReference).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                return 
                    new EventSource<global::Windows.Foundation.TypedEventHandler<global::Windows.Foundation.IMemoryBufferReference, object>>(_obj,
                    (*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out global::WinRT.EventRegistrationToken, int>**)ThisPtr)[7],
                    (*(delegate* unmanaged[Stdcall]<IntPtr, global::WinRT.EventRegistrationToken, int>**)ThisPtr)[8]);
            }).Subscribe(value);
            remove => _Closed.GetValue((IWinRTObject)this, (key) =>
            {

                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IMemoryBufferReference).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                return 
                    new EventSource<global::Windows.Foundation.TypedEventHandler<global::Windows.Foundation.IMemoryBufferReference, object>>(_obj,
                    (*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out global::WinRT.EventRegistrationToken, int>**)ThisPtr)[7],
                    (*(delegate* unmanaged[Stdcall]<IntPtr, global::WinRT.EventRegistrationToken, int>**)ThisPtr)[8]);
            }).Unsubscribe(value);
        }

        private static global::System.Runtime.CompilerServices.ConditionalWeakTable<IWinRTObject, EventSource<global::Windows.Foundation.TypedEventHandler<global::Windows.Foundation.IMemoryBufferReference, object>>> _Closed = new();
        void global::System.IDisposable.Dispose() => ((global::System.IDisposable)(IWinRTObject)this).Dispose();
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("629BDBC8-D932-4FF4-96B9-8D96C5C1E858")]
    internal unsafe interface IPropertyValueStatics : global::Windows.Foundation.IPropertyValueStatics
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IPropertyValueStatics()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IPropertyValueStatics), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 39);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_CreateEmpty_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, byte, IntPtr*, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_CreateUInt8_1;
            ((delegate* unmanaged[Stdcall]<IntPtr, short, IntPtr*, int>*)AbiToProjectionVftablePtr)[8] = &Do_Abi_CreateInt16_2;
            ((delegate* unmanaged[Stdcall]<IntPtr, ushort, IntPtr*, int>*)AbiToProjectionVftablePtr)[9] = &Do_Abi_CreateUInt16_3;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr*, int>*)AbiToProjectionVftablePtr)[10] = &Do_Abi_CreateInt32_4;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint, IntPtr*, int>*)AbiToProjectionVftablePtr)[11] = &Do_Abi_CreateUInt32_5;
            ((delegate* unmanaged[Stdcall]<IntPtr, long, IntPtr*, int>*)AbiToProjectionVftablePtr)[12] = &Do_Abi_CreateInt64_6;
            ((delegate* unmanaged[Stdcall]<IntPtr, ulong, IntPtr*, int>*)AbiToProjectionVftablePtr)[13] = &Do_Abi_CreateUInt64_7;
            ((delegate* unmanaged[Stdcall]<IntPtr, float, IntPtr*, int>*)AbiToProjectionVftablePtr)[14] = &Do_Abi_CreateSingle_8;
            ((delegate* unmanaged[Stdcall]<IntPtr, double, IntPtr*, int>*)AbiToProjectionVftablePtr)[15] = &Do_Abi_CreateDouble_9;
            ((delegate* unmanaged[Stdcall]<IntPtr, ushort, IntPtr*, int>*)AbiToProjectionVftablePtr)[16] = &Do_Abi_CreateChar16_10;
            ((delegate* unmanaged[Stdcall]<IntPtr, byte, IntPtr*, int>*)AbiToProjectionVftablePtr)[17] = &Do_Abi_CreateBoolean_11;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[18] = &Do_Abi_CreateString_12;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[19] = &Do_Abi_CreateInspectable_13;
            ((delegate* unmanaged[Stdcall]<IntPtr, Guid, IntPtr*, int>*)AbiToProjectionVftablePtr)[20] = &Do_Abi_CreateGuid_14;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::ABI.System.DateTimeOffset, IntPtr*, int>*)AbiToProjectionVftablePtr)[21] = &Do_Abi_CreateDateTime_15;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::ABI.System.TimeSpan, IntPtr*, int>*)AbiToProjectionVftablePtr)[22] = &Do_Abi_CreateTimeSpan_16;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Foundation.Point, IntPtr*, int>*)AbiToProjectionVftablePtr)[23] = &Do_Abi_CreatePoint_17;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Foundation.Size, IntPtr*, int>*)AbiToProjectionVftablePtr)[24] = &Do_Abi_CreateSize_18;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Foundation.Rect, IntPtr*, int>*)AbiToProjectionVftablePtr)[25] = &Do_Abi_CreateRect_19;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[26] = &Do_Abi_CreateUInt8Array_20;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[27] = &Do_Abi_CreateInt16Array_21;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[28] = &Do_Abi_CreateUInt16Array_22;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[29] = &Do_Abi_CreateInt32Array_23;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[30] = &Do_Abi_CreateUInt32Array_24;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[31] = &Do_Abi_CreateInt64Array_25;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[32] = &Do_Abi_CreateUInt64Array_26;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[33] = &Do_Abi_CreateSingleArray_27;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[34] = &Do_Abi_CreateDoubleArray_28;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[35] = &Do_Abi_CreateChar16Array_29;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[36] = &Do_Abi_CreateBooleanArray_30;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[37] = &Do_Abi_CreateStringArray_31;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[38] = &Do_Abi_CreateInspectableArray_32;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[39] = &Do_Abi_CreateGuidArray_33;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[40] = &Do_Abi_CreateDateTimeArray_34;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[41] = &Do_Abi_CreateTimeSpanArray_35;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[42] = &Do_Abi_CreatePointArray_36;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[43] = &Do_Abi_CreateSizeArray_37;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[44] = &Do_Abi_CreateRectArray_38;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateEmpty_0(IntPtr thisPtr, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateEmpty();
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateUInt8_1(IntPtr thisPtr, byte value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateUInt8(value);
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateInt16_2(IntPtr thisPtr, short value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateInt16(value);
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateUInt16_3(IntPtr thisPtr, ushort value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateUInt16(value);
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateInt32_4(IntPtr thisPtr, int value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateInt32(value);
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateUInt32_5(IntPtr thisPtr, uint value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateUInt32(value);
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateInt64_6(IntPtr thisPtr, long value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateInt64(value);
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateUInt64_7(IntPtr thisPtr, ulong value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateUInt64(value);
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateSingle_8(IntPtr thisPtr, float value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateSingle(value);
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateDouble_9(IntPtr thisPtr, double value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateDouble(value);
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateChar16_10(IntPtr thisPtr, ushort value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateChar16((char)value);
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateBoolean_11(IntPtr thisPtr, byte value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateBoolean(value != 0);
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateString_12(IntPtr thisPtr, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateString(MarshalString.FromAbi(value));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateInspectable_13(IntPtr thisPtr, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateInspectable(MarshalInspectable<object>.FromAbi(value));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateGuid_14(IntPtr thisPtr, Guid value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateGuid(value);
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateDateTime_15(IntPtr thisPtr, global::ABI.System.DateTimeOffset value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateDateTime(global::ABI.System.DateTimeOffset.FromAbi(value));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateTimeSpan_16(IntPtr thisPtr, global::ABI.System.TimeSpan value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateTimeSpan(global::ABI.System.TimeSpan.FromAbi(value));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreatePoint_17(IntPtr thisPtr, global::Windows.Foundation.Point value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreatePoint(value);
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateSize_18(IntPtr thisPtr, global::Windows.Foundation.Size value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateSize(value);
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateRect_19(IntPtr thisPtr, global::Windows.Foundation.Rect value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateRect(value);
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateUInt8Array_20(IntPtr thisPtr, int __valueSize, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateUInt8Array(MarshalBlittable<byte>.FromAbiArray((__valueSize, value)));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateInt16Array_21(IntPtr thisPtr, int __valueSize, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateInt16Array(MarshalBlittable<short>.FromAbiArray((__valueSize, value)));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateUInt16Array_22(IntPtr thisPtr, int __valueSize, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateUInt16Array(MarshalBlittable<ushort>.FromAbiArray((__valueSize, value)));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateInt32Array_23(IntPtr thisPtr, int __valueSize, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateInt32Array(MarshalBlittable<int>.FromAbiArray((__valueSize, value)));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateUInt32Array_24(IntPtr thisPtr, int __valueSize, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateUInt32Array(MarshalBlittable<uint>.FromAbiArray((__valueSize, value)));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateInt64Array_25(IntPtr thisPtr, int __valueSize, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateInt64Array(MarshalBlittable<long>.FromAbiArray((__valueSize, value)));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateUInt64Array_26(IntPtr thisPtr, int __valueSize, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateUInt64Array(MarshalBlittable<ulong>.FromAbiArray((__valueSize, value)));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateSingleArray_27(IntPtr thisPtr, int __valueSize, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateSingleArray(MarshalBlittable<float>.FromAbiArray((__valueSize, value)));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateDoubleArray_28(IntPtr thisPtr, int __valueSize, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateDoubleArray(MarshalBlittable<double>.FromAbiArray((__valueSize, value)));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateChar16Array_29(IntPtr thisPtr, int __valueSize, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateChar16Array(MarshalNonBlittable<char>.FromAbiArray((__valueSize, value)));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateBooleanArray_30(IntPtr thisPtr, int __valueSize, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateBooleanArray(MarshalNonBlittable<bool>.FromAbiArray((__valueSize, value)));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateStringArray_31(IntPtr thisPtr, int __valueSize, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateStringArray(MarshalString.FromAbiArray((__valueSize, value)));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateInspectableArray_32(IntPtr thisPtr, int __valueSize, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateInspectableArray(MarshalInspectable<object>.FromAbiArray((__valueSize, value)));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateGuidArray_33(IntPtr thisPtr, int __valueSize, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateGuidArray(MarshalBlittable<Guid>.FromAbiArray((__valueSize, value)));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateDateTimeArray_34(IntPtr thisPtr, int __valueSize, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateDateTimeArray(MarshalNonBlittable<global::System.DateTimeOffset>.FromAbiArray((__valueSize, value)));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateTimeSpanArray_35(IntPtr thisPtr, int __valueSize, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateTimeSpanArray(MarshalNonBlittable<global::System.TimeSpan>.FromAbiArray((__valueSize, value)));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreatePointArray_36(IntPtr thisPtr, int __valueSize, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreatePointArray(MarshalBlittable<global::Windows.Foundation.Point>.FromAbiArray((__valueSize, value)));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateSizeArray_37(IntPtr thisPtr, int __valueSize, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateSizeArray(MarshalBlittable<global::Windows.Foundation.Size>.FromAbiArray((__valueSize, value)));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateRectArray_38(IntPtr thisPtr, int __valueSize, IntPtr value, IntPtr* propertyValue)
        {
            object __propertyValue = default;

            *propertyValue = default;

            try
            {
                __propertyValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IPropertyValueStatics>(thisPtr).CreateRectArray(MarshalBlittable<global::Windows.Foundation.Rect>.FromAbiArray((__valueSize, value)));
                *propertyValue = MarshalInspectable<object>.FromManaged(__propertyValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateEmpty()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateUInt8(byte value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, byte, out IntPtr, int>**)ThisPtr)[7](ThisPtr, value, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateInt16(short value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, short, out IntPtr, int>**)ThisPtr)[8](ThisPtr, value, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateUInt16(ushort value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, ushort, out IntPtr, int>**)ThisPtr)[9](ThisPtr, value, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateInt32(int value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, out IntPtr, int>**)ThisPtr)[10](ThisPtr, value, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateUInt32(uint value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint, out IntPtr, int>**)ThisPtr)[11](ThisPtr, value, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateInt64(long value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, long, out IntPtr, int>**)ThisPtr)[12](ThisPtr, value, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateUInt64(ulong value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, ulong, out IntPtr, int>**)ThisPtr)[13](ThisPtr, value, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateSingle(float value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, float, out IntPtr, int>**)ThisPtr)[14](ThisPtr, value, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateDouble(double value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, double, out IntPtr, int>**)ThisPtr)[15](ThisPtr, value, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateChar16(char value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, ushort, out IntPtr, int>**)ThisPtr)[16](ThisPtr, (ushort)value, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateBoolean(bool value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, byte, out IntPtr, int>**)ThisPtr)[17](ThisPtr, (byte)(value ? 1 : 0), out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateString(string value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalString __value = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalString.CreateMarshaler(value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[18](ThisPtr, MarshalString.GetAbi(__value), out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalString.DisposeMarshaler(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateInspectable(object value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IObjectReference __value = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalInspectable<object>.CreateMarshaler(value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[19](ThisPtr, MarshalInspectable<object>.GetAbi(__value), out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateGuid(Guid value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, Guid, out IntPtr, int>**)ThisPtr)[20](ThisPtr, value, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateDateTime(global::System.DateTimeOffset value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::ABI.System.DateTimeOffset.Marshaler __value = default;
            IntPtr __retval = default;
            try
            {
                __value = global::ABI.System.DateTimeOffset.CreateMarshaler(value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::ABI.System.DateTimeOffset, out IntPtr, int>**)ThisPtr)[21](ThisPtr, global::ABI.System.DateTimeOffset.GetAbi(__value), out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                global::ABI.System.DateTimeOffset.DisposeMarshaler(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateTimeSpan(global::System.TimeSpan value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            global::ABI.System.TimeSpan.Marshaler __value = default;
            IntPtr __retval = default;
            try
            {
                __value = global::ABI.System.TimeSpan.CreateMarshaler(value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::ABI.System.TimeSpan, out IntPtr, int>**)ThisPtr)[22](ThisPtr, global::ABI.System.TimeSpan.GetAbi(__value), out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                global::ABI.System.TimeSpan.DisposeMarshaler(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreatePoint(global::Windows.Foundation.Point value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Foundation.Point, out IntPtr, int>**)ThisPtr)[23](ThisPtr, value, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateSize(global::Windows.Foundation.Size value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Foundation.Size, out IntPtr, int>**)ThisPtr)[24](ThisPtr, value, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateRect(global::Windows.Foundation.Rect value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Foundation.Rect, out IntPtr, int>**)ThisPtr)[25](ThisPtr, value, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateUInt8Array(byte[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalBlittable<byte>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalBlittable<byte>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalBlittable<byte>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, out IntPtr, int>**)ThisPtr)[26](ThisPtr, __value_length, __value_data, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalBlittable<byte>.DisposeMarshalerArray(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateInt16Array(short[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalBlittable<short>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalBlittable<short>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalBlittable<short>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, out IntPtr, int>**)ThisPtr)[27](ThisPtr, __value_length, __value_data, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalBlittable<short>.DisposeMarshalerArray(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateUInt16Array(ushort[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalBlittable<ushort>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalBlittable<ushort>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalBlittable<ushort>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, out IntPtr, int>**)ThisPtr)[28](ThisPtr, __value_length, __value_data, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalBlittable<ushort>.DisposeMarshalerArray(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateInt32Array(int[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalBlittable<int>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalBlittable<int>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalBlittable<int>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, out IntPtr, int>**)ThisPtr)[29](ThisPtr, __value_length, __value_data, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalBlittable<int>.DisposeMarshalerArray(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateUInt32Array(uint[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalBlittable<uint>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalBlittable<uint>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalBlittable<uint>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, out IntPtr, int>**)ThisPtr)[30](ThisPtr, __value_length, __value_data, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalBlittable<uint>.DisposeMarshalerArray(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateInt64Array(long[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalBlittable<long>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalBlittable<long>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalBlittable<long>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, out IntPtr, int>**)ThisPtr)[31](ThisPtr, __value_length, __value_data, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalBlittable<long>.DisposeMarshalerArray(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateUInt64Array(ulong[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalBlittable<ulong>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalBlittable<ulong>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalBlittable<ulong>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, out IntPtr, int>**)ThisPtr)[32](ThisPtr, __value_length, __value_data, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalBlittable<ulong>.DisposeMarshalerArray(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateSingleArray(float[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalBlittable<float>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalBlittable<float>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalBlittable<float>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, out IntPtr, int>**)ThisPtr)[33](ThisPtr, __value_length, __value_data, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalBlittable<float>.DisposeMarshalerArray(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateDoubleArray(double[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalBlittable<double>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalBlittable<double>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalBlittable<double>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, out IntPtr, int>**)ThisPtr)[34](ThisPtr, __value_length, __value_data, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalBlittable<double>.DisposeMarshalerArray(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateChar16Array(char[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalNonBlittable<char>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalNonBlittable<char>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalNonBlittable<char>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, out IntPtr, int>**)ThisPtr)[35](ThisPtr, __value_length, __value_data, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalNonBlittable<char>.DisposeMarshalerArray(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateBooleanArray(bool[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalNonBlittable<bool>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalNonBlittable<bool>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalNonBlittable<bool>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, out IntPtr, int>**)ThisPtr)[36](ThisPtr, __value_length, __value_data, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalNonBlittable<bool>.DisposeMarshalerArray(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateStringArray(string[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalString.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalString.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalString.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, out IntPtr, int>**)ThisPtr)[37](ThisPtr, __value_length, __value_data, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalString.DisposeMarshalerArray(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateInspectableArray(object[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalInterfaceHelper<object>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalInspectable<object>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalInspectable<object>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, out IntPtr, int>**)ThisPtr)[38](ThisPtr, __value_length, __value_data, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshalerArray(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateGuidArray(Guid[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalBlittable<Guid>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalBlittable<Guid>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalBlittable<Guid>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, out IntPtr, int>**)ThisPtr)[39](ThisPtr, __value_length, __value_data, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalBlittable<Guid>.DisposeMarshalerArray(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateDateTimeArray(global::System.DateTimeOffset[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalNonBlittable<global::System.DateTimeOffset>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalNonBlittable<global::System.DateTimeOffset>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalNonBlittable<global::System.DateTimeOffset>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, out IntPtr, int>**)ThisPtr)[40](ThisPtr, __value_length, __value_data, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalNonBlittable<global::System.DateTimeOffset>.DisposeMarshalerArray(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateTimeSpanArray(global::System.TimeSpan[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalNonBlittable<global::System.TimeSpan>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalNonBlittable<global::System.TimeSpan>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalNonBlittable<global::System.TimeSpan>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, out IntPtr, int>**)ThisPtr)[41](ThisPtr, __value_length, __value_data, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalNonBlittable<global::System.TimeSpan>.DisposeMarshalerArray(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreatePointArray(global::Windows.Foundation.Point[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalBlittable<global::Windows.Foundation.Point>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalBlittable<global::Windows.Foundation.Point>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalBlittable<global::Windows.Foundation.Point>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, out IntPtr, int>**)ThisPtr)[42](ThisPtr, __value_length, __value_data, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalBlittable<global::Windows.Foundation.Point>.DisposeMarshalerArray(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateSizeArray(global::Windows.Foundation.Size[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalBlittable<global::Windows.Foundation.Size>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalBlittable<global::Windows.Foundation.Size>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalBlittable<global::Windows.Foundation.Size>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, out IntPtr, int>**)ThisPtr)[43](ThisPtr, __value_length, __value_data, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalBlittable<global::Windows.Foundation.Size>.DisposeMarshalerArray(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }

        unsafe object global::Windows.Foundation.IPropertyValueStatics.CreateRectArray(global::Windows.Foundation.Rect[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IPropertyValueStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalBlittable<global::Windows.Foundation.Rect>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            IntPtr __retval = default;
            try
            {
                __value = MarshalBlittable<global::Windows.Foundation.Rect>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalBlittable<global::Windows.Foundation.Rect>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, out IntPtr, int>**)ThisPtr)[44](ThisPtr, __value_length, __value_data, out __retval));
                return MarshalInspectable<object>.FromAbi(__retval);
            }
            finally
            {
                MarshalBlittable<global::Windows.Foundation.Rect>.DisposeMarshalerArray(__value);
                MarshalInspectable<object>.DisposeAbi(__retval);
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("96369F54-8EB6-48F0-ABCE-C1B211E627C3")]
    internal unsafe interface IStringable : global::Windows.Foundation.IStringable
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IStringable()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IStringable), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 1);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_ToString_0;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ToString_0(IntPtr thisPtr, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IStringable>(thisPtr).ToString();
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe string global::Windows.Foundation.IStringable.ToString()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IStringable).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, out __retval));
                return MarshalString.FromAbi(__retval);
            }
            finally
            {
                MarshalString.DisposeAbi(__retval);
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("C1D432BA-C824-4452-A7FD-512BC3BBE9A1")]
    internal unsafe interface IUriEscapeStatics : global::Windows.Foundation.IUriEscapeStatics
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IUriEscapeStatics()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IUriEscapeStatics), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 2);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_UnescapeComponent_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_EscapeComponent_1;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_UnescapeComponent_0(IntPtr thisPtr, IntPtr toUnescape, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriEscapeStatics>(thisPtr).UnescapeComponent(MarshalString.FromAbi(toUnescape));
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_EscapeComponent_1(IntPtr thisPtr, IntPtr toEscape, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriEscapeStatics>(thisPtr).EscapeComponent(MarshalString.FromAbi(toEscape));
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe string global::Windows.Foundation.IUriEscapeStatics.UnescapeComponent(string toUnescape)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriEscapeStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalString __toUnescape = default;
            IntPtr __retval = default;
            try
            {
                __toUnescape = MarshalString.CreateMarshaler(toUnescape);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, MarshalString.GetAbi(__toUnescape), out __retval));
                return MarshalString.FromAbi(__retval);
            }
            finally
            {
                MarshalString.DisposeMarshaler(__toUnescape);
                MarshalString.DisposeAbi(__retval);
            }
        }

        unsafe string global::Windows.Foundation.IUriEscapeStatics.EscapeComponent(string toEscape)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriEscapeStatics).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalString __toEscape = default;
            IntPtr __retval = default;
            try
            {
                __toEscape = MarshalString.CreateMarshaler(toEscape);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[7](ThisPtr, MarshalString.GetAbi(__toEscape), out __retval));
                return MarshalString.FromAbi(__retval);
            }
            finally
            {
                MarshalString.DisposeMarshaler(__toEscape);
                MarshalString.DisposeAbi(__retval);
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("9E365E57-48B2-4160-956F-C7385120BBFC")]
    internal unsafe interface IUriRuntimeClass : global::Windows.Foundation.IUriRuntimeClass
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IUriRuntimeClass()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IUriRuntimeClass), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 17);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_get_AbsoluteUri_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_get_DisplayUri_1;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[8] = &Do_Abi_get_Domain_2;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[9] = &Do_Abi_get_Extension_3;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[10] = &Do_Abi_get_Fragment_4;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[11] = &Do_Abi_get_Host_5;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[12] = &Do_Abi_get_Password_6;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[13] = &Do_Abi_get_Path_7;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[14] = &Do_Abi_get_Query_8;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[15] = &Do_Abi_get_QueryParsed_9;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[16] = &Do_Abi_get_RawUri_10;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[17] = &Do_Abi_get_SchemeName_11;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[18] = &Do_Abi_get_UserName_12;
            ((delegate* unmanaged[Stdcall]<IntPtr, int*, int>*)AbiToProjectionVftablePtr)[19] = &Do_Abi_get_Port_13;
            ((delegate* unmanaged[Stdcall]<IntPtr, byte*, int>*)AbiToProjectionVftablePtr)[20] = &Do_Abi_get_Suspicious_14;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, byte*, int>*)AbiToProjectionVftablePtr)[21] = &Do_Abi_Equals_15;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[22] = &Do_Abi_CombineUri_16;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_Equals_15(IntPtr thisPtr, IntPtr pUri, byte* value)
        {
            bool __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClass>(thisPtr).Equals(global::ABI.System.Uri.FromAbi(pUri));
                *value = (byte)(__value ? 1 : 0);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CombineUri_16(IntPtr thisPtr, IntPtr relativeUri, IntPtr* instance)
        {
            global::System.Uri __instance = default;

            *instance = default;

            try
            {
                __instance = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClass>(thisPtr).CombineUri(MarshalString.FromAbi(relativeUri));
                *instance = global::ABI.System.Uri.FromManaged(__instance);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_AbsoluteUri_0(IntPtr thisPtr, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClass>(thisPtr).AbsoluteUri;
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_DisplayUri_1(IntPtr thisPtr, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClass>(thisPtr).DisplayUri;
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Domain_2(IntPtr thisPtr, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClass>(thisPtr).Domain;
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Extension_3(IntPtr thisPtr, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClass>(thisPtr).Extension;
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Fragment_4(IntPtr thisPtr, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClass>(thisPtr).Fragment;
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Host_5(IntPtr thisPtr, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClass>(thisPtr).Host;
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Password_6(IntPtr thisPtr, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClass>(thisPtr).Password;
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Path_7(IntPtr thisPtr, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClass>(thisPtr).Path;
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Port_13(IntPtr thisPtr, int* value)
        {
            int __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClass>(thisPtr).Port;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Query_8(IntPtr thisPtr, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClass>(thisPtr).Query;
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_QueryParsed_9(IntPtr thisPtr, IntPtr* ppWwwFormUrlDecoder)
        {
            global::Windows.Foundation.WwwFormUrlDecoder __ppWwwFormUrlDecoder = default;

            *ppWwwFormUrlDecoder = default;

            try
            {
                __ppWwwFormUrlDecoder = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClass>(thisPtr).QueryParsed;
                *ppWwwFormUrlDecoder = global::ABI.Windows.Foundation.WwwFormUrlDecoder.FromManaged(__ppWwwFormUrlDecoder);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_RawUri_10(IntPtr thisPtr, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClass>(thisPtr).RawUri;
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_SchemeName_11(IntPtr thisPtr, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClass>(thisPtr).SchemeName;
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Suspicious_14(IntPtr thisPtr, byte* value)
        {
            bool __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClass>(thisPtr).Suspicious;
                *value = (byte)(__value ? 1 : 0);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_UserName_12(IntPtr thisPtr, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClass>(thisPtr).UserName;
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe bool global::Windows.Foundation.IUriRuntimeClass.Equals(global::System.Uri pUri)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClass).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            IObjectReference __pUri = default;
            byte __retval = default;
            try
            {
                __pUri = global::ABI.System.Uri.CreateMarshaler(pUri);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out byte, int>**)ThisPtr)[21](ThisPtr, global::ABI.System.Uri.GetAbi(__pUri), out __retval));
                return __retval != 0;
            }
            finally
            {
                global::ABI.System.Uri.DisposeMarshaler(__pUri);
            }
        }

        unsafe global::System.Uri global::Windows.Foundation.IUriRuntimeClass.CombineUri(string relativeUri)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClass).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalString __relativeUri = default;
            IntPtr __retval = default;
            try
            {
                __relativeUri = MarshalString.CreateMarshaler(relativeUri);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[22](ThisPtr, MarshalString.GetAbi(__relativeUri), out __retval));
                return global::ABI.System.Uri.FromAbi(__retval);
            }
            finally
            {
                MarshalString.DisposeMarshaler(__relativeUri);
                global::ABI.System.Uri.DisposeAbi(__retval);
            }
        }

        unsafe string global::Windows.Foundation.IUriRuntimeClass.AbsoluteUri
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClass).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, out __retval));
                    return MarshalString.FromAbi(__retval);
                }
                finally
                {
                    MarshalString.DisposeAbi(__retval);
                }
            }
        }

        unsafe string global::Windows.Foundation.IUriRuntimeClass.DisplayUri
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClass).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[7](ThisPtr, out __retval));
                    return MarshalString.FromAbi(__retval);
                }
                finally
                {
                    MarshalString.DisposeAbi(__retval);
                }
            }
        }

        unsafe string global::Windows.Foundation.IUriRuntimeClass.Domain
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClass).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[8](ThisPtr, out __retval));
                    return MarshalString.FromAbi(__retval);
                }
                finally
                {
                    MarshalString.DisposeAbi(__retval);
                }
            }
        }

        unsafe string global::Windows.Foundation.IUriRuntimeClass.Extension
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClass).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[9](ThisPtr, out __retval));
                    return MarshalString.FromAbi(__retval);
                }
                finally
                {
                    MarshalString.DisposeAbi(__retval);
                }
            }
        }

        unsafe string global::Windows.Foundation.IUriRuntimeClass.Fragment
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClass).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[10](ThisPtr, out __retval));
                    return MarshalString.FromAbi(__retval);
                }
                finally
                {
                    MarshalString.DisposeAbi(__retval);
                }
            }
        }

        unsafe string global::Windows.Foundation.IUriRuntimeClass.Host
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClass).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[11](ThisPtr, out __retval));
                    return MarshalString.FromAbi(__retval);
                }
                finally
                {
                    MarshalString.DisposeAbi(__retval);
                }
            }
        }

        unsafe string global::Windows.Foundation.IUriRuntimeClass.Password
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClass).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[12](ThisPtr, out __retval));
                    return MarshalString.FromAbi(__retval);
                }
                finally
                {
                    MarshalString.DisposeAbi(__retval);
                }
            }
        }

        unsafe string global::Windows.Foundation.IUriRuntimeClass.Path
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClass).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[13](ThisPtr, out __retval));
                    return MarshalString.FromAbi(__retval);
                }
                finally
                {
                    MarshalString.DisposeAbi(__retval);
                }
            }
        }

        unsafe int global::Windows.Foundation.IUriRuntimeClass.Port
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClass).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                int __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out int, int>**)ThisPtr)[19](ThisPtr, out __retval));
                return __retval;
            }
        }

        unsafe string global::Windows.Foundation.IUriRuntimeClass.Query
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClass).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[14](ThisPtr, out __retval));
                    return MarshalString.FromAbi(__retval);
                }
                finally
                {
                    MarshalString.DisposeAbi(__retval);
                }
            }
        }

        unsafe global::Windows.Foundation.WwwFormUrlDecoder global::Windows.Foundation.IUriRuntimeClass.QueryParsed
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClass).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[15](ThisPtr, out __retval));
                    return global::ABI.Windows.Foundation.WwwFormUrlDecoder.FromAbi(__retval);
                }
                finally
                {
                    global::ABI.Windows.Foundation.WwwFormUrlDecoder.DisposeAbi(__retval);
                }
            }
        }

        unsafe string global::Windows.Foundation.IUriRuntimeClass.RawUri
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClass).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[16](ThisPtr, out __retval));
                    return MarshalString.FromAbi(__retval);
                }
                finally
                {
                    MarshalString.DisposeAbi(__retval);
                }
            }
        }

        unsafe string global::Windows.Foundation.IUriRuntimeClass.SchemeName
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClass).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[17](ThisPtr, out __retval));
                    return MarshalString.FromAbi(__retval);
                }
                finally
                {
                    MarshalString.DisposeAbi(__retval);
                }
            }
        }

        unsafe bool global::Windows.Foundation.IUriRuntimeClass.Suspicious
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClass).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                byte __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out byte, int>**)ThisPtr)[20](ThisPtr, out __retval));
                return __retval != 0;
            }
        }

        unsafe string global::Windows.Foundation.IUriRuntimeClass.UserName
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClass).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[18](ThisPtr, out __retval));
                    return MarshalString.FromAbi(__retval);
                }
                finally
                {
                    MarshalString.DisposeAbi(__retval);
                }
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("44A9796F-723E-4FDF-A218-033E75B0C084")]
    internal unsafe interface IUriRuntimeClassFactory : global::Windows.Foundation.IUriRuntimeClassFactory
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IUriRuntimeClassFactory()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IUriRuntimeClassFactory), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 2);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_CreateUri_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_CreateWithRelativeUri_1;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateUri_0(IntPtr thisPtr, IntPtr uri, IntPtr* instance)
        {
            global::System.Uri __instance = default;

            *instance = default;

            try
            {
                __instance = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClassFactory>(thisPtr).CreateUri(MarshalString.FromAbi(uri));
                *instance = global::ABI.System.Uri.FromManaged(__instance);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateWithRelativeUri_1(IntPtr thisPtr, IntPtr baseUri, IntPtr relativeUri, IntPtr* instance)
        {
            global::System.Uri __instance = default;

            *instance = default;

            try
            {
                __instance = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClassFactory>(thisPtr).CreateWithRelativeUri(MarshalString.FromAbi(baseUri), MarshalString.FromAbi(relativeUri));
                *instance = global::ABI.System.Uri.FromManaged(__instance);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::System.Uri global::Windows.Foundation.IUriRuntimeClassFactory.CreateUri(string uri)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClassFactory).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalString __uri = default;
            IntPtr __retval = default;
            try
            {
                __uri = MarshalString.CreateMarshaler(uri);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, MarshalString.GetAbi(__uri), out __retval));
                return global::ABI.System.Uri.FromAbi(__retval);
            }
            finally
            {
                MarshalString.DisposeMarshaler(__uri);
                global::ABI.System.Uri.DisposeAbi(__retval);
            }
        }

        unsafe global::System.Uri global::Windows.Foundation.IUriRuntimeClassFactory.CreateWithRelativeUri(string baseUri, string relativeUri)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClassFactory).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalString __baseUri = default;
            MarshalString __relativeUri = default;
            IntPtr __retval = default;
            try
            {
                __baseUri = MarshalString.CreateMarshaler(baseUri);
                __relativeUri = MarshalString.CreateMarshaler(relativeUri);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[7](ThisPtr, MarshalString.GetAbi(__baseUri), MarshalString.GetAbi(__relativeUri), out __retval));
                return global::ABI.System.Uri.FromAbi(__retval);
            }
            finally
            {
                MarshalString.DisposeMarshaler(__baseUri);
                MarshalString.DisposeMarshaler(__relativeUri);
                global::ABI.System.Uri.DisposeAbi(__retval);
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("758D9661-221C-480F-A339-50656673F46F")]
    internal unsafe interface IUriRuntimeClassWithAbsoluteCanonicalUri : global::Windows.Foundation.IUriRuntimeClassWithAbsoluteCanonicalUri
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IUriRuntimeClassWithAbsoluteCanonicalUri()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IUriRuntimeClassWithAbsoluteCanonicalUri), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 2);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_get_AbsoluteCanonicalUri_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_get_DisplayIri_1;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_AbsoluteCanonicalUri_0(IntPtr thisPtr, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClassWithAbsoluteCanonicalUri>(thisPtr).AbsoluteCanonicalUri;
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_DisplayIri_1(IntPtr thisPtr, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IUriRuntimeClassWithAbsoluteCanonicalUri>(thisPtr).DisplayIri;
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe string global::Windows.Foundation.IUriRuntimeClassWithAbsoluteCanonicalUri.AbsoluteCanonicalUri
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClassWithAbsoluteCanonicalUri).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, out __retval));
                    return MarshalString.FromAbi(__retval);
                }
                finally
                {
                    MarshalString.DisposeAbi(__retval);
                }
            }
        }

        unsafe string global::Windows.Foundation.IUriRuntimeClassWithAbsoluteCanonicalUri.DisplayIri
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IUriRuntimeClassWithAbsoluteCanonicalUri).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[7](ThisPtr, out __retval));
                    return MarshalString.FromAbi(__retval);
                }
                finally
                {
                    MarshalString.DisposeAbi(__retval);
                }
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("125E7431-F678-4E8E-B670-20A9B06C512D")]
    internal unsafe interface IWwwFormUrlDecoderEntry : global::Windows.Foundation.IWwwFormUrlDecoderEntry
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IWwwFormUrlDecoderEntry()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IWwwFormUrlDecoderEntry), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 2);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_get_Name_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_get_Value_1;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Name_0(IntPtr thisPtr, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IWwwFormUrlDecoderEntry>(thisPtr).Name;
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Value_1(IntPtr thisPtr, IntPtr* value)
        {
            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IWwwFormUrlDecoderEntry>(thisPtr).Value;
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe string global::Windows.Foundation.IWwwFormUrlDecoderEntry.Name
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IWwwFormUrlDecoderEntry).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, out __retval));
                    return MarshalString.FromAbi(__retval);
                }
                finally
                {
                    MarshalString.DisposeAbi(__retval);
                }
            }
        }

        unsafe string global::Windows.Foundation.IWwwFormUrlDecoderEntry.Value
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IWwwFormUrlDecoderEntry).TypeHandle));
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                try
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>**)ThisPtr)[7](ThisPtr, out __retval));
                    return MarshalString.FromAbi(__retval);
                }
                finally
                {
                    MarshalString.DisposeAbi(__retval);
                }
            }
        }
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("D45A0451-F225-4542-9296-0E1DF5D254DF")]
    internal unsafe interface IWwwFormUrlDecoderRuntimeClass : global::Windows.Foundation.IWwwFormUrlDecoderRuntimeClass
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IWwwFormUrlDecoderRuntimeClass()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IWwwFormUrlDecoderRuntimeClass), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 1);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_GetFirstValueByName_0;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_GetFirstValueByName_0(IntPtr thisPtr, IntPtr name, IntPtr* phstrValue)
        {
            string __phstrValue = default;

            *phstrValue = default;

            try
            {
                __phstrValue = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IWwwFormUrlDecoderRuntimeClass>(thisPtr).GetFirstValueByName(MarshalString.FromAbi(name));
                *phstrValue = MarshalString.FromManaged(__phstrValue);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe string global::Windows.Foundation.IWwwFormUrlDecoderRuntimeClass.GetFirstValueByName(string name)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IWwwFormUrlDecoderRuntimeClass).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalString __name = default;
            IntPtr __retval = default;
            try
            {
                __name = MarshalString.CreateMarshaler(name);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, MarshalString.GetAbi(__name), out __retval));
                return MarshalString.FromAbi(__retval);
            }
            finally
            {
                MarshalString.DisposeMarshaler(__name);
                MarshalString.DisposeAbi(__retval);
            }
        }

        int global::System.Collections.Generic.IReadOnlyCollection<global::Windows.Foundation.IWwwFormUrlDecoderEntry>.Count => ((global::System.Collections.Generic.IReadOnlyList<global::Windows.Foundation.IWwwFormUrlDecoderEntry>)(IWinRTObject)this).Count;

        global::Windows.Foundation.IWwwFormUrlDecoderEntry global::System.Collections.Generic.IReadOnlyList<global::Windows.Foundation.IWwwFormUrlDecoderEntry>.this[int index] => ((global::System.Collections.Generic.IReadOnlyList<global::Windows.Foundation.IWwwFormUrlDecoderEntry>)(IWinRTObject)this)[index];

        IEnumerator<global::Windows.Foundation.IWwwFormUrlDecoderEntry> IEnumerable<global::Windows.Foundation.IWwwFormUrlDecoderEntry>.GetEnumerator() => ((global::System.Collections.Generic.IReadOnlyList<global::Windows.Foundation.IWwwFormUrlDecoderEntry>)(IWinRTObject)this).GetEnumerator();
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    }

    [DynamicInterfaceCastableImplementation]
    [Guid("5B8C6B3D-24AE-41B5-A1BF-F0C3D544845B")]
    internal unsafe interface IWwwFormUrlDecoderRuntimeClassFactory : global::Windows.Foundation.IWwwFormUrlDecoderRuntimeClassFactory
    {

        public static IntPtr AbiToProjectionVftablePtr;
        static unsafe IWwwFormUrlDecoderRuntimeClassFactory()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IWwwFormUrlDecoderRuntimeClassFactory), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 1);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_CreateWwwFormUrlDecoder_0;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CreateWwwFormUrlDecoder_0(IntPtr thisPtr, IntPtr query, IntPtr* instance)
        {
            global::Windows.Foundation.WwwFormUrlDecoder __instance = default;

            *instance = default;

            try
            {
                __instance = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Foundation.IWwwFormUrlDecoderRuntimeClassFactory>(thisPtr).CreateWwwFormUrlDecoder(MarshalString.FromAbi(query));
                *instance = global::ABI.Windows.Foundation.WwwFormUrlDecoder.FromManaged(__instance);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Foundation.WwwFormUrlDecoder global::Windows.Foundation.IWwwFormUrlDecoderRuntimeClassFactory.CreateWwwFormUrlDecoder(string query)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Foundation.IWwwFormUrlDecoderRuntimeClassFactory).TypeHandle));
            var ThisPtr = _obj.ThisPtr;

            MarshalString __query = default;
            IntPtr __retval = default;
            try
            {
                __query = MarshalString.CreateMarshaler(query);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>**)ThisPtr)[6](ThisPtr, MarshalString.GetAbi(__query), out __retval));
                return global::ABI.Windows.Foundation.WwwFormUrlDecoder.FromAbi(__retval);
            }
            finally
            {
                MarshalString.DisposeMarshaler(__query);
                global::ABI.Windows.Foundation.WwwFormUrlDecoder.DisposeAbi(__retval);
            }
        }
    }

    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct MemoryBuffer
    {
        public static IObjectReference CreateMarshaler(global::Windows.Foundation.MemoryBuffer obj) => obj is null ? null : MarshalInterface<global::Windows.Foundation.IMemoryBuffer>.CreateMarshaler(obj);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Foundation.MemoryBuffer FromAbi(IntPtr thisPtr) => global::Windows.Foundation.MemoryBuffer.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Foundation.MemoryBuffer obj) => obj is null ? IntPtr.Zero : CreateMarshaler(obj).GetRef();
        public static unsafe MarshalInterfaceHelper<global::Windows.Foundation.MemoryBuffer>.MarshalerArray CreateMarshalerArray(global::Windows.Foundation.MemoryBuffer[] array) => MarshalInterfaceHelper<global::Windows.Foundation.MemoryBuffer>.CreateMarshalerArray(array, (o) => CreateMarshaler(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Foundation.MemoryBuffer>.GetAbiArray(box);
        public static unsafe global::Windows.Foundation.MemoryBuffer[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Foundation.MemoryBuffer>.FromAbiArray(box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Foundation.MemoryBuffer[] array) => MarshalInterfaceHelper<global::Windows.Foundation.MemoryBuffer>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Foundation.MemoryBuffer>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Foundation.MemoryBuffer>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [Guid("9DE1C534-6AE1-11E0-84E1-18A905BCC53F")]
    public static class TypedEventHandler<TSender, TResult>
    {
        public static Guid PIID = GuidGenerator.CreateIID(typeof(global::Windows.Foundation.TypedEventHandler<TSender, TResult>));
        private static readonly Type Abi_Invoke_Type = Expression.GetDelegateType(new Type[] { typeof(void*), Marshaler<TSender>.AbiType, Marshaler<TResult>.AbiType, typeof(int) });

        private static readonly global::WinRT.Interop.IDelegateVftbl AbiToProjectionVftable;
        public static readonly IntPtr AbiToProjectionVftablePtr;

        static unsafe TypedEventHandler()
        {
            AbiInvokeDelegate = global::System.Delegate.CreateDelegate(Abi_Invoke_Type, typeof(TypedEventHandler<TSender, TResult>).GetMethod(nameof(Do_Abi_Invoke), BindingFlags.Static | BindingFlags.NonPublic).MakeGenericMethod(new Type[]{ Marshaler<TSender>.AbiType, Marshaler<TResult>.AbiType })
            );
            AbiToProjectionVftable = new global::WinRT.Interop.IDelegateVftbl
            {
                IUnknownVftbl = global::WinRT.Interop.IUnknownVftbl.AbiToProjectionVftbl,
                Invoke = Marshal.GetFunctionPointerForDelegate(AbiInvokeDelegate)
            };
            var nativeVftbl = ComWrappersSupport.AllocateVtableMemory(typeof(TypedEventHandler<TSender, TResult>), Marshal.SizeOf<global::WinRT.Interop.IDelegateVftbl>());
            Marshal.StructureToPtr(AbiToProjectionVftable, nativeVftbl, false);
            AbiToProjectionVftablePtr = nativeVftbl;
        }

        public static global::System.Delegate AbiInvokeDelegate { get; }

        public static unsafe IObjectReference CreateMarshaler(global::Windows.Foundation.TypedEventHandler<TSender, TResult> managedDelegate) => 
        managedDelegate is null ? null : MarshalDelegate.CreateMarshaler(managedDelegate, GuidGenerator.GetIID(typeof(TypedEventHandler<TSender, TResult>)));

        public static IntPtr GetAbi(IObjectReference value) => MarshalInterfaceHelper<global::Windows.Foundation.TypedEventHandler<TSender, TResult>>.GetAbi(value);

        public static unsafe global::Windows.Foundation.TypedEventHandler<TSender, TResult> FromAbi(IntPtr nativeDelegate)
        {
            var abiDelegate = ObjectReference<IDelegateVftbl>.FromAbi(nativeDelegate);
            return abiDelegate is null ? null : (global::Windows.Foundation.TypedEventHandler<TSender, TResult>)ComWrappersSupport.TryRegisterObjectForInterface(new global::Windows.Foundation.TypedEventHandler<TSender, TResult>(new NativeDelegateWrapper(abiDelegate).Invoke), nativeDelegate);
        }

        [global::WinRT.ObjectReferenceWrapper(nameof(_nativeDelegate))]
        #if NETSTANDARD2_0
        private class NativeDelegateWrapper
        #else
        private class NativeDelegateWrapper : IWinRTObject
        #endif
        {
            private readonly ObjectReference<global::WinRT.Interop.IDelegateVftbl> _nativeDelegate;
            #if NETSTANDARD2_0
            private readonly AgileReference _agileReference = default;
            #endif

            public NativeDelegateWrapper(ObjectReference<global::WinRT.Interop.IDelegateVftbl> nativeDelegate)
            {
                _nativeDelegate = nativeDelegate;
                #if NETSTANDARD2_0
                if (_nativeDelegate.TryAs<ABI.WinRT.Interop.IAgileObject.Vftbl>(out var objRef) < 0)
                {
                    _agileReference = new AgileReference(_nativeDelegate);
                }
                #else
                if (_nativeDelegate.TryAs<IUnknownVftbl>(IAgileObject.IID, out var objRef) < 0)
                {
                    var agileReference = new AgileReference(_nativeDelegate);
                    ((IWinRTObject)this).AdditionalTypeData.TryAdd(typeof(AgileReference).TypeHandle, agileReference);
                }
                #endif
                else
                {
                    objRef.Dispose();
                }
            }

            #if !NETSTANDARD2_0
            IObjectReference IWinRTObject.NativeObject => _nativeDelegate;
            bool IWinRTObject.HasUnwrappableNativeObject => true;
            global::System.Collections.Concurrent.ConcurrentDictionary<global::System.RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache { get; } = new();
            global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData { get; } = new();
            #endif

            public unsafe void Invoke(TSender sender, TResult args)
            {
                #if NETSTANDARD2_0
                var agileReference = _agileReference;
                #else
                var agileReference = ((IWinRTObject)this).AdditionalTypeData.TryGetValue(typeof(AgileReference).TypeHandle, out var agileObj) ? (AgileReference)agileObj : null;
                #endif
                using var agileDelegate = agileReference?.Get()?.As<global::WinRT.Interop.IDelegateVftbl>(GuidGenerator.GetIID(typeof(TypedEventHandler<TSender, TResult>))); 
                var delegateToInvoke = agileDelegate ?? _nativeDelegate;
                IntPtr ThisPtr = delegateToInvoke.ThisPtr;
                var abiInvoke = Marshal.GetDelegateForFunctionPointer(delegateToInvoke.Vftbl.Invoke, Abi_Invoke_Type);
                object __sender = default;
                object __args = default;
                var __params = new object[]{ ThisPtr, null, null };
                try
                {
                    __sender = Marshaler<TSender>.CreateMarshaler(sender);
                    __params[1] = Marshaler<TSender>.GetAbi(__sender);
                    __args = Marshaler<TResult>.CreateMarshaler(args);
                    __params[2] = Marshaler<TResult>.GetAbi(__args);
                    abiInvoke.DynamicInvokeAbi(__params);
                }
                finally
                {
                    Marshaler<TSender>.DisposeMarshaler(__sender);
                    Marshaler<TResult>.DisposeMarshaler(__args);
                }

            }
        }

        public static IntPtr FromManaged(global::Windows.Foundation.TypedEventHandler<TSender, TResult> managedDelegate) => CreateMarshaler(managedDelegate)?.GetRef() ?? IntPtr.Zero;

        public static void DisposeMarshaler(IObjectReference value) => MarshalInterfaceHelper<global::Windows.Foundation.TypedEventHandler<TSender, TResult>>.DisposeMarshaler(value);

        public static void DisposeAbi(IntPtr abi) => MarshalInterfaceHelper<global::Windows.Foundation.TypedEventHandler<TSender, TResult>>.DisposeAbi(abi);

        private static unsafe int Do_Abi_Invoke<TSenderAbi, TResultAbi>(void* thisPtr, TSenderAbi sender, TResultAbi args)
        {


            try
            {
                global::WinRT.ComWrappersSupport.MarshalDelegateInvoke(new IntPtr(thisPtr), (global::System.Delegate invoke) =>
                {
                    invoke.DynamicInvoke(Marshaler<TSender>.FromAbi(sender), Marshaler<TResult>.FromAbi(args));
                });

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
    }

    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct WwwFormUrlDecoder
    {
        public static IObjectReference CreateMarshaler(global::Windows.Foundation.WwwFormUrlDecoder obj) => obj is null ? null : MarshalInspectable<global::Windows.Foundation.WwwFormUrlDecoder>.CreateMarshaler(obj).As<IUnknownVftbl>(GuidGenerator.GetIID(typeof(global::Windows.Foundation.IWwwFormUrlDecoderRuntimeClass).GetHelperType()));
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Foundation.WwwFormUrlDecoder FromAbi(IntPtr thisPtr) => global::Windows.Foundation.WwwFormUrlDecoder.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Foundation.WwwFormUrlDecoder obj) => obj is null ? IntPtr.Zero : CreateMarshaler(obj).GetRef();
        public static unsafe MarshalInterfaceHelper<global::Windows.Foundation.WwwFormUrlDecoder>.MarshalerArray CreateMarshalerArray(global::Windows.Foundation.WwwFormUrlDecoder[] array) => MarshalInterfaceHelper<global::Windows.Foundation.WwwFormUrlDecoder>.CreateMarshalerArray(array, (o) => CreateMarshaler(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Foundation.WwwFormUrlDecoder>.GetAbiArray(box);
        public static unsafe global::Windows.Foundation.WwwFormUrlDecoder[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Foundation.WwwFormUrlDecoder>.FromAbiArray(box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Foundation.WwwFormUrlDecoder[] array) => MarshalInterfaceHelper<global::Windows.Foundation.WwwFormUrlDecoder>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Foundation.WwwFormUrlDecoder>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Foundation.WwwFormUrlDecoder>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct WwwFormUrlDecoderEntry
    {
        public static IObjectReference CreateMarshaler(global::Windows.Foundation.WwwFormUrlDecoderEntry obj) => obj is null ? null : MarshalInterface<global::Windows.Foundation.IWwwFormUrlDecoderEntry>.CreateMarshaler(obj);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Foundation.WwwFormUrlDecoderEntry FromAbi(IntPtr thisPtr) => global::Windows.Foundation.WwwFormUrlDecoderEntry.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Foundation.WwwFormUrlDecoderEntry obj) => obj is null ? IntPtr.Zero : CreateMarshaler(obj).GetRef();
        public static unsafe MarshalInterfaceHelper<global::Windows.Foundation.WwwFormUrlDecoderEntry>.MarshalerArray CreateMarshalerArray(global::Windows.Foundation.WwwFormUrlDecoderEntry[] array) => MarshalInterfaceHelper<global::Windows.Foundation.WwwFormUrlDecoderEntry>.CreateMarshalerArray(array, (o) => CreateMarshaler(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Foundation.WwwFormUrlDecoderEntry>.GetAbiArray(box);
        public static unsafe global::Windows.Foundation.WwwFormUrlDecoderEntry[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Foundation.WwwFormUrlDecoderEntry>.FromAbiArray(box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Foundation.WwwFormUrlDecoderEntry[] array) => MarshalInterfaceHelper<global::Windows.Foundation.WwwFormUrlDecoderEntry>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Foundation.WwwFormUrlDecoderEntry>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Foundation.WwwFormUrlDecoderEntry>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
}
#pragma warning restore CA1416

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

namespace System.Runtime.InteropServices.WindowsRuntime
{
    using System.Diagnostics;
    using System.Threading;
    using System.Threading.Tasks;
    using global::Windows.Foundation;

    /// <summary><p>Provides factory methods to construct WinRT-compatible representations of asynchronous operations.</p>
    /// <p>The factory methods take as inputs functions (delegates) that provide managed Task objects;
    /// Different factory methods return different sub-interfaces of <code>Windows.Foundation.IAyncInfo</code>.
    /// When an asynchronous operation created by this factory is actually started (by calling <code>Start()</code>),
    /// the specified <code>Task</code>-provider delegate will be invoked to create the <code>Task</code> that will
    /// be wrapped by the to-WinRT adapter.</p> </summary>
#if !NETSTANDARD2_0
    [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
    public static class AsyncInfo
    {
        #region Factory methods for creating "normal" IAsyncInfo instances backed by a Task created by a pastProvider delegate

        /// <summary>
        /// Creates and starts an <see cref="IAsyncAction"/> instance from a function that generates
        /// a <see cref="System.Threading.Tasks.Task"/>.
        /// Use this overload if your task supports cancellation in order to hook-up the <code>Cancel</code>
        /// mechanism exposed by the created asynchronous action and the cancellation of your task.</summary>
        /// <param name="taskProvider">The function to invoke to create the task when the IAsyncInfo is started.
        /// The function is passed a <see cref="System.Threading.CancellationToken"/> that the task may monitor
        /// to be notified of a cancellation request;
        /// you may ignore the <code>CancellationToken</code> if your task does not support cancellation.</param>
        /// <returns>An unstarted <see cref="IAsyncAction"/> instance. </returns>
        public static IAsyncAction Run(Func<CancellationToken, Task> taskProvider)
        {
            if (taskProvider == null)
                throw new ArgumentNullException(nameof(taskProvider));

            return new TaskToAsyncActionAdapter(taskProvider);
        }


        /// <summary>
        /// Creates and starts an <see cref="IAsyncActionWithProgress{TProgress}"/> instance from a function
        /// that generates a <see cref="System.Threading.Tasks.Task"/>.
        /// Use this overload if your task supports cancellation and progress monitoring is order to:
        /// (1) hook-up the <code>Cancel</code> mechanism of the created asynchronous action and the cancellation of your task,
        /// and (2) hook-up the <code>Progress</code> update delegate exposed by the created async action and the progress updates
        /// published by your task.</summary>
        /// <param name="taskProvider">The function to invoke to create the task when the IAsyncInfo is started.
        /// The function is passed a <see cref="System.Threading.CancellationToken"/> that the task may monitor
        /// to be notified of a cancellation request;
        /// you may ignore the <code>CancellationToken</code> if your task does not support cancellation.
        /// It is also passed a <see cref="System.IProgress{TProgress}"/> instance to which progress updates may be published;
        /// you may ignore the <code>IProgress</code> if your task does not support progress reporting.</param>
        /// <returns>An unstarted <see cref="IAsyncActionWithProgress{TProgress}"/> instance.</returns>
        public static IAsyncActionWithProgress<TProgress> Run<TProgress>(Func<CancellationToken, IProgress<TProgress>, Task> taskProvider)
        {
            if (taskProvider == null)
                throw new ArgumentNullException(nameof(taskProvider));

            return new TaskToAsyncActionWithProgressAdapter<TProgress>(taskProvider);
        }


        /// <summary>
        /// Creates and starts  an <see cref="IAsyncOperation{TResult}"/> instance from a function
        /// that generates a <see cref="System.Threading.Tasks.Task{TResult}"/>.
        /// Use this overload if your task supports cancellation in order to hook-up the <code>Cancel</code>
        /// mechanism exposed by the created asynchronous operation and the cancellation of your task.</summary>
        /// <param name="taskProvider">The function to invoke to create the task when the IAsyncInfo is started.
        /// The function is passed a <see cref="System.Threading.CancellationToken"/> that the task may monitor
        /// to be notified of a cancellation request;
        /// you may ignore the <code>CancellationToken</code> if your task does not support cancellation.</param>
        /// <returns>An unstarted <see cref="IAsyncOperation{TResult}"/> instance.</returns>
        public static IAsyncOperation<TResult> Run<TResult>(Func<CancellationToken, Task<TResult>> taskProvider)
        {
            // This is only internal to reduce the number of public overloads.
            // Code execution flows through this method when the method above is called. We can always make this public.

            if (taskProvider == null)
                throw new ArgumentNullException(nameof(taskProvider));

            return new TaskToAsyncOperationAdapter<TResult>(taskProvider);
        }


        /// <summary>
        /// Creates and starts  an <see cref="IAsyncOperationWithProgress{TResult, TProgress}"/> instance
        /// from a function that generates a <see cref="System.Threading.Tasks.Task{TResult}"/>.<br />
        /// Use this overload if your task supports cancellation and progress monitoring is order to:
        /// (1) hook-up the <code>Cancel</code> mechanism of the created asynchronous operation and the cancellation of your task,
        /// and (2) hook-up the <code>Progress</code> update delegate exposed by the created async operation and the progress
        /// updates published by your task.</summary>
        /// <typeparam name="TResult">The result type of the task.</typeparam>
        /// <typeparam name="TProgress">The type used for progress notifications.</typeparam>
        /// <param name="taskProvider">The function to invoke to create the task when the IAsyncOperationWithProgress is started.<br />
        /// The function is passed a <see cref="System.Threading.CancellationToken"/> that the task may monitor
        /// to be notified of a cancellation request;
        /// you may ignore the <code>CancellationToken</code> if your task does not support cancellation.
        /// It is also passed a <see cref="System.IProgress{TProgress}"/> instance to which progress updates may be published;
        /// you may ignore the <code>IProgress</code> if your task does not support progress reporting.</param>
        /// <returns>An unstarted <see cref="IAsyncOperationWithProgress{TResult, TProgress}"/> instance.</returns>
        public static IAsyncOperationWithProgress<TResult, TProgress> Run<TResult, TProgress>(
                                                                            Func<CancellationToken, IProgress<TProgress>, Task<TResult>> taskProvider)
        {
            if (taskProvider == null)
                throw new ArgumentNullException(nameof(taskProvider));

            return new TaskToAsyncOperationWithProgressAdapter<TResult, TProgress>(taskProvider);
        }

        #endregion Factory methods for creating "normal" IAsyncInfo instances backed by a Task created by a pastProvider delegate


        #region Factory methods for creating IAsyncInfo instances that have already completed synchronously

        internal static IAsyncAction CreateCompletedAction()
        {
            var asyncInfo = new TaskToAsyncActionAdapter(isCanceled: false);
            return asyncInfo;
        }


        internal static IAsyncActionWithProgress<TProgress> CreateCompletedAction<TProgress>()
        {
            var asyncInfo = new TaskToAsyncActionWithProgressAdapter<TProgress>(isCanceled: false);
            return asyncInfo;
        }


        internal static IAsyncOperation<TResult> CreateCompletedOperation<TResult>(TResult synchronousResult)
        {
            var asyncInfo = new TaskToAsyncOperationAdapter<TResult>(synchronousResult);
            return asyncInfo;
        }


        internal static IAsyncOperationWithProgress<TResult, TProgress> CreateCompletedOperation<TResult, TProgress>(TResult synchronousResult)
        {
            var asyncInfo = new TaskToAsyncOperationWithProgressAdapter<TResult, TProgress>(synchronousResult);
            return asyncInfo;
        }

        #endregion Factory methods for creating IAsyncInfo instances that have already completed synchronously


        #region Factory methods for creating IAsyncInfo instances that have already completed synchronously with an error

        internal static IAsyncAction CreateFaultedAction(Exception error)
        {
            if (error == null)
                throw new ArgumentNullException(nameof(error));

            var asyncInfo = new TaskToAsyncActionAdapter(isCanceled: false);

            asyncInfo.DangerousSetError(error);
            Debug.Assert(asyncInfo.Status == AsyncStatus.Error);

            return asyncInfo;
        }


        internal static IAsyncActionWithProgress<TProgress> CreateFaultedAction<TProgress>(Exception error)
        {
            if (error == null)
                throw new ArgumentNullException(nameof(error));

            var asyncInfo = new TaskToAsyncActionWithProgressAdapter<TProgress>(isCanceled: false);

            asyncInfo.DangerousSetError(error);
            Debug.Assert(asyncInfo.Status == AsyncStatus.Error);

            return asyncInfo;
        }


        internal static IAsyncOperation<TResult> CreateFaultedOperation<TResult>(Exception error)
        {
            if (error == null)
                throw new ArgumentNullException(nameof(error));

            var asyncInfo = new TaskToAsyncOperationAdapter<TResult>(default(TResult));

            asyncInfo.DangerousSetError(error);
            Debug.Assert(asyncInfo.Status == AsyncStatus.Error);

            return asyncInfo;
        }


        internal static IAsyncOperationWithProgress<TResult, TProgress> CreateFaultedOperation<TResult, TProgress>(Exception error)
        {
            if (error == null)
                throw new ArgumentNullException(nameof(error));

            var asyncInfo = new TaskToAsyncOperationWithProgressAdapter<TResult, TProgress>(default(TResult));

            asyncInfo.DangerousSetError(error);
            Debug.Assert(asyncInfo.Status == AsyncStatus.Error);

            return asyncInfo;
        }
        #endregion Factory methods for creating IAsyncInfo instances that have already completed synchronously with an error

    }  // class AsyncInfo
}  // namespace

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

namespace System.Threading.Tasks
{
    using System;
    using System.Threading;
    /// <summary>
    /// Reusable component to generate unique IDs for ann the different implementations of IAsyncInfo in this assembly.
    /// </summary>
    internal static class AsyncInfoIdGenerator
    {
        /// <summary>
        /// We will never generate this Id, so this value can be used as an invalid, uninitialised or a <em>no-Id</em> value.
        /// </summary>
        internal const uint InvalidId = int.MaxValue;


        /// <summary>
        /// We want to avoid ending up with the same ID as a Windows-implemented async info.
        /// At the same time we want to be reproducible. So we use a random generator with a fixed seed.
        /// </summary>
        private static readonly Random s_idGenerator = new Random(19830118);


        /// <summary>
        /// Generate a unique ID that can be used for an IAsyncInfo object.
        /// The returned value will never be equal to <code>AsyncInfoIdGenerator.InvalidId</code>.
        /// </summary>
        /// <returns>A new unique IAsyncInfo Id.</returns>
        internal static uint CreateNext()
        {
            lock (s_idGenerator)
            {
                int newId = s_idGenerator.Next(1, (int)InvalidId);  // Valid IDs will be larger than zero and smaller than InvalidId
                return unchecked((uint)newId);
            }
        }


        /// <summary>
        /// Initialises the specified <code>id</code> to a unique Id-value that can be used for an IAsyncInfo object under the
        /// assumption that another thread may also attempt to initialise <code>id</code>. The thread that changes <code>id</code>
        /// first from <code>AsyncInfoIdGenerator.InvalidId</code> to another value wins and all other threads will respect that
        /// choice and leave <code>id</code> unchanged. The method returns the Id that was agreed upon by the race.
        /// </summary>
        /// <param name="id">The IAsyncInfo ID to initialise.</param>
        /// <returns>The unique value to which the specified reference target was initialised.</returns>
        internal static uint EnsureInitializedThreadsafe(ref uint id)
        {
            if (id != InvalidId)
                return id;

            uint newId = CreateNext();

            // There is no overload of Interlocked.CompareExchange that accepts an UInt32.
            // We apply some pointer tricks to pass the arguments to the overload that takes an Int32.
            // In clear-text, the following unsafe/fixed statement does this:
            //     UInt32 asyncIdVal = Interlocked.CompareExchange(ref id, newId, InvalidId);
            //     if (asyncIdVal == InvalidId)
            //         return newId;

            unsafe
            {
                fixed (uint* idPtr = &id)
                {
                    uint asyncIdVal = unchecked((uint)Interlocked.CompareExchange(ref *(int*)idPtr, (int)newId, (int)InvalidId));
                    if (asyncIdVal == InvalidId)
                        return newId;

                    return asyncIdVal;
                }
            }
        }
    }  // class AsyncInfoIdGenerator
}  // namespace

// AsyncInfoIdGenerator.cs

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace System.Threading.Tasks
{
    using System;
    using System.Runtime.ExceptionServices;
    using System.Threading;
    internal static class ExceptionDispatchHelper
    {
        internal static void ThrowAsync(Exception exception, SynchronizationContext targetContext)
        {
            if (exception == null)
                return;

            // TODO - decide how to cleanly do it so it lights up if TA is defined
            //if (exception is ThreadAbortException)
            //    return;


            ExceptionDispatchInfo exceptionDispatchInfo = ExceptionDispatchInfo.Capture(exception);

            if (targetContext != null)
            {
                try
                {
                    targetContext.Post((edi) => ((ExceptionDispatchInfo)edi!).Throw(), exceptionDispatchInfo);
                }
                catch
                {
                    // Something went wrong in the Post; let's try using the thread pool instead:
                    ThrowAsync(exception, null);
                }
                return;
            }

            bool scheduled = true;
            try
            {
                new SynchronizationContext().Post((edi) => ((ExceptionDispatchInfo)edi!).Throw(), exceptionDispatchInfo);
            }
            catch
            {
                // Something went wrong when scheduling the thrower; we do our best by throwing the exception here:
                scheduled = false;
            }

            if (!scheduled)
                exceptionDispatchInfo.Throw();
        }
    }  // ExceptionDispatchHelper
}  // namespace

// ExceptionDispatchHelper.cs

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace System.Threading.Tasks
{
    using System;
    using System.Diagnostics;
    using System.Threading;
    using System.Threading.Tasks;
    using global::Windows.Foundation;

#if !NETSTANDARD2_0
    [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
    internal class TaskToAsyncActionAdapter
                        : TaskToAsyncInfoAdapter<AsyncActionCompletedHandler, VoidReferenceTypeParameter, VoidValueTypeParameter, VoidValueTypeParameter>,
                          IAsyncAction
    {
        internal TaskToAsyncActionAdapter(Delegate taskGenerator)

             : base(taskGenerator)
        {
        }


        internal TaskToAsyncActionAdapter(Task underlyingTask, CancellationTokenSource underlyingCancelTokenSource)

            : base(underlyingTask, underlyingCancelTokenSource, underlyingProgressDispatcher: null)
        {
        }


        internal TaskToAsyncActionAdapter(bool isCanceled)

            : base(default(VoidValueTypeParameter))
        {
            if (isCanceled)
                DangerousSetCanceled();
        }


        public virtual void GetResults()
        {
            GetResultsInternal();
        }


        internal override void OnCompleted(AsyncActionCompletedHandler userCompletionHandler, AsyncStatus asyncStatus)
        {
            Debug.Assert(userCompletionHandler != null);
            userCompletionHandler(this, asyncStatus);
        }
    }  // class TaskToAsyncActionAdapter
}  // namespace

// TaskToAsyncActionAdapter.cs

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace System.Threading.Tasks
{
    using System;
    using System.Diagnostics;
    using System.Threading;
    using System.Threading.Tasks;
    using global::Windows.Foundation;

#if !NETSTANDARD2_0
    [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
    internal class TaskToAsyncActionWithProgressAdapter<TProgress>
                            : TaskToAsyncInfoAdapter<AsyncActionWithProgressCompletedHandler<TProgress>,
                                                     AsyncActionProgressHandler<TProgress>,
                                                     VoidValueTypeParameter,
                                                     TProgress>,
                              IAsyncActionWithProgress<TProgress>
    {
        internal TaskToAsyncActionWithProgressAdapter(Delegate taskGenerator)

             : base(taskGenerator)
        {
        }


        // This is currently not used, so commented out to save code.
        // Leaving this is the source to be uncommented in case we decide to support IAsyncActionWithProgress-consturction from a Task.
        //
        //internal TaskToAsyncActionWithProgressAdapter(Task underlyingTask, CancellationTokenSource underlyingCancelTokenSource,
        //                                                 Progress<TProgress> underlyingProgressDispatcher)
        //
        //    : base(underlyingTask, underlyingCancelTokenSource, underlyingProgressDispatcher) {
        //}


        internal TaskToAsyncActionWithProgressAdapter(bool isCanceled)

            : base(default(VoidValueTypeParameter))
        {
            if (isCanceled)
                DangerousSetCanceled();
        }


        public virtual void GetResults()
        {
            GetResultsInternal();
        }


        internal override void OnCompleted(AsyncActionWithProgressCompletedHandler<TProgress> userCompletionHandler, AsyncStatus asyncStatus)
        {
            Debug.Assert(userCompletionHandler != null);
            userCompletionHandler(this, asyncStatus);
        }


        internal override void OnProgress(AsyncActionProgressHandler<TProgress> userProgressHandler, TProgress progressInfo)
        {
            Debug.Assert(userProgressHandler != null);
            userProgressHandler(this, progressInfo);
        }
    }  // class TaskToAsyncActionWithProgressAdapter<TProgress>
}  // namespace

// TaskToAsyncActionWithProgressAdapter.cs

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace System.Threading.Tasks
{
    using System;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Diagnostics.Contracts;
    using System.Runtime.ExceptionServices;
    using System.Runtime.InteropServices;
    using System.Threading;
    using global::Windows.Foundation;

    /// <summary>
    /// Implements a wrapper that allows to expose managed <code>System.Threading.Tasks.Task</code> objects as
    /// through the WinRT <code>Windows.Foundation.IAsyncInfo</code> interface.
    /// </summary>
#if !NETSTANDARD2_0
    [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
    internal class TaskToAsyncInfoAdapter<TCompletedHandler, TProgressHandler, TResult, TProgressInfo>
                                                                                : IAsyncInfo, IProgress<TProgressInfo>
                                                                                where TCompletedHandler : class
                                                                                where TProgressHandler : class
    {
        private const int E_ILLEGAL_STATE_CHANGE = unchecked((int)0x8000000D);
        private const int E_ILLEGAL_METHOD_CALL = unchecked((int)0x8000000E);
        private const int E_ILLEGAL_DELEGATE_ASSIGNMENT = unchecked((int)0x80000018);
        private const int E_FAIL = unchecked((int)0x80004005);

        #region Private Types, Statics and Constants

        // ! THIS DIAGRAM ILLUSTRATES THE CONSTANTS BELOW. UPDATE THIS IF UPDATING THE CONSTANTS BELOW!:
        //     3         2         1         0
        //    10987654321098765432109876543210
        //    X...............................   Reserved such that we can use Int32 and not worry about negative-valued state constants
        //    ..X.............................   STATEFLAG_COMPLETED_SYNCHRONOUSLY
        //    ...X............................   STATEFLAG_MUST_RUN_COMPLETION_HNDL_WHEN_SET
        //    ....X...........................   STATEFLAG_COMPLETION_HNDL_NOT_YET_INVOKED
        //    ................................   STATE_NOT_INITIALIZED
        //    ...............................X   STATE_STARTED
        //    ..............................X.   STATE_RUN_TO_COMPLETION
        //    .............................X..   STATE_CANCELLATION_REQUESTED
        //    ............................X...   STATE_CANCELLATION_COMPLETED
        //    ...........................X....   STATE_ERROR
        //    ..........................X.....   STATE_CLOSED
        //    ..........................XXXXXX   STATEMASK_SELECT_ANY_ASYNC_STATE
        //    XXXXXXXXXXXXXXXXXXXXXXXXXX......   STATEMASK_CLEAR_ALL_ASYNC_STATES
        //     3         2         1         0
        //    10987654321098765432109876543210

        // These STATE_XXXX constants describe the async state of this object.
        // Objects of this type are in exactly in one of these states at any given time:
        private const int STATE_NOT_INITIALIZED = 0;   // 0x00
        private const int STATE_STARTED = 1;   // 0x01
        private const int STATE_RUN_TO_COMPLETION = 2;   // 0x02
        private const int STATE_CANCELLATION_REQUESTED = 4;   // 0x04
        private const int STATE_CANCELLATION_COMPLETED = 8;   // 0x08
        private const int STATE_ERROR = 16;  // 0x10
        private const int STATE_CLOSED = 32;  // 0x20

        // The STATEFLAG_XXXX constants can be bitmasked with the states to describe additional
        // state info that cannot be easily inferred from the async state:
        private const int STATEFLAG_COMPLETED_SYNCHRONOUSLY = 0x20000000;
        private const int STATEFLAG_MUST_RUN_COMPLETION_HNDL_WHEN_SET = 0x10000000;
        private const int STATEFLAG_COMPLETION_HNDL_NOT_YET_INVOKED = 0x8000000;

        // These two masks are used to select any STATE_XXXX bits and clear all other (i.e. STATEFLAG_XXXX) bits.
        // It is set to (next power of 2 after the largest STATE_XXXX value) - 1.
        // !!! Make sure to update this if a new STATE_XXXX value is added above !!
        private const int STATEMASK_SELECT_ANY_ASYNC_STATE = (64 - 1);

        // These two masks are used to clear all STATE_XXXX bits and leave any STATEFLAG_XXXX bits.
        private const int STATEMASK_CLEAR_ALL_ASYNC_STATES = ~STATEMASK_SELECT_ANY_ASYNC_STATE;

        private static InvalidOperationException CreateCannotGetResultsFromIncompleteOperationException(Exception cause)
        {
            InvalidOperationException ex = (cause == null)
                            ? new InvalidOperationException(SR.InvalidOperation_CannotGetResultsFromIncompleteOperation)
                            : new InvalidOperationException(SR.InvalidOperation_CannotGetResultsFromIncompleteOperation, cause);
            ex.SetHResult(E_ILLEGAL_METHOD_CALL);
            return ex;
        }

        #endregion Private Types, Statics and Constants


        #region Instance variables

        /// <summary>The token source used to cancel running operations.</summary>
        private CancellationTokenSource _cancelTokenSource = null;

        /// <summary>The async info's ID. InvalidAsyncId stands for not yet been initialised.</summary>
        private uint _id = AsyncInfoIdGenerator.InvalidId;

        /// <summary>The cached error code used to avoid creating several exception objects if the <code>ErrorCode</code>
        /// property is accessed several times. <code>null</code> indicates either no error or that <code>ErrorCode</code>
        /// has not yet been called.</summary>
        private Exception _error = null;

        /// <summary>The state of the async info. Interlocked operations are used to manipulate this field.</summary>
        private volatile int _state = STATE_NOT_INITIALIZED;

        /// <summary>For IAsyncInfo instances that completed synchronously (at creation time) this field holds the result;
        /// for instances backed by an actual Task, this field holds a reference to the task generated by the task generator.
        /// Since we always know which of the above is the case, we can always cast this field to TResult in the former case
        /// or to one of Task or Task{TResult} in the latter case. This approach allows us to save a field on all IAsyncInfos.
        /// Notably, this makes us pay the added cost of boxing for synchronously completing IAsyncInfos where TResult is a
        /// value type, however, this is expected to occur rather rare compared to non-synchronously completed user-IAsyncInfos.</summary>
        private object _dataContainer;

        /// <summary>Registered completed handler.</summary>
        private TCompletedHandler _completedHandler;

        /// <summary>Registered progress handler.</summary>
        private TProgressHandler _progressHandler;

        /// <summary>The synchronization context on which this instance was created/started. Used to callback invocations.</summary>
        private SynchronizationContext _startingContext;

        #endregion Instance variables


        #region Constructors and Destructor

        /// <summary>Creates an IAsyncInfo from the specified delegate. The delegate will be called to construct a task that will
        /// represent the future encapsulated by this IAsyncInfo.</summary>
        /// <param name="taskProvider">The task generator to use for creating the task.</param>
        internal TaskToAsyncInfoAdapter(Delegate taskProvider)
        {
            Debug.Assert(taskProvider != null);
            Debug.Assert((null != (taskProvider as Func<Task>))
                            || (null != (taskProvider as Func<CancellationToken, Task>))
                            || (null != (taskProvider as Func<IProgress<TProgressInfo>, Task>))
                            || (null != (taskProvider as Func<CancellationToken, IProgress<TProgressInfo>, Task>)));

            // The IAsyncInfo is reasonably expected to be created/started by the same code that wires up the Completed and Progress handlers.
            // Record the current SynchronizationContext so that we can invoke completion and progress callbacks in it later.
            _startingContext = GetStartingContext();

            // Construct task from the specified provider:
            Task task = InvokeTaskProvider(taskProvider);

            if (task == null)
                throw new NullReferenceException(SR.NullReference_TaskProviderReturnedNull);

            if (task.Status == TaskStatus.Created)
                throw new InvalidOperationException(SR.InvalidOperation_TaskProviderReturnedUnstartedTask);

            _dataContainer = task;
            _state = (STATEFLAG_COMPLETION_HNDL_NOT_YET_INVOKED | STATE_STARTED);

            // Set the completion routine and let the task running:
            task.ContinueWith(
                (_, this_) => ((TaskToAsyncInfoAdapter<TCompletedHandler, TProgressHandler, TResult, TProgressInfo>)this_!).TaskCompleted(),
                this, CancellationToken.None, TaskContinuationOptions.ExecuteSynchronously, TaskScheduler.Default);
        }


        /// <summary>
        /// Creates an IAsyncInfo from the Task object. The specified task represents the future encapsulated by this IAsyncInfo.
        /// The specified CancellationTokenSource and Progress are assumed to be the source of the specified Task's cancellation and
        /// the Progress that receives reports from the specified Task.
        /// </summary>
        /// <param name="underlyingTask">The Task whose operation is represented by this IAsyncInfo</param>
        /// <param name="underlyingCancelTokenSource">The cancellation control for the cancellation token observed
        /// by <code>underlyingTask</code>.</param>
        /// <param name="underlyingProgressDispatcher">A progress listener/pugblisher that receives progress notifications
        /// form <code>underlyingTask</code>.</param>
        internal TaskToAsyncInfoAdapter(Task underlyingTask,
                                        CancellationTokenSource underlyingCancelTokenSource, Progress<TProgressInfo> underlyingProgressDispatcher)
        {
            if (underlyingTask == null)
                throw new ArgumentNullException(nameof(underlyingTask));

            // Throw InvalidOperation and not Argument for parity with the constructor that takes Delegate taskProvider:
            if (underlyingTask.Status == TaskStatus.Created)
                throw new InvalidOperationException(SR.InvalidOperation_UnstartedTaskSpecified);

            // The IAsyncInfo is reasonably expected to be created/started by the same code that wires up the Completed and Progress handlers.
            // Record the current SynchronizationContext so that we can invoke completion and progress callbacks in it later.
            _startingContext = GetStartingContext();

            // We do not need to invoke any delegates to get the task, it is provided for us:
            _dataContainer = underlyingTask;

            // This must be the cancellation source for the token that the specified underlyingTask observes for cancellation:
            // (it may also be null in cases where the specified underlyingTask does nto support cancellation)
            _cancelTokenSource = underlyingCancelTokenSource;

            // Iff the specified underlyingTask reports progress, chain the reports to this IAsyncInfo's reporting method:
            if (underlyingProgressDispatcher != null)
                underlyingProgressDispatcher.ProgressChanged += OnReportChainedProgress;

            _state = (STATEFLAG_COMPLETION_HNDL_NOT_YET_INVOKED | STATE_STARTED);

            underlyingTask.ContinueWith(
                (_, this_) => ((TaskToAsyncInfoAdapter<TCompletedHandler, TProgressHandler, TResult, TProgressInfo>)this_!).TaskCompleted(),
                this, CancellationToken.None, TaskContinuationOptions.ExecuteSynchronously, TaskScheduler.Default);
        }


        /// <summary>
        /// Creates an IAsyncInfo from the specified result value. The IAsyncInfo is created in the Completed state and the
        /// specified <code>synchronousResult</code> is used as the result value.
        /// </summary>
        /// <param name="synchronousResult">The result of this synchronously completed IAsyncInfo.</param>
        internal TaskToAsyncInfoAdapter(TResult synchronousResult)
        {
            // We already completed. There will be no progress callback invokations and a potential completed handler invokation will be synchronous.
            // We do not need the starting SynchronizationContext:
            _startingContext = null;

            // Set the synchronous result:
            _dataContainer = synchronousResult;

            // CompletedSynchronously + MustRunCompletionHandleImmediatelyWhenSet + CompletionHandlerNotYetInvoked + RUN_TO_COMPLETION:
            // (same state as assigned by DangerousSetCompleted())
            _state = (STATEFLAG_COMPLETED_SYNCHRONOUSLY
                          | STATEFLAG_MUST_RUN_COMPLETION_HNDL_WHEN_SET
                          | STATEFLAG_COMPLETION_HNDL_NOT_YET_INVOKED
                          | STATE_RUN_TO_COMPLETION);
        }


        ~TaskToAsyncInfoAdapter()
        {
            TransitionToClosed();
        }

        #endregion Constructors and Destructor


        #region Synchronous completion controls

        /// <summary> This method sets the result on a *synchronously completed* IAsyncInfo.
        /// It does not try to deal with the inherit races: Use it only when constructing a synchronously
        /// completed IAsyncInfo in a desired state when you understand the threading conditions well.</summary>
        /// <param name="synchronousResult">The new result of this synchronously completed IAsyncInfo (may be <code>default(TResult)</code>)</param>
        /// <returns>FALSE if this IAsyncInfo has not actually completed synchronously and this method had no effects, TRUE otherwise.</returns>
        internal bool DangerousSetCompleted(TResult synchronousResult)
        {
            if (!CompletedSynchronously)
                return false;

            _dataContainer = synchronousResult;
            _error = null;

            // CompletedSynchronously + MustRunCompletionHandleImmediatelyWhenSet + CompletionHandlerNotYetInvoked + RUN_TO_COMPLETION:
            _state = (STATEFLAG_COMPLETED_SYNCHRONOUSLY
                          | STATEFLAG_MUST_RUN_COMPLETION_HNDL_WHEN_SET
                          | STATEFLAG_COMPLETION_HNDL_NOT_YET_INVOKED
                          | STATE_RUN_TO_COMPLETION);
            return true;
        }


        internal bool DangerousSetCanceled()
        {
            if (!CompletedSynchronously)
                return false;

            // Here we do not try to deal with the inherit races: Use this method only when constructing a synchronously
            // completed IAsyncInfo in a desired state when you understand the threading conditions well.

            _dataContainer = null;
            _error = null;

            // CompletedSynchronously + MustRunCompletionHandleImmediatelyWhenSet + CompletionHandlerNotYetInvoked + CANCELLATION_COMPLETED:
            _state = (STATEFLAG_COMPLETED_SYNCHRONOUSLY
                          | STATEFLAG_MUST_RUN_COMPLETION_HNDL_WHEN_SET
                          | STATEFLAG_COMPLETION_HNDL_NOT_YET_INVOKED
                          | STATE_CANCELLATION_COMPLETED);
            return true;
        }


        internal bool DangerousSetError(Exception error)
        {
            if (!CompletedSynchronously)
                return false;

            if (error == null)
                throw new ArgumentNullException(nameof(error));

            // Here we do not try to deal with the inherit races: Use this method only when constructing a synchronously
            // completed IAsyncInfo in a desired state when you understand the threading conditions well.

            _dataContainer = null;
            _error = error;

            // CompletedSynchronously + MustRunCompletionHandleImmediatelyWhenSet + CompletionHandlerNotYetInvoked + ERROR:
            _state = (STATEFLAG_COMPLETED_SYNCHRONOUSLY
                          | STATEFLAG_MUST_RUN_COMPLETION_HNDL_WHEN_SET
                          | STATEFLAG_COMPLETION_HNDL_NOT_YET_INVOKED
                          | STATE_ERROR);
            return true;
        }

        #endregion Synchronous completion controls


        #region State bit field operations

        internal bool CompletedSynchronously { [Pure] get { return (0 != (_state & STATEFLAG_COMPLETED_SYNCHRONOUSLY)); } }

        private bool IsInStartedState { [Pure] get { return (0 != (_state & STATE_STARTED)); } }

        private bool IsInRunToCompletionState { [Pure] get { return (0 != (_state & STATE_RUN_TO_COMPLETION)); } }

        private bool IsInErrorState { [Pure] get { return (0 != (_state & STATE_ERROR)); } }

        private bool IsInClosedState { [Pure] get { return (0 != (_state & STATE_CLOSED)); } }

        private bool IsInRunningState
        {
            [Pure]
            get
            {
                return (0 != (_state & (STATE_STARTED
                                       | STATE_CANCELLATION_REQUESTED)));
            }
        }

        private bool IsInTerminalState
        {
            [Pure]
            get
            {
                return (0 != (_state & (STATE_RUN_TO_COMPLETION
                                       | STATE_CANCELLATION_COMPLETED
                                       | STATE_ERROR)));
            }
        }

        [Pure]
        private bool CheckUniqueAsyncState(int state)
        {
            unchecked
            {
                uint asyncState = (uint)state;
                return (asyncState & (~asyncState + 1)) == asyncState; // This checks if asyncState is 0 or a power of 2.
            }
        }

        #endregion State bit field operations


        #region Infrastructure methods

        private SynchronizationContext GetStartingContext()
        {
    #if DESKTOP // as a reminder that on most platforms we want a different behavior
                return SynchronizationContext.CurrentNoFlow;
    #else
                return SynchronizationContext.Current;
    #endif
            }


        internal Task Task
        {
            get
            {
                EnsureNotClosed();

                if (CompletedSynchronously)
                    return null;

                return (Task)_dataContainer;
            }
        }


        internal CancellationTokenSource CancelTokenSource
        {
            get { return _cancelTokenSource; }
        }


        [Pure]
        internal void EnsureNotClosed()
        {
            if (!IsInClosedState)
                return;

            ObjectDisposedException ex = new ObjectDisposedException(SR.ObjectDisposed_AsyncInfoIsClosed);
            ex.SetHResult(E_ILLEGAL_METHOD_CALL);
            throw ex;
        }


        internal virtual void OnCompleted(TCompletedHandler userCompletionHandler, AsyncStatus asyncStatus)
        {
            Debug.Fail("This (sub-)type of IAsyncInfo does not support completion notifications "
                                 + " (" + this.GetType().ToString() + ")");
        }


        internal virtual void OnProgress(TProgressHandler userProgressHandler, TProgressInfo progressInfo)
        {
            Debug.Fail("This (sub-)type of IAsyncInfo does not support progress notifications "
                                 + " (" + this.GetType().ToString() + ")");
        }


        private void OnCompletedInvoker(AsyncStatus status)
        {
            bool conditionFailed;

            // Get the handler:
            TCompletedHandler handler = Volatile.Read(ref _completedHandler);

            // If we might not run the handler now, we need to remember that if it is set later, it will need to be run then:
            if (handler == null)
            {
                // Remember to run the handler when it is set:
                SetState(STATEFLAG_MUST_RUN_COMPLETION_HNDL_WHEN_SET, ~STATEFLAG_MUST_RUN_COMPLETION_HNDL_WHEN_SET,
                            conditionBitMask: 0, useCondition: false, conditionFailed: out conditionFailed);

                // The handler may have been set concurrently before we managed to SetState, so check for it again:
                handler = Volatile.Read(ref _completedHandler);

                // If handler was not set cuncurrently after all, then no worries:
                if (handler == null)
                    return;
            }

            // This method might be running cuncurrently. Create a block by emulating an interlocked un-set of
            // the STATEFLAG_COMPLETION_HNDL_NOT_YET_INVOKED-bit in the m_state bit field. Only the thread that wins the race
            // for unsetting this bit, wins, others give up:
            SetState(0, ~STATEFLAG_COMPLETION_HNDL_NOT_YET_INVOKED,
                        conditionBitMask: STATEFLAG_COMPLETION_HNDL_NOT_YET_INVOKED, useCondition: true, conditionFailed: out conditionFailed);

            if (conditionFailed)
                return;

            // Invoke the user handler:
            OnCompleted(handler, status);
        }


        // This is a separate method from IProgress<TProgressInfo>.Report to avoid alocating the closure if it is not used.
        private void OnProgressInvokerCrossContext(TProgressHandler handler, TProgressInfo progressInfo)
        {
            Debug.Assert(handler != null);
            Debug.Assert(_startingContext != null);

            _startingContext.Post((tupleObject) =>
            {
                var tuple = (Tuple<TaskToAsyncInfoAdapter<TCompletedHandler, TProgressHandler, TResult, TProgressInfo>,
                                   TProgressHandler,
                                   TProgressInfo>)tupleObject!;

                tuple.Item1.OnProgress(tuple.Item2, tuple.Item3);
            }, Tuple.Create(this, handler, progressInfo));
        }


        /// <summary>Reports a progress update.</summary>
        /// <param name="value">The new progress value to report.</param>
        void IProgress<TProgressInfo>.Report(TProgressInfo value)
        {
            // If no progress handler is set, there is nothing to do:
            TProgressHandler handler = Volatile.Read(ref _progressHandler);
            if (handler == null)
                return;

            // Try calling progress handler in the right synchronization context.
            // If the user callback throws an exception, it will bubble up through here and reach the
            // user worker code running as this async future. The user should catch it.
            // If the user does not catch it, it will be treated just as any other exception coming from the async execution code:
            // this AsyncInfo will be faulted.

            if (_startingContext == null)
            {
                // The starting context is null, invoke directly:
                OnProgress(handler, value);
            }
            else
            {
                // Invoke callback in the right context:
                OnProgressInvokerCrossContext(handler, value);
            }
        }


        private void OnReportChainedProgress(object sender, TProgressInfo progressInfo)
        {
            ((IProgress<TProgressInfo>)this).Report(progressInfo);
        }


        /// <summary>
        /// Sets the <code>m_state</code> bit field to reflect the specified async state with the corresponding STATE_XXX bit mask.
        /// </summary>
        /// <param name="newAsyncState">Must be one of the STATE_XXX (not STATEYYY_ZZZ !) constants defined in this class.</param>
        /// <param name="conditionBitMask">If <code>useCondition</code> is FALSE: this field is ignored.
        ///                                If <code>useCondition</code> is TRUE: Unless this value has at least one bit with <code>m_state</code> in
        ///                                                                      common, this method will not perform any action.</param>
        /// <param name="useCondition">If TRUE, use <code>conditionBitMask</code> to determine whether the state should be set;
        ///                            If FALSE, ignore <code>conditionBitMask</code>.</param>
        /// <param name="conditionFailed">If <code>useCondition</code> is FALSE: this field is set to FALSE;
        ///                               If <code>useCondition</code> is TRUE: this field indicated whether the specified <code>conditionBitMask</code>
        ///                                                                     had at least one bit in common with <code>m_state</code> (TRUE)
        ///                                                                     or not (FALSE).
        ///                               (!) Note that the meaning of this parameter to the caller is not quite the same as whether <code>m_state</code>
        ///                               is/was set to the specified value, because <code>m_state</code> may already have had the specified value, or it
        ///                               may be set and then immediately changed by another thread. The true meaning of this parameter is whether or not
        ///                               the specified condition did hold before trying to change the state.</param>
        /// <returns>The value at which the current invocation of this method left <code>m_state</code>.</returns>
        private int SetAsyncState(int newAsyncState, int conditionBitMask, bool useCondition, out bool conditionFailed)
        {
            Debug.Assert(CheckUniqueAsyncState(newAsyncState & STATEMASK_SELECT_ANY_ASYNC_STATE));
            Debug.Assert(CheckUniqueAsyncState(_state & STATEMASK_SELECT_ANY_ASYNC_STATE));

            int resultState = SetState(newAsyncState, STATEMASK_CLEAR_ALL_ASYNC_STATES, conditionBitMask, useCondition, out conditionFailed);
            Debug.Assert(CheckUniqueAsyncState(resultState & STATEMASK_SELECT_ANY_ASYNC_STATE));

            return resultState;
        }


        /// <summary>
        /// Sets the specified bits in the <code>m_state</code> bit field according to the specified bit-mask parameters.
        /// </summary>
        /// <param name="newStateSetMask">The bits to turn ON in the <code>m_state</code> bit field</param>
        /// <param name="newStateIgnoreMask">Any bits that are OFF in this value will get turned OFF,
        ///                                  unless they are explicitly switched on by <code>newStateSetMask</code>.</param>
        /// <param name="conditionBitMask">If <code>useCondition</code> is FALSE: this field is ignored.
        ///                                If <code>useCondition</code> is TRUE: Unless this value has at least one bit with <code>m_state</code> in
        ///                                                                      common, this method will not perform any action.</param>
        /// <param name="useCondition">If TRUE, use <code>conditionBitMask</code> to determine whether the state should be set;
        ///                            If FALSE, ignore <code>conditionBitMask</code>.</param>
        /// <param name="conditionFailed">If <code>useCondition</code> is FALSE: this field is set to FALSE;
        ///                               If <code>useCondition</code> is TRUE: this field indicated whether the specified <code>conditionBitMask</code>
        ///                                                                     had at least one bit in common with <code>m_state</code> (TRUE)
        ///                                                                     or not (FALSE).
        ///                               (!) Note that the meaning of this parameter to the caller is not quite the same as whether <code>m_state</code>
        ///                               is/was set to the specified value, because <code>m_state</code> may already have had the specified value, or it
        ///                               may be set and then immediately changed by another thread. The true meaning of this parameter is whether or not
        ///                               the specified condition did hold before trying to change the state.</param>
        /// <returns>The value at which the current invocation of this method left <code>m_state</code>.</returns>
        private int SetState(int newStateSetMask, int newStateIgnoreMask, int conditionBitMask, bool useCondition, out bool conditionFailed)
        {
            int origState = _state;

            if (useCondition && 0 == (origState & conditionBitMask))
            {
                conditionFailed = true;
                return origState;
            }

            int newState = (origState & newStateIgnoreMask) | newStateSetMask;
            int prevState = Interlocked.CompareExchange(ref _state, newState, origState);

            // If m_state changed concurrently, we want to make sure that the change being made is based on a bitmask that is up to date:
            // (this relies of the fact that all state machines that save their state in m_state have no cycles)
            while (true)
            {
                if (prevState == origState)
                {
                    conditionFailed = false;
                    return newState;
                }

                origState = _state;

                if (useCondition && 0 == (origState & conditionBitMask))
                {
                    conditionFailed = true;
                    return origState;
                }

                newState = (origState & newStateIgnoreMask) | newStateSetMask;
                prevState = Interlocked.CompareExchange(ref _state, newState, origState);
            }
        }


        private int TransitionToTerminalState()
        {
            Debug.Assert(IsInRunningState);
            Debug.Assert(!CompletedSynchronously);

            Task task = _dataContainer as Task;
            Debug.Assert(task != null);
            Debug.Assert(task.IsCompleted);

            // Recall that STATE_CANCELLATION_REQUESTED and STATE_CANCELLATION_COMPLETED both map to the public CANCELED state.
            // So, we are STARTED or CANCELED. We will ask the task how it completed and possibly transition out of CANCELED.
            // This may happen if cancellation was requested while in STARTED state, but the task does not support cancellation,
            // or if it can support cancellation in principle, but the Cancel request came in while still STARTED, but after the
            // last opportunity to cancel.
            // If the underlying operation was not able to react to the cancellation request and instead either run to completion
            // or faulted, then the state will transition into COMPLETED or ERROR accordingly. If the operation was really cancelled,
            // the state will remain CANCELED.

            // If the switch below defaults, we have an erroneous implementation.
            int terminalAsyncState = STATE_ERROR;

            switch (task.Status)
            {
                case TaskStatus.RanToCompletion:
                    terminalAsyncState = STATE_RUN_TO_COMPLETION;
                    break;

                case TaskStatus.Canceled:
                    terminalAsyncState = STATE_CANCELLATION_COMPLETED;
                    break;

                case TaskStatus.Faulted:
                    terminalAsyncState = STATE_ERROR;
                    break;

                default:
                    Debug.Fail("Unexpected task.Status: It should be terminal if TaskCompleted() is called.");
                    break;
            }

            bool ignore;
            int newState = SetAsyncState(terminalAsyncState,
                                           conditionBitMask: STATEMASK_SELECT_ANY_ASYNC_STATE, useCondition: true, conditionFailed: out ignore);

            Debug.Assert((newState & STATEMASK_SELECT_ANY_ASYNC_STATE) == terminalAsyncState);
            Debug.Assert((_state & STATEMASK_SELECT_ANY_ASYNC_STATE) == terminalAsyncState || IsInClosedState,
                            "We must either be in a state we just entered or we were concurrently closed");

            return newState;
        }


        private void TaskCompleted()
        {
            int terminalState = TransitionToTerminalState();
            Debug.Assert(IsInTerminalState);

            // We transitioned into a terminal state, so it became legal to close us concurrently.
            // So we use data from this stack and not m_state to get the completion status.
            // On this code path we will also fetch m_completedHandler, however that race is benign because in CLOSED the handler
            // can only change to null, so it won't be invoked, which is appropriate for CLOSED.
            AsyncStatus terminationStatus = GetStatus(terminalState);

            // Try calling completed handler in the right synchronization context.
            // If the user callback throws an exception, it will bubble up through here.
            // If we let it though, it will be caught and swallowed by the Task subsystem, which is just below us on the stack.
            // Instead we follow the same pattern as Task and other parallel libs and re-throw the excpetion on the threadpool
            // to ensure a diagnostic message and a fail-fast-like teardown.
            try
            {
                if (_startingContext == null)
                {
                    // The starting context is null, invoking directly:
                    OnCompletedInvoker(terminationStatus);
                }
                else
                {
                    // Invoke callback in the right context (delegate cached by compiler):
                    _startingContext.Post((tupleObject) =>
                    {
                        var tuple = (Tuple<TaskToAsyncInfoAdapter<TCompletedHandler, TProgressHandler, TResult, TProgressInfo>, AsyncStatus>)tupleObject!;
                        tuple.Item1.OnCompletedInvoker(tuple.Item2);
                    }, Tuple.Create(this, terminationStatus));
                }
            }
            catch (Exception ex)
            {
                ExceptionDispatchHelper.ThrowAsync(ex, _startingContext);
            }
        }


        private AsyncStatus GetStatus(int state)
        {
            int asyncState = state & STATEMASK_SELECT_ANY_ASYNC_STATE;
            Debug.Assert(CheckUniqueAsyncState(asyncState));

            switch (asyncState)
            {
                case STATE_NOT_INITIALIZED:
                    Debug.Fail("STATE_NOT_INITIALIZED should only occur when this object was not"
                                         + " fully constructed, in which case we should never get here");
                    return AsyncStatus.Error;

                case STATE_STARTED:
                    return AsyncStatus.Started;

                case STATE_RUN_TO_COMPLETION:
                    return AsyncStatus.Completed;

                case STATE_CANCELLATION_REQUESTED:
                case STATE_CANCELLATION_COMPLETED:
                    return AsyncStatus.Canceled;

                case STATE_ERROR:
                    return AsyncStatus.Error;

                case STATE_CLOSED:
                    Debug.Fail("This method should never be called is this IAsyncInfo is CLOSED");
                    return AsyncStatus.Error;
            }

            Debug.Fail("The switch above is missing a case");
            return AsyncStatus.Error;
        }

        internal TResult GetResultsInternal()
        {
            EnsureNotClosed();

            // If this IAsyncInfo has actually faulted, GetResults will throw the same error as returned by ErrorCode:
            if (IsInErrorState)
            {
                Exception error = ErrorCode;
                Debug.Assert(error != null);
                ExceptionDispatchInfo.Capture(error).Throw();
            }

            // IAsyncInfo throws E_ILLEGAL_METHOD_CALL when called in a state other than COMPLETED:
            if (!IsInRunToCompletionState)
                throw CreateCannotGetResultsFromIncompleteOperationException(null);


            // If this is a synchronous operation, use the cached result:
            if (CompletedSynchronously)
                return (TResult)_dataContainer!;

            // The operation is asynchronous:
            Task<TResult> task = _dataContainer as Task<TResult>;

            // Since CompletedSynchronously is false and EnsureNotClosed() did not throw, task can only be null if:
            //  - this IAsyncInfo has completed synchronously, however we checked for this above;
            //  - it was not converted to Task<TResult>, which means it is a non-generic Task. In that case we cannot get a result from Task.
            if (task == null)
                return default(TResult)!;

            Debug.Assert(IsInRunToCompletionState);

            // Pull out the task result and return.
            // Any exceptions thrown in the task will be rethrown.
            // If this exception is a cancelation exception, meaning there was actually no error except for being cancelled,
            // return an error code appropriate for WinRT instead (InvalidOperation with E_ILLEGAL_METHOD_CALL).
            try
            {
                return task.GetAwaiter().GetResult();
            }
            catch (TaskCanceledException tcEx)
            {
                throw CreateCannotGetResultsFromIncompleteOperationException(tcEx);
            }
        }


        private Task InvokeTaskProvider(Delegate taskProvider)
        {
            var funcVoidTask = taskProvider as Func<Task>;
            if (funcVoidTask != null)
            {
                return funcVoidTask();
            }

            var funcCTokTask = taskProvider as Func<CancellationToken, Task>;
            if (funcCTokTask != null)
            {
                _cancelTokenSource = new CancellationTokenSource();
                return funcCTokTask(_cancelTokenSource.Token);
            }

            var funcIPrgrTask = taskProvider as Func<IProgress<TProgressInfo>, Task>;
            if (funcIPrgrTask != null)
            {
                return funcIPrgrTask(this);
            }

            var funcCTokIPrgrTask = taskProvider as Func<CancellationToken, IProgress<TProgressInfo>, Task>;
            if (funcCTokIPrgrTask != null)
            {
                _cancelTokenSource = new CancellationTokenSource();
                return funcCTokIPrgrTask(_cancelTokenSource.Token, this);
            }

            Debug.Fail("We should never get here!"
                                 + " Public methods creating instances of this class must be typesafe to ensure that taskProvider"
                                 + " can always be cast to one of the above Func types."
                                 + " The taskProvider is " + (taskProvider == null
                                                                    ? "null."
                                                                    : "a " + taskProvider.GetType().ToString()) + ".");
            return null;
        }


        private void TransitionToClosed()
        {
            // From the finaliser we always call this Close version since finalisation can happen any time, even when STARTED (e.g. process ends)
            // and we do not want to throw in those cases.

            // Always go to closed, even from STATE_NOT_INITIALIZED.
            // Any checking whether it is legal to call CLosed inthe current state, should occur in Close().
            bool ignore;
            SetAsyncState(STATE_CLOSED, 0, useCondition: false, conditionFailed: out ignore);

            _cancelTokenSource = null;
            _dataContainer = null;
            _error = null;
            _completedHandler = null;
            _progressHandler = null;
            _startingContext = null;
        }

        #endregion Infrastructure methods


        #region Implementation of IAsyncInfo

        /// <summary>
        /// Gets or sets the completed handler.
        ///
        /// We will set the completion handler even when this IAsyncInfo is already started (no other choice).
        /// If we the completion handler is set BEFORE this IAsyncInfo completed, then the handler will be called upon completion as normal.
        /// If we the completion handler is set AFTER this IAsyncInfo already completed, then this setter will invoke the handler synchronously
        /// on the current context.
        /// </summary>
        public virtual TCompletedHandler Completed
        {
            get
            {
                TCompletedHandler handler = Volatile.Read(ref _completedHandler);
                EnsureNotClosed();
                return handler;
            }

            set
            {
                EnsureNotClosed();

                // Try setting completion handler, but only if this has not yet been done:
                // (Note: We allow setting Completed to null multiple times iff it has not yet been set to anything else than null.
                //  Some other WinRT projection languages do not allow setting the Completed handler more than once, even if it is set to null.
                //  We could do the same by introducing a new STATEFLAG_COMPLETION_HNDL_SET bit-flag constant and saving a this state into
                //  the m_state field to indicate that the completion handler has been set previously, but we choose not to do this.)
                TCompletedHandler handlerBefore = Interlocked.CompareExchange(ref _completedHandler, value, null);
                if (handlerBefore != null)
                {
                    InvalidOperationException ex = new InvalidOperationException(SR.InvalidOperation_CannotSetCompletionHanlderMoreThanOnce);
                    ex.SetHResult(E_ILLEGAL_DELEGATE_ASSIGNMENT);
                    throw ex;
                }

                if (value == null)
                    return;

                // If STATEFLAG_MUST_RUN_COMPLETION_HNDL_WHEN_SET is OFF then we are done (i.e. no need to invoke the handler synchronously)
                if (0 == (_state & STATEFLAG_MUST_RUN_COMPLETION_HNDL_WHEN_SET))
                    return;

                // We have changed the handler and at some point this IAsyncInfo may have transitioned to the Closed state.
                // This is OK, but if this happened we need to ensure that we only leave a null handler behind:
                if (IsInClosedState)
                {
                    Interlocked.Exchange(ref _completedHandler, null);
                    return;
                }

                // The STATEFLAG_MUST_RUN_COMPLETION_HNDL_WHEN_SET-flag was set, so we need to call the completion handler now:
                Debug.Assert(IsInTerminalState);
                OnCompletedInvoker(Status);
            }
        }


        /// <summary>Gets or sets the progress handler.</summary>
        public virtual TProgressHandler Progress
        {
            get
            {
                TProgressHandler handler = Volatile.Read(ref _progressHandler);
                EnsureNotClosed();

                return handler;
            }

            set
            {
                EnsureNotClosed();

                Interlocked.Exchange(ref _progressHandler, value);

                // We transitioned into CLOSED after the above check, we will need to null out m_progressHandler:
                if (IsInClosedState)
                    Interlocked.Exchange(ref _progressHandler, null);
            }
        }


        /// <summary>Cancels the async info.</summary>
        public virtual void Cancel()
        {
            // Cancel will be ignored in any terminal state including CLOSED.
            // In other words, it is ignored in any state except STARTED.

            bool stateWasNotStarted;
            SetAsyncState(STATE_CANCELLATION_REQUESTED, conditionBitMask: STATE_STARTED, useCondition: true, conditionFailed: out stateWasNotStarted);

            if (!stateWasNotStarted)
            {  // i.e. if state was different from STATE_STARTED:
                if (_cancelTokenSource != null)
                    _cancelTokenSource.Cancel();
            }
        }


        /// <summary>Close the async info.</summary>
        public virtual void Close()
        {
            if (IsInClosedState)
                return;

            // Cannot Close from a non-terminal state:
            if (!IsInTerminalState)
            {
                // If we are STATE_NOT_INITIALIZED, the we probably threw from the ctor.
                // The finalizer will be called anyway and we need to free this partially constructed object correctly.
                // So we avoid throwing when we are in STATE_NOT_INITIALIZED.
                // In other words throw only if *some* async state is set:
                if (0 != (_state & STATEMASK_SELECT_ANY_ASYNC_STATE))
                {
                    InvalidOperationException ex = new InvalidOperationException(SR.InvalidOperation_IllegalStateChange);
                    ex.SetHResult(E_ILLEGAL_STATE_CHANGE);
                    throw ex;
                }
            }

            TransitionToClosed();
        }


        /// <summary>Gets the error code for the async info.</summary>
        public virtual Exception ErrorCode
        {
            get
            {
                EnsureNotClosed();

                // If the task is faulted, hand back an HR representing its first exception.
                // Otherwise, hand back S_OK (which is a null Exception).

                if (!IsInErrorState)
                    return null;

                Exception error = Volatile.Read(ref _error);

                // ERROR is a terminal state. SO if we have an error, just return it.
                // If we completed synchronously, we return the current error iven if it is null since we do not expect this to change:
                if (error != null || CompletedSynchronously)
                    return error;

                Task task = _dataContainer as Task;
                Debug.Assert(task != null);

                AggregateException aggregateException = task.Exception;

                // By spec, if task.IsFaulted is true, then task.Exception must not be null and its InnerException must
                // also not be null. However, in case something is unexpected on the Task side of the road, lets be defensive
                // instead of failing with an inexplicable NullReferenceException:

                if (aggregateException == null)
                {
                    error = new Exception(SR.WinRtCOM_Error);
                    error.SetHResult(E_FAIL);
                }
                else
                {
                    Exception innerException = aggregateException.InnerException;

                    error = (innerException == null)
                                ? aggregateException
                                : innerException;
                }

                // If m_error was set concurrently, setError will be non-null. Then we use that - as it is the first m_error
                // that was set. If setError we know that we won any races and we can return error:
                Exception setError = Interlocked.CompareExchange(ref _error, error, null);
                return setError ?? error;
            }
        }


        public virtual uint Id
        {
            get
            {
                EnsureNotClosed();

                if (_id != AsyncInfoIdGenerator.InvalidId)
                    return _id;

                return AsyncInfoIdGenerator.EnsureInitializedThreadsafe(ref _id);
            }
        }


        /// <summary>Gets the status of the async info.</summary>
        public virtual AsyncStatus Status
        {
            get
            {
                EnsureNotClosed();
                return GetStatus(_state);
            }
        }
        #endregion Implementation of IAsyncInfo
    }  // class TaskToAsyncInfoAdapter<TCompletedHandler, TProgressHandler, TResult, TProgressInfo>
}  // namespace

// TaskToAsyncInfoAdapter.cs

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace System.Threading.Tasks
{
    using System;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Threading;
    using System.Threading.Tasks;
    using global::Windows.Foundation;

#if !NETSTANDARD2_0
    [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
    internal class TaskToAsyncOperationAdapter<TResult>
                    : TaskToAsyncInfoAdapter<AsyncOperationCompletedHandler<TResult>, VoidReferenceTypeParameter, TResult, VoidValueTypeParameter>,
                      IAsyncOperation<TResult>
    {
        internal TaskToAsyncOperationAdapter(Delegate taskGenerator)

             : base(taskGenerator)
        {
        }


        internal TaskToAsyncOperationAdapter(Task underlyingTask, CancellationTokenSource underlyingCancelTokenSource)

            : base(underlyingTask, underlyingCancelTokenSource, underlyingProgressDispatcher: null)
        {
        }


        internal TaskToAsyncOperationAdapter(TResult synchronousResult)

            : base(synchronousResult)
        {
        }

        public virtual TResult GetResults()
        {
            return GetResultsInternal();
        }


        internal override void OnCompleted(AsyncOperationCompletedHandler<TResult> userCompletionHandler, AsyncStatus asyncStatus)
        {
            Debug.Assert(userCompletionHandler != null);
            userCompletionHandler(this, asyncStatus);
        }
    }  // class TaskToAsyncOperationAdapter<TResult>
}  // namespace

// TaskToAsyncOperationAdapter.cs

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace System.Threading.Tasks
{
    using System;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Threading;
    using System.Threading.Tasks;
    using global::Windows.Foundation;

#if !NETSTANDARD2_0
    [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
    internal class TaskToAsyncOperationWithProgressAdapter<TResult, TProgress>
                            : TaskToAsyncInfoAdapter<AsyncOperationWithProgressCompletedHandler<TResult, TProgress>,
                                                     AsyncOperationProgressHandler<TResult, TProgress>,
                                                     TResult,
                                                     TProgress>,
                              IAsyncOperationWithProgress<TResult, TProgress>
    {
        internal TaskToAsyncOperationWithProgressAdapter(Delegate taskGenerator)

             : base(taskGenerator)
        {
        }

        // This is currently not used, so commented out to save code.
        // Leaving this is the source to be uncommented in case we decide to support IAsyncOperationWithProgress-consturction from a Task.
        //
        //internal TaskToAsyncOperationWithProgressAdapter(Task underlyingTask, CancellationTokenSource underlyingCancelTokenSource,
        //                                                 Progress<TProgress> underlyingProgressDispatcher)
        //
        //    : base(underlyingTask, underlyingCancelTokenSource, underlyingProgressDispatcher) {
        //}


        internal TaskToAsyncOperationWithProgressAdapter(TResult synchronousResult)

            : base(synchronousResult)
        {
        }

        public virtual TResult GetResults()
        {
            return GetResultsInternal();
        }


        internal override void OnCompleted(AsyncOperationWithProgressCompletedHandler<TResult, TProgress> userCompletionHandler,
                                           AsyncStatus asyncStatus)
        {
            Debug.Assert(userCompletionHandler != null);
            userCompletionHandler(this, asyncStatus);
        }


        internal override void OnProgress(AsyncOperationProgressHandler<TResult, TProgress> userProgressHandler, TProgress progressInfo)
        {
            Debug.Assert(userProgressHandler != null);
            userProgressHandler(this, progressInfo);
        }
    }  // class TaskToAsyncOperationWithProgressAdapter<TResult, TProgress>
}  // namespace

// TaskToAsyncOperationWithProgressAdapter.cs


namespace System
{
    using global::System.Diagnostics;
    using global::System.Runtime.CompilerServices;
    using global::System.Runtime.InteropServices;
    using global::System.Threading;
    using global::System.Threading.Tasks;
    using global::Windows.Foundation;

#if NET5_0
    [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
    public static class WindowsRuntimeSystemExtensions
    {
        public static Task AsTask(this IAsyncAction source, CancellationToken cancellationToken)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            // TODO: Handle the scenario where the 'IAsyncAction' is actually a task (i.e. originated from native code
            // but projected into an IAsyncAction)

            switch (source.Status)
            {
                case AsyncStatus.Completed:
                    return Task.CompletedTask;

                case AsyncStatus.Error:
                    return Task.FromException(source.ErrorCode);

                case AsyncStatus.Canceled:
                    return Task.FromCanceled(cancellationToken.IsCancellationRequested ? cancellationToken : new CancellationToken(true));
            }

            var bridge = new AsyncInfoToTaskBridge<VoidValueTypeParameter, VoidValueTypeParameter>(cancellationToken);
            source.Completed = new AsyncActionCompletedHandler(bridge.CompleteFromAsyncAction);
            bridge.RegisterForCancellation(source);
            return bridge.Task;
        }

        public static Task AsTask(this IAsyncAction source)
        {
            return AsTask(source, CancellationToken.None);
        }

        public static TaskAwaiter GetAwaiter(this IAsyncAction source)
        {
            return AsTask(source).GetAwaiter();
        }

        public static Task<TResult> AsTask<TResult>(this IAsyncOperation<TResult> source, CancellationToken cancellationToken)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            // TODO: Handle the scenario where the 'IAsyncOperation' is actually a task (i.e. originated from native code
            // but projected into an IAsyncOperation)

            switch (source.Status)
            {
                case AsyncStatus.Completed:
                    return Task.FromResult(source.GetResults());

                case AsyncStatus.Error:
                    return Task.FromException<TResult>(source.ErrorCode);

                case AsyncStatus.Canceled:
                    return Task.FromCanceled<TResult>(cancellationToken.IsCancellationRequested ? cancellationToken : new CancellationToken(true));
            }

            var bridge = new AsyncInfoToTaskBridge<TResult, VoidValueTypeParameter>(cancellationToken);
            source.Completed = new AsyncOperationCompletedHandler<TResult>(bridge.CompleteFromAsyncOperation);
            bridge.RegisterForCancellation(source);
            return bridge.Task;
        }

        public static Task<TResult> AsTask<TResult>(this IAsyncOperation<TResult> source)
        {
            return AsTask(source, CancellationToken.None);
        }

        public static TaskAwaiter<TResult> GetAwaiter<TResult>(this IAsyncOperation<TResult> source)
        {
            return AsTask(source).GetAwaiter();
        }

        public static Task AsTask<TProgress>(this IAsyncActionWithProgress<TProgress> source, CancellationToken cancellationToken, IProgress<TProgress> progress)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            // TODO: Handle the scenario where the 'IAsyncActionWithProgress' is actually a task (i.e. originated from native code
            // but projected into an IAsyncActionWithProgress)

            switch (source.Status)
            {
                case AsyncStatus.Completed:
                    return Task.CompletedTask;

                case AsyncStatus.Error:
                    return Task.FromException(source.ErrorCode);

                case AsyncStatus.Canceled:
                    return Task.FromCanceled(cancellationToken.IsCancellationRequested ? cancellationToken : new CancellationToken(true));
            }

            if (progress != null)
            {
                SetProgress(source, progress);
            }

            var bridge = new AsyncInfoToTaskBridge<VoidValueTypeParameter, TProgress>(cancellationToken);
            source.Completed = new AsyncActionWithProgressCompletedHandler<TProgress>(bridge.CompleteFromAsyncActionWithProgress);
            bridge.RegisterForCancellation(source);
            return bridge.Task;
        }

        private static void SetProgress<TProgress>(IAsyncActionWithProgress<TProgress> source, IProgress<TProgress> sink)
        {
            // This is separated out into a separate method so that we only pay the costs of compiler-generated closure if progress is non-null.
            source.Progress = new AsyncActionProgressHandler<TProgress>((_, info) => sink.Report(info));
        }

        public static Task AsTask<TProgress>(this IAsyncActionWithProgress<TProgress> source)
        {
            return AsTask(source, CancellationToken.None, null);
        }

        public static Task AsTask<TProgress>(this IAsyncActionWithProgress<TProgress> source, CancellationToken cancellationToken)
        {
            return AsTask(source, cancellationToken, null);
        }

        public static Task AsTask<TProgress>(this IAsyncActionWithProgress<TProgress> source, IProgress<TProgress> progress)
        {
            return AsTask(source, CancellationToken.None, progress);
        }

        public static TaskAwaiter GetAwaiter<TProgress>(this IAsyncActionWithProgress<TProgress> source)
        {
            return AsTask(source).GetAwaiter();
        }

        public static Task<TResult> AsTask<TResult, TProgress>(this IAsyncOperationWithProgress<TResult, TProgress> source, CancellationToken cancellationToken, IProgress<TProgress> progress)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            // TODO: Handle the scenario where the 'IAsyncOperationWithProgress' is actually a task (i.e. originated from native code
            // but projected into an IAsyncOperationWithProgress)

            switch (source.Status)
            {
                case AsyncStatus.Completed:
                    return Task.FromResult(source.GetResults());

                case AsyncStatus.Error:
                    return Task.FromException<TResult>(source.ErrorCode);

                case AsyncStatus.Canceled:
                    return Task.FromCanceled<TResult>(cancellationToken.IsCancellationRequested ? cancellationToken : new CancellationToken(true));
            }

            if (progress != null)
            {
                SetProgress(source, progress);
            }

            var bridge = new AsyncInfoToTaskBridge<TResult, TProgress>(cancellationToken);
            source.Completed = new AsyncOperationWithProgressCompletedHandler<TResult, TProgress>(bridge.CompleteFromAsyncOperationWithProgress);
            bridge.RegisterForCancellation(source);
            return bridge.Task;
        }

        private static void SetProgress<TResult, TProgress>(IAsyncOperationWithProgress<TResult, TProgress> source, IProgress<TProgress> sink)
        {
            // This is separated out into a separate method so that we only pay the costs of compiler-generated closure if progress is non-null.
            source.Progress = new AsyncOperationProgressHandler<TResult, TProgress>((_, info) => sink.Report(info));
        }

        public static Task<TResult> AsTask<TResult, TProgress>(this IAsyncOperationWithProgress<TResult, TProgress> source)
        {
            return AsTask(source, CancellationToken.None, null);
        }

        public static Task<TResult> AsTask<TResult, TProgress>(this IAsyncOperationWithProgress<TResult, TProgress> source, CancellationToken cancellationToken)
        {
            return AsTask(source, cancellationToken, null);
        }

        public static Task<TResult> AsTask<TResult, TProgress>(this IAsyncOperationWithProgress<TResult, TProgress> source, IProgress<TProgress> progress)
        {
            return AsTask(source, CancellationToken.None, progress);
        }

        public static TaskAwaiter<TResult> GetAwaiter<TResult, TProgress>(this IAsyncOperationWithProgress<TResult, TProgress> source)
        {
            return AsTask(source).GetAwaiter();
        }

        public static IAsyncAction AsAsyncAction(this Task source)
        {
            if (source == null)
                throw new ArgumentNullException(nameof(source));

            return new TaskToAsyncActionAdapter(source, underlyingCancelTokenSource: null);
        }

        public static IAsyncOperation<TResult> AsAsyncOperation<TResult>(this Task<TResult> source)
        {
            if (source == null)
                throw new ArgumentNullException(nameof(source));

            return new TaskToAsyncOperationAdapter<TResult>(source, underlyingCancelTokenSource: null);
        }
    }

    // Marker type since generic parameters cannot be 'void'
    struct VoidValueTypeParameter { }

    /// <summary>This can be used instead of <code>VoidValueTypeParameter</code> when a reference type is required.
    /// In case of an actual instantiation (e.g. through <code>default(T)</code>),
    /// using <code>VoidValueTypeParameter</code> offers better performance.</summary>
    internal class VoidReferenceTypeParameter { }

#if NET5_0
    [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
    sealed class AsyncInfoToTaskBridge<TResult, TProgress> : TaskCompletionSource<TResult>
    {
        private readonly CancellationToken _ct;
        private CancellationTokenRegistration _ctr;
        private bool _completing;

        internal AsyncInfoToTaskBridge(CancellationToken cancellationToken)
        {
            // TODO: AsyncCausality?
            _ct = cancellationToken;
        }

        internal void RegisterForCancellation(IAsyncInfo asyncInfo)
        {
            Debug.Assert(asyncInfo != null);

            try
            {
                if (_ct.CanBeCanceled && !_completing)
                {
                    var ctr = _ct.Register(ai => ((IAsyncInfo)ai).Cancel(), asyncInfo);
                    bool disposeOfCtr = false;
                    lock (this)
                    {
                        if (_completing)
                        {
                            disposeOfCtr = true;
                        }
                        else
                        {
                            _ctr = ctr;
                        }
                    }

                    if (disposeOfCtr)
                    {
                        ctr.Dispose();
                    }
                }
            }
            catch (Exception ex)
            {
                if (!base.Task.IsFaulted)
                {
                    Debug.Fail($"Expected base task to already be faulted but found it in state {base.Task.Status}");
                    base.TrySetException(ex);
                }
            }
        }

        internal void CompleteFromAsyncAction(IAsyncAction asyncInfo, AsyncStatus asyncStatus)
        {
            Complete(asyncInfo, null, asyncStatus);
        }

        internal void CompleteFromAsyncActionWithProgress(IAsyncActionWithProgress<TProgress> asyncInfo, AsyncStatus asyncStatus)
        {
            Complete(asyncInfo, null, asyncStatus);
        }

        internal void CompleteFromAsyncOperation(IAsyncOperation<TResult> asyncInfo, AsyncStatus asyncStatus)
        {
            Complete(asyncInfo, ai => ((IAsyncOperation<TResult>)ai).GetResults(), asyncStatus);
        }

        internal void CompleteFromAsyncOperationWithProgress(IAsyncOperationWithProgress<TResult, TProgress> asyncInfo, AsyncStatus asyncStatus)
        {
            Complete(asyncInfo, ai => ((IAsyncOperationWithProgress<TResult, TProgress>)ai).GetResults(), asyncStatus);
        }

        private void Complete(IAsyncInfo asyncInfo, Func<IAsyncInfo, TResult> getResultsFunction, AsyncStatus asyncStatus)
        {
            if (asyncInfo == null)
            {
                throw new ArgumentNullException(nameof(asyncInfo));
            }

            // TODO: AsyncCausality?

            try
            {
                Debug.Assert(asyncInfo.Status == asyncStatus, "asyncInfo.Status does not match asyncStatus; are we dealing with a faulty IAsyncInfo implementation?");
                if (Task.IsCompleted)
                {
                    Debug.Fail("Expected the task to not yet be completed.");
                    throw new InvalidOperationException("The asynchronous operation could not be completed.");
                }

                // Clean up our registration with the cancellation token, noting that we're now in the process of cleaning up.
                CancellationTokenRegistration ctr;
                lock (this)
                {
                    _completing = true;
                    ctr = _ctr;
                    _ctr = default;
                }
                ctr.Dispose();

                try
                {
                    if (asyncStatus != AsyncStatus.Completed && asyncStatus != AsyncStatus.Canceled && asyncStatus != AsyncStatus.Error)
                    {
                        Debug.Fail("The async operation should be in a terminal state.");
                        throw new InvalidOperationException("The asynchronous operation could not be completed.");
                    }

                    TResult result = default(TResult);
                    Exception error = null;
                    if (asyncStatus == AsyncStatus.Error)
                    {
                        error = asyncInfo.ErrorCode;

                        // Defend against a faulty IAsyncInfo implementation
                        if (error is null)
                        {
                            Debug.Fail("IAsyncInfo.Status == Error, but ErrorCode returns a null Exception (implying S_OK).");
                            error = new InvalidOperationException("The asynchronous operation could not be completed.");
                        }
                    }
                    else if (asyncStatus == AsyncStatus.Completed && getResultsFunction != null)
                    {
                        try
                        {
                            result = getResultsFunction(asyncInfo);
                        }
                        catch (Exception resultsEx)
                        {
                            // According to the WinRT team, this can happen in some egde cases, such as marshalling errors in GetResults.
                            error = resultsEx;
                            asyncStatus = AsyncStatus.Error;
                        }
                    }

                    // Complete the task based on the previously retrieved results:
                    bool success = false;
                    switch (asyncStatus)
                    {
                        case AsyncStatus.Completed:
                            // TODO: AsyncCausality?
                            success = base.TrySetResult(result);
                            break;

                        case AsyncStatus.Error:
                            Debug.Assert(error != null, "The error should have been retrieved previously.");
                            success = base.TrySetException(error);
                            break;

                        case AsyncStatus.Canceled:
                            success = base.TrySetCanceled(_ct.IsCancellationRequested ? _ct : new CancellationToken(true));
                            break;
                    }

                    Debug.Assert(success, "Expected the outcome to be successfully transfered to the task.");
                }
                catch (Exception exc)
                {
                    Debug.Fail($"Unexpected exception in Complete: {exc}");

                    // TODO: AsyncCausality

                    if (!base.TrySetException(exc))
                    {
                        Debug.Fail("The task was already completed and thus the exception couldn't be stored.");
                        throw;
                    }
                }
            }
            finally
            {
                // We may be called on an STA thread which we don't own, so make sure that the RCW is released right
                // away. Otherwise, if we leave it up to the finalizer, the apartment may already be gone.
                if (ComWrappersSupport.TryUnwrapObject(asyncInfo, out var objRef))
                {
                    objRef.Dispose();
                }
            }
        }
    }
}

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

namespace Windows.Foundation
{
    class SR
    {
        public static string Argument_BufferLengthExceedsCapacity = "The specified useful data length exceeds the capacity of this buffer.";

        public static string Argument_IndexOutOfArrayBounds = "The specified index is out of bounds of the specified array.";

        public static string Argument_InsufficientArrayElementsAfterOffset = "The specified array does not contain the specified number of elements starting at the specified offset.";

        public static string Argument_UnexpectedAsyncResult = "The specified AsyncResult does not correspond to any outstanding IO operation.";

        public static string ArgumentOutOfRange_NeedNonNegNum = "Non-negative number required.";

        public static string InvalidOperation_CannotCallThisMethodInCurrentState = "The state of this object does not permit invoking this method.";

        public static string InvalidOperation_CannotGetResultsFromIncompleteOperation = "Cannot call GetResults on this asynchronous info because the underlying operation has not completed.";

        public static string InvalidOperation_CannotSetCompletionHanlderMoreThanOnce = "The 'Completed' handler delegate cannot be set more than once, but this handler has already been set.";

        public static string InvalidOperation_CannotSetStreamSizeCannotWrite = "Cannot set the size of this stream because it cannot be written to.";

        public static string InvalidOperation_IllegalStateChange = "The specified state transition is illegal for the current state of this object.";

        public static string InvalidOperation_InvalidAsyncCompletion = "The asynchronous operation could not be completed.";

        public static string InvalidOperation_MultipleIOCompletionCallbackInvocation = "A callback for the same asynchronous IO operation was invoked more than once.";

        public static string InvalidOperation_TaskProviderReturnedUnstartedTask = "The Task provider delegate specified for this IAsyncInfo instance returned a Task object that was not started. Task instances must be run immediately upon creation.";

        public static string InvalidOperation_UnexpectedAsyncOperationID = "This AsyncResult or Task corresponds to a different asynchronous operation ID than the one that invoked the completion callback.";

        public static string InvalidOperation_UnstartedTaskSpecified = "The specified underlying Task is not started. Task instances must be run immediately upon creation.";

        public static string IO_General = "An IO error occurred in the Windows runtime system.";

        public static string NotImplemented_NativeRoutineNotFound = "A native library routine was not found: {0}.";

        public static string NullReference_IOCompletionCallbackCannotProcessNullAsyncInfo = "The Windows Runtime stream that underlies this System.IO.Stream object has invoked an IO completion callback and specified null for the IAsyncInfo instance that describes the completed IO operation. This behavior is not supported because results cannot be retrieved from a null operation. Either the underlying Windows Runtime stream has a faulty implementation, or you are using a Windows Runtime object in an unsupported runtime environment.";

        public static string NullReference_TaskProviderReturnedNull = "The task provider delegate used to create this asynchronous operation returned null, but a valid Task object was expected.";

        public static string ObjectDisposed_AsyncInfoIsClosed = "The requested invocation is not permitted because this IAsyncInfo instance has already been closed.";

        public static string ObjectDisposed_CannotPerformOperation = "The requested operation cannot be performed because this stream has already been disposed.";

        public static string WinRtCOM_Error = "An error has occurred.";

        public static string Argument_InvalidSeekOrigin = "Invalid seek origin.";

        public static string InvalidOperation_SendNotSupportedOnWindowsrTSynchronizationContext = "Send is not supported in the Windows Runtime SynchronizationContext";
    
        public static string InvalidAction = "Invalid action value: '{0}'.";

    }
}
